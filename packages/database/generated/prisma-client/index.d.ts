
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model MemberRecharge
 * 
 */
export type MemberRecharge = $Result.DefaultSelection<Prisma.$MemberRechargePayload>
/**
 * Model MemberWithdraw
 * 
 */
export type MemberWithdraw = $Result.DefaultSelection<Prisma.$MemberWithdrawPayload>
/**
 * Model StockSymbol
 * 
 */
export type StockSymbol = $Result.DefaultSelection<Prisma.$StockSymbolPayload>
/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>
/**
 * Model StockRecord
 * 
 */
export type StockRecord = $Result.DefaultSelection<Prisma.$StockRecordPayload>
/**
 * Model StockMarket
 * 
 */
export type StockMarket = $Result.DefaultSelection<Prisma.$StockMarketPayload>
/**
 * Model StockFavorite
 * 
 */
export type StockFavorite = $Result.DefaultSelection<Prisma.$StockFavoritePayload>
/**
 * Model StockSubscribe
 * 
 */
export type StockSubscribe = $Result.DefaultSelection<Prisma.$StockSubscribePayload>
/**
 * Model MemberSubscribe
 * 
 */
export type MemberSubscribe = $Result.DefaultSelection<Prisma.$MemberSubscribePayload>
/**
 * Model StockPosition
 * 
 */
export type StockPosition = $Result.DefaultSelection<Prisma.$StockPositionPayload>
/**
 * Model MemberDetail
 * 
 */
export type MemberDetail = $Result.DefaultSelection<Prisma.$MemberDetailPayload>
/**
 * Model MemberCard
 * 
 */
export type MemberCard = $Result.DefaultSelection<Prisma.$MemberCardPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model StockResource
 * 
 */
export type StockResource = $Result.DefaultSelection<Prisma.$StockResourcePayload>
/**
 * Model StockResourceRecord
 * 
 */
export type StockResourceRecord = $Result.DefaultSelection<Prisma.$StockResourceRecordPayload>
/**
 * Model Article
 * 
 */
export type Article = $Result.DefaultSelection<Prisma.$ArticlePayload>
/**
 * Model Recharge
 * 
 */
export type Recharge = $Result.DefaultSelection<Prisma.$RechargePayload>
/**
 * Model Withdraw
 * 
 */
export type Withdraw = $Result.DefaultSelection<Prisma.$WithdrawPayload>
/**
 * Model RechargeAccount
 * 
 */
export type RechargeAccount = $Result.DefaultSelection<Prisma.$RechargeAccountPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const GENDER: {
  UNKNOWN: 'UNKNOWN',
  MAN: 'MAN',
  WOMAN: 'WOMAN'
};

export type GENDER = (typeof GENDER)[keyof typeof GENDER]


export const STOCK_STATUS: {
  NORMAL: 'NORMAL',
  DISABLE: 'DISABLE',
  DOWN: 'DOWN'
};

export type STOCK_STATUS = (typeof STOCK_STATUS)[keyof typeof STOCK_STATUS]


export const RechargeType: {
  CARD: 'CARD',
  CRYPTO: 'CRYPTO'
};

export type RechargeType = (typeof RechargeType)[keyof typeof RechargeType]

}

export type GENDER = $Enums.GENDER

export const GENDER: typeof $Enums.GENDER

export type STOCK_STATUS = $Enums.STOCK_STATUS

export const STOCK_STATUS: typeof $Enums.STOCK_STATUS

export type RechargeType = $Enums.RechargeType

export const RechargeType: typeof $Enums.RechargeType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs>;

  /**
   * `prisma.memberRecharge`: Exposes CRUD operations for the **MemberRecharge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberRecharges
    * const memberRecharges = await prisma.memberRecharge.findMany()
    * ```
    */
  get memberRecharge(): Prisma.MemberRechargeDelegate<ExtArgs>;

  /**
   * `prisma.memberWithdraw`: Exposes CRUD operations for the **MemberWithdraw** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberWithdraws
    * const memberWithdraws = await prisma.memberWithdraw.findMany()
    * ```
    */
  get memberWithdraw(): Prisma.MemberWithdrawDelegate<ExtArgs>;

  /**
   * `prisma.stockSymbol`: Exposes CRUD operations for the **StockSymbol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockSymbols
    * const stockSymbols = await prisma.stockSymbol.findMany()
    * ```
    */
  get stockSymbol(): Prisma.StockSymbolDelegate<ExtArgs>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs>;

  /**
   * `prisma.stockRecord`: Exposes CRUD operations for the **StockRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockRecords
    * const stockRecords = await prisma.stockRecord.findMany()
    * ```
    */
  get stockRecord(): Prisma.StockRecordDelegate<ExtArgs>;

  /**
   * `prisma.stockMarket`: Exposes CRUD operations for the **StockMarket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMarkets
    * const stockMarkets = await prisma.stockMarket.findMany()
    * ```
    */
  get stockMarket(): Prisma.StockMarketDelegate<ExtArgs>;

  /**
   * `prisma.stockFavorite`: Exposes CRUD operations for the **StockFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockFavorites
    * const stockFavorites = await prisma.stockFavorite.findMany()
    * ```
    */
  get stockFavorite(): Prisma.StockFavoriteDelegate<ExtArgs>;

  /**
   * `prisma.stockSubscribe`: Exposes CRUD operations for the **StockSubscribe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockSubscribes
    * const stockSubscribes = await prisma.stockSubscribe.findMany()
    * ```
    */
  get stockSubscribe(): Prisma.StockSubscribeDelegate<ExtArgs>;

  /**
   * `prisma.memberSubscribe`: Exposes CRUD operations for the **MemberSubscribe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberSubscribes
    * const memberSubscribes = await prisma.memberSubscribe.findMany()
    * ```
    */
  get memberSubscribe(): Prisma.MemberSubscribeDelegate<ExtArgs>;

  /**
   * `prisma.stockPosition`: Exposes CRUD operations for the **StockPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockPositions
    * const stockPositions = await prisma.stockPosition.findMany()
    * ```
    */
  get stockPosition(): Prisma.StockPositionDelegate<ExtArgs>;

  /**
   * `prisma.memberDetail`: Exposes CRUD operations for the **MemberDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberDetails
    * const memberDetails = await prisma.memberDetail.findMany()
    * ```
    */
  get memberDetail(): Prisma.MemberDetailDelegate<ExtArgs>;

  /**
   * `prisma.memberCard`: Exposes CRUD operations for the **MemberCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MemberCards
    * const memberCards = await prisma.memberCard.findMany()
    * ```
    */
  get memberCard(): Prisma.MemberCardDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs>;

  /**
   * `prisma.stockResource`: Exposes CRUD operations for the **StockResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockResources
    * const stockResources = await prisma.stockResource.findMany()
    * ```
    */
  get stockResource(): Prisma.StockResourceDelegate<ExtArgs>;

  /**
   * `prisma.stockResourceRecord`: Exposes CRUD operations for the **StockResourceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockResourceRecords
    * const stockResourceRecords = await prisma.stockResourceRecord.findMany()
    * ```
    */
  get stockResourceRecord(): Prisma.StockResourceRecordDelegate<ExtArgs>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<ExtArgs>;

  /**
   * `prisma.recharge`: Exposes CRUD operations for the **Recharge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recharges
    * const recharges = await prisma.recharge.findMany()
    * ```
    */
  get recharge(): Prisma.RechargeDelegate<ExtArgs>;

  /**
   * `prisma.withdraw`: Exposes CRUD operations for the **Withdraw** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdraws
    * const withdraws = await prisma.withdraw.findMany()
    * ```
    */
  get withdraw(): Prisma.WithdrawDelegate<ExtArgs>;

  /**
   * `prisma.rechargeAccount`: Exposes CRUD operations for the **RechargeAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RechargeAccounts
    * const rechargeAccounts = await prisma.rechargeAccount.findMany()
    * ```
    */
  get rechargeAccount(): Prisma.RechargeAccountDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Member: 'Member',
    MemberRecharge: 'MemberRecharge',
    MemberWithdraw: 'MemberWithdraw',
    StockSymbol: 'StockSymbol',
    Stock: 'Stock',
    StockRecord: 'StockRecord',
    StockMarket: 'StockMarket',
    StockFavorite: 'StockFavorite',
    StockSubscribe: 'StockSubscribe',
    MemberSubscribe: 'MemberSubscribe',
    StockPosition: 'StockPosition',
    MemberDetail: 'MemberDetail',
    MemberCard: 'MemberCard',
    Country: 'Country',
    Setting: 'Setting',
    StockResource: 'StockResource',
    StockResourceRecord: 'StockResourceRecord',
    Article: 'Article',
    Recharge: 'Recharge',
    Withdraw: 'Withdraw',
    RechargeAccount: 'RechargeAccount'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'member' | 'memberRecharge' | 'memberWithdraw' | 'stockSymbol' | 'stock' | 'stockRecord' | 'stockMarket' | 'stockFavorite' | 'stockSubscribe' | 'memberSubscribe' | 'stockPosition' | 'memberDetail' | 'memberCard' | 'country' | 'setting' | 'stockResource' | 'stockResourceRecord' | 'article' | 'recharge' | 'withdraw' | 'rechargeAccount'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>,
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      MemberRecharge: {
        payload: Prisma.$MemberRechargePayload<ExtArgs>
        fields: Prisma.MemberRechargeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberRechargeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberRechargePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberRechargeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberRechargePayload>
          }
          findFirst: {
            args: Prisma.MemberRechargeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberRechargePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberRechargeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberRechargePayload>
          }
          findMany: {
            args: Prisma.MemberRechargeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberRechargePayload>[]
          }
          create: {
            args: Prisma.MemberRechargeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberRechargePayload>
          }
          createMany: {
            args: Prisma.MemberRechargeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MemberRechargeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberRechargePayload>
          }
          update: {
            args: Prisma.MemberRechargeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberRechargePayload>
          }
          deleteMany: {
            args: Prisma.MemberRechargeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MemberRechargeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MemberRechargeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberRechargePayload>
          }
          aggregate: {
            args: Prisma.MemberRechargeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMemberRecharge>
          }
          groupBy: {
            args: Prisma.MemberRechargeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MemberRechargeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberRechargeCountArgs<ExtArgs>,
            result: $Utils.Optional<MemberRechargeCountAggregateOutputType> | number
          }
        }
      }
      MemberWithdraw: {
        payload: Prisma.$MemberWithdrawPayload<ExtArgs>
        fields: Prisma.MemberWithdrawFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberWithdrawFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberWithdrawPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberWithdrawFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberWithdrawPayload>
          }
          findFirst: {
            args: Prisma.MemberWithdrawFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberWithdrawPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberWithdrawFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberWithdrawPayload>
          }
          findMany: {
            args: Prisma.MemberWithdrawFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberWithdrawPayload>[]
          }
          create: {
            args: Prisma.MemberWithdrawCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberWithdrawPayload>
          }
          createMany: {
            args: Prisma.MemberWithdrawCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MemberWithdrawDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberWithdrawPayload>
          }
          update: {
            args: Prisma.MemberWithdrawUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberWithdrawPayload>
          }
          deleteMany: {
            args: Prisma.MemberWithdrawDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MemberWithdrawUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MemberWithdrawUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberWithdrawPayload>
          }
          aggregate: {
            args: Prisma.MemberWithdrawAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMemberWithdraw>
          }
          groupBy: {
            args: Prisma.MemberWithdrawGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MemberWithdrawGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberWithdrawCountArgs<ExtArgs>,
            result: $Utils.Optional<MemberWithdrawCountAggregateOutputType> | number
          }
        }
      }
      StockSymbol: {
        payload: Prisma.$StockSymbolPayload<ExtArgs>
        fields: Prisma.StockSymbolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockSymbolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSymbolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockSymbolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSymbolPayload>
          }
          findFirst: {
            args: Prisma.StockSymbolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSymbolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockSymbolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSymbolPayload>
          }
          findMany: {
            args: Prisma.StockSymbolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSymbolPayload>[]
          }
          create: {
            args: Prisma.StockSymbolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSymbolPayload>
          }
          createMany: {
            args: Prisma.StockSymbolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockSymbolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSymbolPayload>
          }
          update: {
            args: Prisma.StockSymbolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSymbolPayload>
          }
          deleteMany: {
            args: Prisma.StockSymbolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockSymbolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockSymbolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSymbolPayload>
          }
          aggregate: {
            args: Prisma.StockSymbolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockSymbol>
          }
          groupBy: {
            args: Prisma.StockSymbolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockSymbolGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockSymbolCountArgs<ExtArgs>,
            result: $Utils.Optional<StockSymbolCountAggregateOutputType> | number
          }
        }
      }
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>,
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
      StockRecord: {
        payload: Prisma.$StockRecordPayload<ExtArgs>
        fields: Prisma.StockRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockRecordPayload>
          }
          findFirst: {
            args: Prisma.StockRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockRecordPayload>
          }
          findMany: {
            args: Prisma.StockRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockRecordPayload>[]
          }
          create: {
            args: Prisma.StockRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockRecordPayload>
          }
          createMany: {
            args: Prisma.StockRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockRecordPayload>
          }
          update: {
            args: Prisma.StockRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockRecordPayload>
          }
          deleteMany: {
            args: Prisma.StockRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockRecordPayload>
          }
          aggregate: {
            args: Prisma.StockRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockRecord>
          }
          groupBy: {
            args: Prisma.StockRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<StockRecordCountAggregateOutputType> | number
          }
        }
      }
      StockMarket: {
        payload: Prisma.$StockMarketPayload<ExtArgs>
        fields: Prisma.StockMarketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMarketFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMarketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMarketFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMarketPayload>
          }
          findFirst: {
            args: Prisma.StockMarketFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMarketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMarketFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMarketPayload>
          }
          findMany: {
            args: Prisma.StockMarketFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMarketPayload>[]
          }
          create: {
            args: Prisma.StockMarketCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMarketPayload>
          }
          createMany: {
            args: Prisma.StockMarketCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockMarketDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMarketPayload>
          }
          update: {
            args: Prisma.StockMarketUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMarketPayload>
          }
          deleteMany: {
            args: Prisma.StockMarketDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockMarketUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockMarketUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockMarketPayload>
          }
          aggregate: {
            args: Prisma.StockMarketAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockMarket>
          }
          groupBy: {
            args: Prisma.StockMarketGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockMarketGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMarketCountArgs<ExtArgs>,
            result: $Utils.Optional<StockMarketCountAggregateOutputType> | number
          }
        }
      }
      StockFavorite: {
        payload: Prisma.$StockFavoritePayload<ExtArgs>
        fields: Prisma.StockFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFavoriteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFavoriteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockFavoritePayload>
          }
          findFirst: {
            args: Prisma.StockFavoriteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFavoriteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockFavoritePayload>
          }
          findMany: {
            args: Prisma.StockFavoriteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockFavoritePayload>[]
          }
          create: {
            args: Prisma.StockFavoriteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockFavoritePayload>
          }
          createMany: {
            args: Prisma.StockFavoriteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockFavoriteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockFavoritePayload>
          }
          update: {
            args: Prisma.StockFavoriteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockFavoritePayload>
          }
          deleteMany: {
            args: Prisma.StockFavoriteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockFavoriteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockFavoriteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockFavoritePayload>
          }
          aggregate: {
            args: Prisma.StockFavoriteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockFavorite>
          }
          groupBy: {
            args: Prisma.StockFavoriteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockFavoriteCountArgs<ExtArgs>,
            result: $Utils.Optional<StockFavoriteCountAggregateOutputType> | number
          }
        }
      }
      StockSubscribe: {
        payload: Prisma.$StockSubscribePayload<ExtArgs>
        fields: Prisma.StockSubscribeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockSubscribeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSubscribePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockSubscribeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSubscribePayload>
          }
          findFirst: {
            args: Prisma.StockSubscribeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSubscribePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockSubscribeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSubscribePayload>
          }
          findMany: {
            args: Prisma.StockSubscribeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSubscribePayload>[]
          }
          create: {
            args: Prisma.StockSubscribeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSubscribePayload>
          }
          createMany: {
            args: Prisma.StockSubscribeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockSubscribeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSubscribePayload>
          }
          update: {
            args: Prisma.StockSubscribeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSubscribePayload>
          }
          deleteMany: {
            args: Prisma.StockSubscribeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockSubscribeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockSubscribeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockSubscribePayload>
          }
          aggregate: {
            args: Prisma.StockSubscribeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockSubscribe>
          }
          groupBy: {
            args: Prisma.StockSubscribeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockSubscribeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockSubscribeCountArgs<ExtArgs>,
            result: $Utils.Optional<StockSubscribeCountAggregateOutputType> | number
          }
        }
      }
      MemberSubscribe: {
        payload: Prisma.$MemberSubscribePayload<ExtArgs>
        fields: Prisma.MemberSubscribeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberSubscribeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberSubscribePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberSubscribeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberSubscribePayload>
          }
          findFirst: {
            args: Prisma.MemberSubscribeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberSubscribePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberSubscribeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberSubscribePayload>
          }
          findMany: {
            args: Prisma.MemberSubscribeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberSubscribePayload>[]
          }
          create: {
            args: Prisma.MemberSubscribeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberSubscribePayload>
          }
          createMany: {
            args: Prisma.MemberSubscribeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MemberSubscribeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberSubscribePayload>
          }
          update: {
            args: Prisma.MemberSubscribeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberSubscribePayload>
          }
          deleteMany: {
            args: Prisma.MemberSubscribeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MemberSubscribeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MemberSubscribeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberSubscribePayload>
          }
          aggregate: {
            args: Prisma.MemberSubscribeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMemberSubscribe>
          }
          groupBy: {
            args: Prisma.MemberSubscribeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MemberSubscribeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberSubscribeCountArgs<ExtArgs>,
            result: $Utils.Optional<MemberSubscribeCountAggregateOutputType> | number
          }
        }
      }
      StockPosition: {
        payload: Prisma.$StockPositionPayload<ExtArgs>
        fields: Prisma.StockPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockPositionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockPositionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPositionPayload>
          }
          findFirst: {
            args: Prisma.StockPositionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockPositionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPositionPayload>
          }
          findMany: {
            args: Prisma.StockPositionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPositionPayload>[]
          }
          create: {
            args: Prisma.StockPositionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPositionPayload>
          }
          createMany: {
            args: Prisma.StockPositionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockPositionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPositionPayload>
          }
          update: {
            args: Prisma.StockPositionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPositionPayload>
          }
          deleteMany: {
            args: Prisma.StockPositionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockPositionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockPositionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockPositionPayload>
          }
          aggregate: {
            args: Prisma.StockPositionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockPosition>
          }
          groupBy: {
            args: Prisma.StockPositionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockPositionCountArgs<ExtArgs>,
            result: $Utils.Optional<StockPositionCountAggregateOutputType> | number
          }
        }
      }
      MemberDetail: {
        payload: Prisma.$MemberDetailPayload<ExtArgs>
        fields: Prisma.MemberDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberDetailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberDetailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberDetailPayload>
          }
          findFirst: {
            args: Prisma.MemberDetailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberDetailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberDetailPayload>
          }
          findMany: {
            args: Prisma.MemberDetailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberDetailPayload>[]
          }
          create: {
            args: Prisma.MemberDetailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberDetailPayload>
          }
          createMany: {
            args: Prisma.MemberDetailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MemberDetailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberDetailPayload>
          }
          update: {
            args: Prisma.MemberDetailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberDetailPayload>
          }
          deleteMany: {
            args: Prisma.MemberDetailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MemberDetailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MemberDetailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberDetailPayload>
          }
          aggregate: {
            args: Prisma.MemberDetailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMemberDetail>
          }
          groupBy: {
            args: Prisma.MemberDetailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MemberDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberDetailCountArgs<ExtArgs>,
            result: $Utils.Optional<MemberDetailCountAggregateOutputType> | number
          }
        }
      }
      MemberCard: {
        payload: Prisma.$MemberCardPayload<ExtArgs>
        fields: Prisma.MemberCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberCardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberCardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberCardPayload>
          }
          findFirst: {
            args: Prisma.MemberCardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberCardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberCardPayload>
          }
          findMany: {
            args: Prisma.MemberCardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberCardPayload>[]
          }
          create: {
            args: Prisma.MemberCardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberCardPayload>
          }
          createMany: {
            args: Prisma.MemberCardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MemberCardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberCardPayload>
          }
          update: {
            args: Prisma.MemberCardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberCardPayload>
          }
          deleteMany: {
            args: Prisma.MemberCardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MemberCardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MemberCardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MemberCardPayload>
          }
          aggregate: {
            args: Prisma.MemberCardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMemberCard>
          }
          groupBy: {
            args: Prisma.MemberCardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MemberCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCardCountArgs<ExtArgs>,
            result: $Utils.Optional<MemberCardCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>,
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>,
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      StockResource: {
        payload: Prisma.$StockResourcePayload<ExtArgs>
        fields: Prisma.StockResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockResourceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockResourceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourcePayload>
          }
          findFirst: {
            args: Prisma.StockResourceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockResourceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourcePayload>
          }
          findMany: {
            args: Prisma.StockResourceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourcePayload>[]
          }
          create: {
            args: Prisma.StockResourceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourcePayload>
          }
          createMany: {
            args: Prisma.StockResourceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockResourceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourcePayload>
          }
          update: {
            args: Prisma.StockResourceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourcePayload>
          }
          deleteMany: {
            args: Prisma.StockResourceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockResourceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockResourceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourcePayload>
          }
          aggregate: {
            args: Prisma.StockResourceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockResource>
          }
          groupBy: {
            args: Prisma.StockResourceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockResourceCountArgs<ExtArgs>,
            result: $Utils.Optional<StockResourceCountAggregateOutputType> | number
          }
        }
      }
      StockResourceRecord: {
        payload: Prisma.$StockResourceRecordPayload<ExtArgs>
        fields: Prisma.StockResourceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockResourceRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockResourceRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourceRecordPayload>
          }
          findFirst: {
            args: Prisma.StockResourceRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockResourceRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourceRecordPayload>
          }
          findMany: {
            args: Prisma.StockResourceRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourceRecordPayload>[]
          }
          create: {
            args: Prisma.StockResourceRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourceRecordPayload>
          }
          createMany: {
            args: Prisma.StockResourceRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StockResourceRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourceRecordPayload>
          }
          update: {
            args: Prisma.StockResourceRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourceRecordPayload>
          }
          deleteMany: {
            args: Prisma.StockResourceRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StockResourceRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StockResourceRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StockResourceRecordPayload>
          }
          aggregate: {
            args: Prisma.StockResourceRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStockResourceRecord>
          }
          groupBy: {
            args: Prisma.StockResourceRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StockResourceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockResourceRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<StockResourceRecordCountAggregateOutputType> | number
          }
        }
      }
      Article: {
        payload: Prisma.$ArticlePayload<ExtArgs>
        fields: Prisma.ArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>,
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      Recharge: {
        payload: Prisma.$RechargePayload<ExtArgs>
        fields: Prisma.RechargeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RechargeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RechargeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargePayload>
          }
          findFirst: {
            args: Prisma.RechargeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RechargeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargePayload>
          }
          findMany: {
            args: Prisma.RechargeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargePayload>[]
          }
          create: {
            args: Prisma.RechargeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargePayload>
          }
          createMany: {
            args: Prisma.RechargeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RechargeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargePayload>
          }
          update: {
            args: Prisma.RechargeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargePayload>
          }
          deleteMany: {
            args: Prisma.RechargeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RechargeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RechargeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargePayload>
          }
          aggregate: {
            args: Prisma.RechargeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecharge>
          }
          groupBy: {
            args: Prisma.RechargeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RechargeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RechargeCountArgs<ExtArgs>,
            result: $Utils.Optional<RechargeCountAggregateOutputType> | number
          }
        }
      }
      Withdraw: {
        payload: Prisma.$WithdrawPayload<ExtArgs>
        fields: Prisma.WithdrawFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WithdrawFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WithdrawPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WithdrawFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WithdrawPayload>
          }
          findFirst: {
            args: Prisma.WithdrawFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WithdrawPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WithdrawFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WithdrawPayload>
          }
          findMany: {
            args: Prisma.WithdrawFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WithdrawPayload>[]
          }
          create: {
            args: Prisma.WithdrawCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WithdrawPayload>
          }
          createMany: {
            args: Prisma.WithdrawCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WithdrawDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WithdrawPayload>
          }
          update: {
            args: Prisma.WithdrawUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WithdrawPayload>
          }
          deleteMany: {
            args: Prisma.WithdrawDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WithdrawUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WithdrawUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WithdrawPayload>
          }
          aggregate: {
            args: Prisma.WithdrawAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWithdraw>
          }
          groupBy: {
            args: Prisma.WithdrawGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WithdrawGroupByOutputType>[]
          }
          count: {
            args: Prisma.WithdrawCountArgs<ExtArgs>,
            result: $Utils.Optional<WithdrawCountAggregateOutputType> | number
          }
        }
      }
      RechargeAccount: {
        payload: Prisma.$RechargeAccountPayload<ExtArgs>
        fields: Prisma.RechargeAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RechargeAccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargeAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RechargeAccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargeAccountPayload>
          }
          findFirst: {
            args: Prisma.RechargeAccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargeAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RechargeAccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargeAccountPayload>
          }
          findMany: {
            args: Prisma.RechargeAccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargeAccountPayload>[]
          }
          create: {
            args: Prisma.RechargeAccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargeAccountPayload>
          }
          createMany: {
            args: Prisma.RechargeAccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RechargeAccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargeAccountPayload>
          }
          update: {
            args: Prisma.RechargeAccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargeAccountPayload>
          }
          deleteMany: {
            args: Prisma.RechargeAccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RechargeAccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RechargeAccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RechargeAccountPayload>
          }
          aggregate: {
            args: Prisma.RechargeAccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRechargeAccount>
          }
          groupBy: {
            args: Prisma.RechargeAccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RechargeAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.RechargeAccountCountArgs<ExtArgs>,
            result: $Utils.Optional<RechargeAccountCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    stockPostion: number
    memberDetail: number
    memberSubscribe: number
    memberRecharges: number
    memberWithdraws: number
    memberCards: number
    recharges: number
    withdraws: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockPostion?: boolean | MemberCountOutputTypeCountStockPostionArgs
    memberDetail?: boolean | MemberCountOutputTypeCountMemberDetailArgs
    memberSubscribe?: boolean | MemberCountOutputTypeCountMemberSubscribeArgs
    memberRecharges?: boolean | MemberCountOutputTypeCountMemberRechargesArgs
    memberWithdraws?: boolean | MemberCountOutputTypeCountMemberWithdrawsArgs
    memberCards?: boolean | MemberCountOutputTypeCountMemberCardsArgs
    recharges?: boolean | MemberCountOutputTypeCountRechargesArgs
    withdraws?: boolean | MemberCountOutputTypeCountWithdrawsArgs
  }

  // Custom InputTypes

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountStockPostionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockPositionWhereInput
  }


  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMemberDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberDetailWhereInput
  }


  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMemberSubscribeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberSubscribeWhereInput
  }


  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMemberRechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberRechargeWhereInput
  }


  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMemberWithdrawsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWithdrawWhereInput
  }


  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountMemberCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberCardWhereInput
  }


  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountRechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RechargeWhereInput
  }


  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountWithdrawsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawWhereInput
  }



  /**
   * Count Type StockSymbolCountOutputType
   */

  export type StockSymbolCountOutputType = {
    stockPostion: number
  }

  export type StockSymbolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockPostion?: boolean | StockSymbolCountOutputTypeCountStockPostionArgs
  }

  // Custom InputTypes

  /**
   * StockSymbolCountOutputType without action
   */
  export type StockSymbolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbolCountOutputType
     */
    select?: StockSymbolCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StockSymbolCountOutputType without action
   */
  export type StockSymbolCountOutputTypeCountStockPostionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockPositionWhereInput
  }



  /**
   * Count Type StockCountOutputType
   */

  export type StockCountOutputType = {
    stockRecord: number
  }

  export type StockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockRecord?: boolean | StockCountOutputTypeCountStockRecordArgs
  }

  // Custom InputTypes

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCountOutputType
     */
    select?: StockCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountStockRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockRecordWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: bigint | null
  }

  export type UserMinAggregateOutputType = {
    id: bigint | null
    email: string | null
    name: string | null
    avatar: string | null
    password: string | null
    gender: $Enums.GENDER | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: bigint | null
    email: string | null
    name: string | null
    avatar: string | null
    password: string | null
    gender: $Enums.GENDER | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatar: number
    password: number
    gender: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    password?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    password?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    password?: true
    gender?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: bigint
    email: string
    name: string | null
    avatar: string | null
    password: string
    gender: $Enums.GENDER
    createdAt: Date
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    password?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    password?: boolean
    gender?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      email: string
      name: string | null
      avatar: string | null
      password: string
      gender: $Enums.GENDER
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'BigInt'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'GENDER'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }



  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    id: number | null
    status: number | null
    type: number | null
    balance: Decimal | null
    unBalance: Decimal | null
    lockBalance: Decimal | null
  }

  export type MemberSumAggregateOutputType = {
    id: bigint | null
    status: number | null
    type: number | null
    balance: Decimal | null
    unBalance: Decimal | null
    lockBalance: Decimal | null
  }

  export type MemberMinAggregateOutputType = {
    id: bigint | null
    email: string | null
    name: string | null
    avatar: string | null
    password: string | null
    gender: $Enums.GENDER | null
    address: string | null
    status: number | null
    type: number | null
    createdAt: Date | null
    updatedAt: Date | null
    balance: Decimal | null
    unBalance: Decimal | null
    lockBalance: Decimal | null
    lastLoginTime: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: bigint | null
    email: string | null
    name: string | null
    avatar: string | null
    password: string | null
    gender: $Enums.GENDER | null
    address: string | null
    status: number | null
    type: number | null
    createdAt: Date | null
    updatedAt: Date | null
    balance: Decimal | null
    unBalance: Decimal | null
    lockBalance: Decimal | null
    lastLoginTime: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatar: number
    password: number
    gender: number
    address: number
    accountBalance: number
    status: number
    type: number
    createdAt: number
    updatedAt: number
    balance: number
    unBalance: number
    lockBalance: number
    lastLoginTime: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    id?: true
    status?: true
    type?: true
    balance?: true
    unBalance?: true
    lockBalance?: true
  }

  export type MemberSumAggregateInputType = {
    id?: true
    status?: true
    type?: true
    balance?: true
    unBalance?: true
    lockBalance?: true
  }

  export type MemberMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    password?: true
    gender?: true
    address?: true
    status?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    balance?: true
    unBalance?: true
    lockBalance?: true
    lastLoginTime?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    password?: true
    gender?: true
    address?: true
    status?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    balance?: true
    unBalance?: true
    lockBalance?: true
    lastLoginTime?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    password?: true
    gender?: true
    address?: true
    accountBalance?: true
    status?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    balance?: true
    unBalance?: true
    lockBalance?: true
    lastLoginTime?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: bigint
    email: string
    name: string | null
    avatar: string | null
    password: string
    gender: $Enums.GENDER
    address: string | null
    accountBalance: JsonValue | null
    status: number
    type: number
    createdAt: Date
    updatedAt: Date | null
    balance: Decimal
    unBalance: Decimal
    lockBalance: Decimal
    lastLoginTime: Date | null
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    password?: boolean
    gender?: boolean
    address?: boolean
    accountBalance?: boolean
    status?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    balance?: boolean
    unBalance?: boolean
    lockBalance?: boolean
    lastLoginTime?: boolean
    stockPostion?: boolean | Member$stockPostionArgs<ExtArgs>
    memberDetail?: boolean | Member$memberDetailArgs<ExtArgs>
    memberSubscribe?: boolean | Member$memberSubscribeArgs<ExtArgs>
    memberRecharges?: boolean | Member$memberRechargesArgs<ExtArgs>
    memberWithdraws?: boolean | Member$memberWithdrawsArgs<ExtArgs>
    memberCards?: boolean | Member$memberCardsArgs<ExtArgs>
    recharges?: boolean | Member$rechargesArgs<ExtArgs>
    withdraws?: boolean | Member$withdrawsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    password?: boolean
    gender?: boolean
    address?: boolean
    accountBalance?: boolean
    status?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    balance?: boolean
    unBalance?: boolean
    lockBalance?: boolean
    lastLoginTime?: boolean
  }

  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockPostion?: boolean | Member$stockPostionArgs<ExtArgs>
    memberDetail?: boolean | Member$memberDetailArgs<ExtArgs>
    memberSubscribe?: boolean | Member$memberSubscribeArgs<ExtArgs>
    memberRecharges?: boolean | Member$memberRechargesArgs<ExtArgs>
    memberWithdraws?: boolean | Member$memberWithdrawsArgs<ExtArgs>
    memberCards?: boolean | Member$memberCardsArgs<ExtArgs>
    recharges?: boolean | Member$rechargesArgs<ExtArgs>
    withdraws?: boolean | Member$withdrawsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      stockPostion: Prisma.$StockPositionPayload<ExtArgs>[]
      memberDetail: Prisma.$MemberDetailPayload<ExtArgs>[]
      memberSubscribe: Prisma.$MemberSubscribePayload<ExtArgs>[]
      memberRecharges: Prisma.$MemberRechargePayload<ExtArgs>[]
      memberWithdraws: Prisma.$MemberWithdrawPayload<ExtArgs>[]
      memberCards: Prisma.$MemberCardPayload<ExtArgs>[]
      recharges: Prisma.$RechargePayload<ExtArgs>[]
      withdraws: Prisma.$WithdrawPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      email: string
      name: string | null
      avatar: string | null
      password: string
      gender: $Enums.GENDER
      address: string | null
      accountBalance: Prisma.JsonValue | null
      status: number
      type: number
      createdAt: Date
      updatedAt: Date | null
      balance: Prisma.Decimal
      unBalance: Prisma.Decimal
      lockBalance: Prisma.Decimal
      lastLoginTime: Date | null
    }, ExtArgs["result"]["member"]>
    composites: {}
  }


  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Member that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MemberFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
    **/
    create<T extends MemberCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberCreateArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Members.
     *     @param {MemberCreateManyArgs} args - Arguments to create many Members.
     *     @example
     *     // Create many Members
     *     const member = await prisma.member.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
    **/
    delete<T extends MemberDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
    **/
    upsert<T extends MemberUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>
    ): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stockPostion<T extends Member$stockPostionArgs<ExtArgs> = {}>(args?: Subset<T, Member$stockPostionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'findMany'> | Null>;

    memberDetail<T extends Member$memberDetailArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'findMany'> | Null>;

    memberSubscribe<T extends Member$memberSubscribeArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberSubscribeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'findMany'> | Null>;

    memberRecharges<T extends Member$memberRechargesArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberRechargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'findMany'> | Null>;

    memberWithdraws<T extends Member$memberWithdrawsArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberWithdrawsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'findMany'> | Null>;

    memberCards<T extends Member$memberCardsArgs<ExtArgs> = {}>(args?: Subset<T, Member$memberCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'findMany'> | Null>;

    recharges<T extends Member$rechargesArgs<ExtArgs> = {}>(args?: Subset<T, Member$rechargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'findMany'> | Null>;

    withdraws<T extends Member$withdrawsArgs<ExtArgs> = {}>(args?: Subset<T, Member$withdrawsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Member model
   */ 
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'BigInt'>
    readonly email: FieldRef<"Member", 'String'>
    readonly name: FieldRef<"Member", 'String'>
    readonly avatar: FieldRef<"Member", 'String'>
    readonly password: FieldRef<"Member", 'String'>
    readonly gender: FieldRef<"Member", 'GENDER'>
    readonly address: FieldRef<"Member", 'String'>
    readonly accountBalance: FieldRef<"Member", 'Json'>
    readonly status: FieldRef<"Member", 'Int'>
    readonly type: FieldRef<"Member", 'Int'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
    readonly balance: FieldRef<"Member", 'Decimal'>
    readonly unBalance: FieldRef<"Member", 'Decimal'>
    readonly lockBalance: FieldRef<"Member", 'Decimal'>
    readonly lastLoginTime: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }


  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }


  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }


  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }


  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
  }


  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }


  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
  }


  /**
   * Member.stockPostion
   */
  export type Member$stockPostionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    where?: StockPositionWhereInput
    orderBy?: StockPositionOrderByWithRelationInput | StockPositionOrderByWithRelationInput[]
    cursor?: StockPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockPositionScalarFieldEnum | StockPositionScalarFieldEnum[]
  }


  /**
   * Member.memberDetail
   */
  export type Member$memberDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    where?: MemberDetailWhereInput
    orderBy?: MemberDetailOrderByWithRelationInput | MemberDetailOrderByWithRelationInput[]
    cursor?: MemberDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberDetailScalarFieldEnum | MemberDetailScalarFieldEnum[]
  }


  /**
   * Member.memberSubscribe
   */
  export type Member$memberSubscribeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    where?: MemberSubscribeWhereInput
    orderBy?: MemberSubscribeOrderByWithRelationInput | MemberSubscribeOrderByWithRelationInput[]
    cursor?: MemberSubscribeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberSubscribeScalarFieldEnum | MemberSubscribeScalarFieldEnum[]
  }


  /**
   * Member.memberRecharges
   */
  export type Member$memberRechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    where?: MemberRechargeWhereInput
    orderBy?: MemberRechargeOrderByWithRelationInput | MemberRechargeOrderByWithRelationInput[]
    cursor?: MemberRechargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberRechargeScalarFieldEnum | MemberRechargeScalarFieldEnum[]
  }


  /**
   * Member.memberWithdraws
   */
  export type Member$memberWithdrawsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    where?: MemberWithdrawWhereInput
    orderBy?: MemberWithdrawOrderByWithRelationInput | MemberWithdrawOrderByWithRelationInput[]
    cursor?: MemberWithdrawWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberWithdrawScalarFieldEnum | MemberWithdrawScalarFieldEnum[]
  }


  /**
   * Member.memberCards
   */
  export type Member$memberCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    where?: MemberCardWhereInput
    orderBy?: MemberCardOrderByWithRelationInput | MemberCardOrderByWithRelationInput[]
    cursor?: MemberCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberCardScalarFieldEnum | MemberCardScalarFieldEnum[]
  }


  /**
   * Member.recharges
   */
  export type Member$rechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    where?: RechargeWhereInput
    orderBy?: RechargeOrderByWithRelationInput | RechargeOrderByWithRelationInput[]
    cursor?: RechargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RechargeScalarFieldEnum | RechargeScalarFieldEnum[]
  }


  /**
   * Member.withdraws
   */
  export type Member$withdrawsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    where?: WithdrawWhereInput
    orderBy?: WithdrawOrderByWithRelationInput | WithdrawOrderByWithRelationInput[]
    cursor?: WithdrawWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawScalarFieldEnum | WithdrawScalarFieldEnum[]
  }


  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude<ExtArgs> | null
  }



  /**
   * Model MemberRecharge
   */

  export type AggregateMemberRecharge = {
    _count: MemberRechargeCountAggregateOutputType | null
    _avg: MemberRechargeAvgAggregateOutputType | null
    _sum: MemberRechargeSumAggregateOutputType | null
    _min: MemberRechargeMinAggregateOutputType | null
    _max: MemberRechargeMaxAggregateOutputType | null
  }

  export type MemberRechargeAvgAggregateOutputType = {
    id: number | null
    money: Decimal | null
    rechargeMoney: Decimal | null
    status: number | null
    memberId: number | null
  }

  export type MemberRechargeSumAggregateOutputType = {
    id: bigint | null
    money: Decimal | null
    rechargeMoney: Decimal | null
    status: number | null
    memberId: bigint | null
  }

  export type MemberRechargeMinAggregateOutputType = {
    id: bigint | null
    money: Decimal | null
    rechargeMoney: Decimal | null
    market: string | null
    status: number | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberRechargeMaxAggregateOutputType = {
    id: bigint | null
    money: Decimal | null
    rechargeMoney: Decimal | null
    market: string | null
    status: number | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberRechargeCountAggregateOutputType = {
    id: number
    money: number
    rechargeMoney: number
    screen: number
    market: number
    status: number
    memberId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberRechargeAvgAggregateInputType = {
    id?: true
    money?: true
    rechargeMoney?: true
    status?: true
    memberId?: true
  }

  export type MemberRechargeSumAggregateInputType = {
    id?: true
    money?: true
    rechargeMoney?: true
    status?: true
    memberId?: true
  }

  export type MemberRechargeMinAggregateInputType = {
    id?: true
    money?: true
    rechargeMoney?: true
    market?: true
    status?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberRechargeMaxAggregateInputType = {
    id?: true
    money?: true
    rechargeMoney?: true
    market?: true
    status?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberRechargeCountAggregateInputType = {
    id?: true
    money?: true
    rechargeMoney?: true
    screen?: true
    market?: true
    status?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberRechargeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberRecharge to aggregate.
     */
    where?: MemberRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberRecharges to fetch.
     */
    orderBy?: MemberRechargeOrderByWithRelationInput | MemberRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberRecharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberRecharges
    **/
    _count?: true | MemberRechargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberRechargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberRechargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberRechargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberRechargeMaxAggregateInputType
  }

  export type GetMemberRechargeAggregateType<T extends MemberRechargeAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberRecharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberRecharge[P]>
      : GetScalarType<T[P], AggregateMemberRecharge[P]>
  }




  export type MemberRechargeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberRechargeWhereInput
    orderBy?: MemberRechargeOrderByWithAggregationInput | MemberRechargeOrderByWithAggregationInput[]
    by: MemberRechargeScalarFieldEnum[] | MemberRechargeScalarFieldEnum
    having?: MemberRechargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberRechargeCountAggregateInputType | true
    _avg?: MemberRechargeAvgAggregateInputType
    _sum?: MemberRechargeSumAggregateInputType
    _min?: MemberRechargeMinAggregateInputType
    _max?: MemberRechargeMaxAggregateInputType
  }

  export type MemberRechargeGroupByOutputType = {
    id: bigint
    money: Decimal
    rechargeMoney: Decimal
    screen: JsonValue
    market: string
    status: number
    memberId: bigint
    createdAt: Date
    updatedAt: Date | null
    _count: MemberRechargeCountAggregateOutputType | null
    _avg: MemberRechargeAvgAggregateOutputType | null
    _sum: MemberRechargeSumAggregateOutputType | null
    _min: MemberRechargeMinAggregateOutputType | null
    _max: MemberRechargeMaxAggregateOutputType | null
  }

  type GetMemberRechargeGroupByPayload<T extends MemberRechargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberRechargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberRechargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberRechargeGroupByOutputType[P]>
            : GetScalarType<T[P], MemberRechargeGroupByOutputType[P]>
        }
      >
    >


  export type MemberRechargeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    money?: boolean
    rechargeMoney?: boolean
    screen?: boolean
    market?: boolean
    status?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberRecharge"]>

  export type MemberRechargeSelectScalar = {
    id?: boolean
    money?: boolean
    rechargeMoney?: boolean
    screen?: boolean
    market?: boolean
    status?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberRechargeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }


  export type $MemberRechargePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberRecharge"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      money: Prisma.Decimal
      rechargeMoney: Prisma.Decimal
      screen: Prisma.JsonValue
      market: string
      status: number
      memberId: bigint
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["memberRecharge"]>
    composites: {}
  }


  type MemberRechargeGetPayload<S extends boolean | null | undefined | MemberRechargeDefaultArgs> = $Result.GetResult<Prisma.$MemberRechargePayload, S>

  type MemberRechargeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberRechargeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberRechargeCountAggregateInputType | true
    }

  export interface MemberRechargeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberRecharge'], meta: { name: 'MemberRecharge' } }
    /**
     * Find zero or one MemberRecharge that matches the filter.
     * @param {MemberRechargeFindUniqueArgs} args - Arguments to find a MemberRecharge
     * @example
     * // Get one MemberRecharge
     * const memberRecharge = await prisma.memberRecharge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberRechargeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MemberRechargeFindUniqueArgs<ExtArgs>>
    ): Prisma__MemberRechargeClient<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MemberRecharge that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MemberRechargeFindUniqueOrThrowArgs} args - Arguments to find a MemberRecharge
     * @example
     * // Get one MemberRecharge
     * const memberRecharge = await prisma.memberRecharge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MemberRechargeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberRechargeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MemberRechargeClient<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MemberRecharge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRechargeFindFirstArgs} args - Arguments to find a MemberRecharge
     * @example
     * // Get one MemberRecharge
     * const memberRecharge = await prisma.memberRecharge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberRechargeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberRechargeFindFirstArgs<ExtArgs>>
    ): Prisma__MemberRechargeClient<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MemberRecharge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRechargeFindFirstOrThrowArgs} args - Arguments to find a MemberRecharge
     * @example
     * // Get one MemberRecharge
     * const memberRecharge = await prisma.memberRecharge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MemberRechargeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberRechargeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MemberRechargeClient<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MemberRecharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRechargeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberRecharges
     * const memberRecharges = await prisma.memberRecharge.findMany()
     * 
     * // Get first 10 MemberRecharges
     * const memberRecharges = await prisma.memberRecharge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberRechargeWithIdOnly = await prisma.memberRecharge.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MemberRechargeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberRechargeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MemberRecharge.
     * @param {MemberRechargeCreateArgs} args - Arguments to create a MemberRecharge.
     * @example
     * // Create one MemberRecharge
     * const MemberRecharge = await prisma.memberRecharge.create({
     *   data: {
     *     // ... data to create a MemberRecharge
     *   }
     * })
     * 
    **/
    create<T extends MemberRechargeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberRechargeCreateArgs<ExtArgs>>
    ): Prisma__MemberRechargeClient<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MemberRecharges.
     *     @param {MemberRechargeCreateManyArgs} args - Arguments to create many MemberRecharges.
     *     @example
     *     // Create many MemberRecharges
     *     const memberRecharge = await prisma.memberRecharge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberRechargeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberRechargeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MemberRecharge.
     * @param {MemberRechargeDeleteArgs} args - Arguments to delete one MemberRecharge.
     * @example
     * // Delete one MemberRecharge
     * const MemberRecharge = await prisma.memberRecharge.delete({
     *   where: {
     *     // ... filter to delete one MemberRecharge
     *   }
     * })
     * 
    **/
    delete<T extends MemberRechargeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MemberRechargeDeleteArgs<ExtArgs>>
    ): Prisma__MemberRechargeClient<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MemberRecharge.
     * @param {MemberRechargeUpdateArgs} args - Arguments to update one MemberRecharge.
     * @example
     * // Update one MemberRecharge
     * const memberRecharge = await prisma.memberRecharge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberRechargeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberRechargeUpdateArgs<ExtArgs>>
    ): Prisma__MemberRechargeClient<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MemberRecharges.
     * @param {MemberRechargeDeleteManyArgs} args - Arguments to filter MemberRecharges to delete.
     * @example
     * // Delete a few MemberRecharges
     * const { count } = await prisma.memberRecharge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberRechargeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberRechargeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberRecharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRechargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberRecharges
     * const memberRecharge = await prisma.memberRecharge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberRechargeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MemberRechargeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MemberRecharge.
     * @param {MemberRechargeUpsertArgs} args - Arguments to update or create a MemberRecharge.
     * @example
     * // Update or create a MemberRecharge
     * const memberRecharge = await prisma.memberRecharge.upsert({
     *   create: {
     *     // ... data to create a MemberRecharge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberRecharge we want to update
     *   }
     * })
    **/
    upsert<T extends MemberRechargeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MemberRechargeUpsertArgs<ExtArgs>>
    ): Prisma__MemberRechargeClient<$Result.GetResult<Prisma.$MemberRechargePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MemberRecharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRechargeCountArgs} args - Arguments to filter MemberRecharges to count.
     * @example
     * // Count the number of MemberRecharges
     * const count = await prisma.memberRecharge.count({
     *   where: {
     *     // ... the filter for the MemberRecharges we want to count
     *   }
     * })
    **/
    count<T extends MemberRechargeCountArgs>(
      args?: Subset<T, MemberRechargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberRechargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberRecharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRechargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberRechargeAggregateArgs>(args: Subset<T, MemberRechargeAggregateArgs>): Prisma.PrismaPromise<GetMemberRechargeAggregateType<T>>

    /**
     * Group by MemberRecharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberRechargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberRechargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberRechargeGroupByArgs['orderBy'] }
        : { orderBy?: MemberRechargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberRechargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberRechargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberRecharge model
   */
  readonly fields: MemberRechargeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberRecharge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberRechargeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MemberRecharge model
   */ 
  interface MemberRechargeFieldRefs {
    readonly id: FieldRef<"MemberRecharge", 'BigInt'>
    readonly money: FieldRef<"MemberRecharge", 'Decimal'>
    readonly rechargeMoney: FieldRef<"MemberRecharge", 'Decimal'>
    readonly screen: FieldRef<"MemberRecharge", 'Json'>
    readonly market: FieldRef<"MemberRecharge", 'String'>
    readonly status: FieldRef<"MemberRecharge", 'Int'>
    readonly memberId: FieldRef<"MemberRecharge", 'BigInt'>
    readonly createdAt: FieldRef<"MemberRecharge", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberRecharge", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MemberRecharge findUnique
   */
  export type MemberRechargeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    /**
     * Filter, which MemberRecharge to fetch.
     */
    where: MemberRechargeWhereUniqueInput
  }


  /**
   * MemberRecharge findUniqueOrThrow
   */
  export type MemberRechargeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    /**
     * Filter, which MemberRecharge to fetch.
     */
    where: MemberRechargeWhereUniqueInput
  }


  /**
   * MemberRecharge findFirst
   */
  export type MemberRechargeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    /**
     * Filter, which MemberRecharge to fetch.
     */
    where?: MemberRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberRecharges to fetch.
     */
    orderBy?: MemberRechargeOrderByWithRelationInput | MemberRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberRecharges.
     */
    cursor?: MemberRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberRecharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberRecharges.
     */
    distinct?: MemberRechargeScalarFieldEnum | MemberRechargeScalarFieldEnum[]
  }


  /**
   * MemberRecharge findFirstOrThrow
   */
  export type MemberRechargeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    /**
     * Filter, which MemberRecharge to fetch.
     */
    where?: MemberRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberRecharges to fetch.
     */
    orderBy?: MemberRechargeOrderByWithRelationInput | MemberRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberRecharges.
     */
    cursor?: MemberRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberRecharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberRecharges.
     */
    distinct?: MemberRechargeScalarFieldEnum | MemberRechargeScalarFieldEnum[]
  }


  /**
   * MemberRecharge findMany
   */
  export type MemberRechargeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    /**
     * Filter, which MemberRecharges to fetch.
     */
    where?: MemberRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberRecharges to fetch.
     */
    orderBy?: MemberRechargeOrderByWithRelationInput | MemberRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberRecharges.
     */
    cursor?: MemberRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberRecharges.
     */
    skip?: number
    distinct?: MemberRechargeScalarFieldEnum | MemberRechargeScalarFieldEnum[]
  }


  /**
   * MemberRecharge create
   */
  export type MemberRechargeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberRecharge.
     */
    data: XOR<MemberRechargeCreateInput, MemberRechargeUncheckedCreateInput>
  }


  /**
   * MemberRecharge createMany
   */
  export type MemberRechargeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberRecharges.
     */
    data: MemberRechargeCreateManyInput | MemberRechargeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MemberRecharge update
   */
  export type MemberRechargeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberRecharge.
     */
    data: XOR<MemberRechargeUpdateInput, MemberRechargeUncheckedUpdateInput>
    /**
     * Choose, which MemberRecharge to update.
     */
    where: MemberRechargeWhereUniqueInput
  }


  /**
   * MemberRecharge updateMany
   */
  export type MemberRechargeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberRecharges.
     */
    data: XOR<MemberRechargeUpdateManyMutationInput, MemberRechargeUncheckedUpdateManyInput>
    /**
     * Filter which MemberRecharges to update
     */
    where?: MemberRechargeWhereInput
  }


  /**
   * MemberRecharge upsert
   */
  export type MemberRechargeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberRecharge to update in case it exists.
     */
    where: MemberRechargeWhereUniqueInput
    /**
     * In case the MemberRecharge found by the `where` argument doesn't exist, create a new MemberRecharge with this data.
     */
    create: XOR<MemberRechargeCreateInput, MemberRechargeUncheckedCreateInput>
    /**
     * In case the MemberRecharge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberRechargeUpdateInput, MemberRechargeUncheckedUpdateInput>
  }


  /**
   * MemberRecharge delete
   */
  export type MemberRechargeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
    /**
     * Filter which MemberRecharge to delete.
     */
    where: MemberRechargeWhereUniqueInput
  }


  /**
   * MemberRecharge deleteMany
   */
  export type MemberRechargeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberRecharges to delete
     */
    where?: MemberRechargeWhereInput
  }


  /**
   * MemberRecharge without action
   */
  export type MemberRechargeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberRecharge
     */
    select?: MemberRechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberRechargeInclude<ExtArgs> | null
  }



  /**
   * Model MemberWithdraw
   */

  export type AggregateMemberWithdraw = {
    _count: MemberWithdrawCountAggregateOutputType | null
    _avg: MemberWithdrawAvgAggregateOutputType | null
    _sum: MemberWithdrawSumAggregateOutputType | null
    _min: MemberWithdrawMinAggregateOutputType | null
    _max: MemberWithdrawMaxAggregateOutputType | null
  }

  export type MemberWithdrawAvgAggregateOutputType = {
    id: number | null
    money: Decimal | null
    status: number | null
    memberId: number | null
  }

  export type MemberWithdrawSumAggregateOutputType = {
    id: bigint | null
    money: Decimal | null
    status: number | null
    memberId: bigint | null
  }

  export type MemberWithdrawMinAggregateOutputType = {
    id: bigint | null
    money: Decimal | null
    remark: string | null
    status: number | null
    address: string | null
    market: string | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberWithdrawMaxAggregateOutputType = {
    id: bigint | null
    money: Decimal | null
    remark: string | null
    status: number | null
    address: string | null
    market: string | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberWithdrawCountAggregateOutputType = {
    id: number
    money: number
    remark: number
    status: number
    address: number
    market: number
    memberId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberWithdrawAvgAggregateInputType = {
    id?: true
    money?: true
    status?: true
    memberId?: true
  }

  export type MemberWithdrawSumAggregateInputType = {
    id?: true
    money?: true
    status?: true
    memberId?: true
  }

  export type MemberWithdrawMinAggregateInputType = {
    id?: true
    money?: true
    remark?: true
    status?: true
    address?: true
    market?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberWithdrawMaxAggregateInputType = {
    id?: true
    money?: true
    remark?: true
    status?: true
    address?: true
    market?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberWithdrawCountAggregateInputType = {
    id?: true
    money?: true
    remark?: true
    status?: true
    address?: true
    market?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberWithdrawAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberWithdraw to aggregate.
     */
    where?: MemberWithdrawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberWithdraws to fetch.
     */
    orderBy?: MemberWithdrawOrderByWithRelationInput | MemberWithdrawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWithdrawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberWithdraws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberWithdraws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberWithdraws
    **/
    _count?: true | MemberWithdrawCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberWithdrawAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberWithdrawSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberWithdrawMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberWithdrawMaxAggregateInputType
  }

  export type GetMemberWithdrawAggregateType<T extends MemberWithdrawAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberWithdraw]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberWithdraw[P]>
      : GetScalarType<T[P], AggregateMemberWithdraw[P]>
  }




  export type MemberWithdrawGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWithdrawWhereInput
    orderBy?: MemberWithdrawOrderByWithAggregationInput | MemberWithdrawOrderByWithAggregationInput[]
    by: MemberWithdrawScalarFieldEnum[] | MemberWithdrawScalarFieldEnum
    having?: MemberWithdrawScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberWithdrawCountAggregateInputType | true
    _avg?: MemberWithdrawAvgAggregateInputType
    _sum?: MemberWithdrawSumAggregateInputType
    _min?: MemberWithdrawMinAggregateInputType
    _max?: MemberWithdrawMaxAggregateInputType
  }

  export type MemberWithdrawGroupByOutputType = {
    id: bigint
    money: Decimal
    remark: string | null
    status: number
    address: string | null
    market: string
    memberId: bigint
    createdAt: Date
    updatedAt: Date | null
    _count: MemberWithdrawCountAggregateOutputType | null
    _avg: MemberWithdrawAvgAggregateOutputType | null
    _sum: MemberWithdrawSumAggregateOutputType | null
    _min: MemberWithdrawMinAggregateOutputType | null
    _max: MemberWithdrawMaxAggregateOutputType | null
  }

  type GetMemberWithdrawGroupByPayload<T extends MemberWithdrawGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberWithdrawGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberWithdrawGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberWithdrawGroupByOutputType[P]>
            : GetScalarType<T[P], MemberWithdrawGroupByOutputType[P]>
        }
      >
    >


  export type MemberWithdrawSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    money?: boolean
    remark?: boolean
    status?: boolean
    address?: boolean
    market?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberWithdraw"]>

  export type MemberWithdrawSelectScalar = {
    id?: boolean
    money?: boolean
    remark?: boolean
    status?: boolean
    address?: boolean
    market?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberWithdrawInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }


  export type $MemberWithdrawPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberWithdraw"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      money: Prisma.Decimal
      remark: string | null
      status: number
      address: string | null
      market: string
      memberId: bigint
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["memberWithdraw"]>
    composites: {}
  }


  type MemberWithdrawGetPayload<S extends boolean | null | undefined | MemberWithdrawDefaultArgs> = $Result.GetResult<Prisma.$MemberWithdrawPayload, S>

  type MemberWithdrawCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberWithdrawFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberWithdrawCountAggregateInputType | true
    }

  export interface MemberWithdrawDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberWithdraw'], meta: { name: 'MemberWithdraw' } }
    /**
     * Find zero or one MemberWithdraw that matches the filter.
     * @param {MemberWithdrawFindUniqueArgs} args - Arguments to find a MemberWithdraw
     * @example
     * // Get one MemberWithdraw
     * const memberWithdraw = await prisma.memberWithdraw.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberWithdrawFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MemberWithdrawFindUniqueArgs<ExtArgs>>
    ): Prisma__MemberWithdrawClient<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MemberWithdraw that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MemberWithdrawFindUniqueOrThrowArgs} args - Arguments to find a MemberWithdraw
     * @example
     * // Get one MemberWithdraw
     * const memberWithdraw = await prisma.memberWithdraw.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MemberWithdrawFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberWithdrawFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MemberWithdrawClient<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MemberWithdraw that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberWithdrawFindFirstArgs} args - Arguments to find a MemberWithdraw
     * @example
     * // Get one MemberWithdraw
     * const memberWithdraw = await prisma.memberWithdraw.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberWithdrawFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberWithdrawFindFirstArgs<ExtArgs>>
    ): Prisma__MemberWithdrawClient<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MemberWithdraw that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberWithdrawFindFirstOrThrowArgs} args - Arguments to find a MemberWithdraw
     * @example
     * // Get one MemberWithdraw
     * const memberWithdraw = await prisma.memberWithdraw.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MemberWithdrawFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberWithdrawFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MemberWithdrawClient<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MemberWithdraws that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberWithdrawFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberWithdraws
     * const memberWithdraws = await prisma.memberWithdraw.findMany()
     * 
     * // Get first 10 MemberWithdraws
     * const memberWithdraws = await prisma.memberWithdraw.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithdrawWithIdOnly = await prisma.memberWithdraw.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MemberWithdrawFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberWithdrawFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MemberWithdraw.
     * @param {MemberWithdrawCreateArgs} args - Arguments to create a MemberWithdraw.
     * @example
     * // Create one MemberWithdraw
     * const MemberWithdraw = await prisma.memberWithdraw.create({
     *   data: {
     *     // ... data to create a MemberWithdraw
     *   }
     * })
     * 
    **/
    create<T extends MemberWithdrawCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberWithdrawCreateArgs<ExtArgs>>
    ): Prisma__MemberWithdrawClient<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MemberWithdraws.
     *     @param {MemberWithdrawCreateManyArgs} args - Arguments to create many MemberWithdraws.
     *     @example
     *     // Create many MemberWithdraws
     *     const memberWithdraw = await prisma.memberWithdraw.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberWithdrawCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberWithdrawCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MemberWithdraw.
     * @param {MemberWithdrawDeleteArgs} args - Arguments to delete one MemberWithdraw.
     * @example
     * // Delete one MemberWithdraw
     * const MemberWithdraw = await prisma.memberWithdraw.delete({
     *   where: {
     *     // ... filter to delete one MemberWithdraw
     *   }
     * })
     * 
    **/
    delete<T extends MemberWithdrawDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MemberWithdrawDeleteArgs<ExtArgs>>
    ): Prisma__MemberWithdrawClient<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MemberWithdraw.
     * @param {MemberWithdrawUpdateArgs} args - Arguments to update one MemberWithdraw.
     * @example
     * // Update one MemberWithdraw
     * const memberWithdraw = await prisma.memberWithdraw.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberWithdrawUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberWithdrawUpdateArgs<ExtArgs>>
    ): Prisma__MemberWithdrawClient<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MemberWithdraws.
     * @param {MemberWithdrawDeleteManyArgs} args - Arguments to filter MemberWithdraws to delete.
     * @example
     * // Delete a few MemberWithdraws
     * const { count } = await prisma.memberWithdraw.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberWithdrawDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberWithdrawDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberWithdraws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberWithdrawUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberWithdraws
     * const memberWithdraw = await prisma.memberWithdraw.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberWithdrawUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MemberWithdrawUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MemberWithdraw.
     * @param {MemberWithdrawUpsertArgs} args - Arguments to update or create a MemberWithdraw.
     * @example
     * // Update or create a MemberWithdraw
     * const memberWithdraw = await prisma.memberWithdraw.upsert({
     *   create: {
     *     // ... data to create a MemberWithdraw
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberWithdraw we want to update
     *   }
     * })
    **/
    upsert<T extends MemberWithdrawUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MemberWithdrawUpsertArgs<ExtArgs>>
    ): Prisma__MemberWithdrawClient<$Result.GetResult<Prisma.$MemberWithdrawPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MemberWithdraws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberWithdrawCountArgs} args - Arguments to filter MemberWithdraws to count.
     * @example
     * // Count the number of MemberWithdraws
     * const count = await prisma.memberWithdraw.count({
     *   where: {
     *     // ... the filter for the MemberWithdraws we want to count
     *   }
     * })
    **/
    count<T extends MemberWithdrawCountArgs>(
      args?: Subset<T, MemberWithdrawCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberWithdrawCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberWithdraw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberWithdrawAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberWithdrawAggregateArgs>(args: Subset<T, MemberWithdrawAggregateArgs>): Prisma.PrismaPromise<GetMemberWithdrawAggregateType<T>>

    /**
     * Group by MemberWithdraw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberWithdrawGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberWithdrawGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberWithdrawGroupByArgs['orderBy'] }
        : { orderBy?: MemberWithdrawGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberWithdrawGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberWithdrawGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberWithdraw model
   */
  readonly fields: MemberWithdrawFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberWithdraw.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberWithdrawClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MemberWithdraw model
   */ 
  interface MemberWithdrawFieldRefs {
    readonly id: FieldRef<"MemberWithdraw", 'BigInt'>
    readonly money: FieldRef<"MemberWithdraw", 'Decimal'>
    readonly remark: FieldRef<"MemberWithdraw", 'String'>
    readonly status: FieldRef<"MemberWithdraw", 'Int'>
    readonly address: FieldRef<"MemberWithdraw", 'String'>
    readonly market: FieldRef<"MemberWithdraw", 'String'>
    readonly memberId: FieldRef<"MemberWithdraw", 'BigInt'>
    readonly createdAt: FieldRef<"MemberWithdraw", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberWithdraw", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MemberWithdraw findUnique
   */
  export type MemberWithdrawFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    /**
     * Filter, which MemberWithdraw to fetch.
     */
    where: MemberWithdrawWhereUniqueInput
  }


  /**
   * MemberWithdraw findUniqueOrThrow
   */
  export type MemberWithdrawFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    /**
     * Filter, which MemberWithdraw to fetch.
     */
    where: MemberWithdrawWhereUniqueInput
  }


  /**
   * MemberWithdraw findFirst
   */
  export type MemberWithdrawFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    /**
     * Filter, which MemberWithdraw to fetch.
     */
    where?: MemberWithdrawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberWithdraws to fetch.
     */
    orderBy?: MemberWithdrawOrderByWithRelationInput | MemberWithdrawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberWithdraws.
     */
    cursor?: MemberWithdrawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberWithdraws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberWithdraws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberWithdraws.
     */
    distinct?: MemberWithdrawScalarFieldEnum | MemberWithdrawScalarFieldEnum[]
  }


  /**
   * MemberWithdraw findFirstOrThrow
   */
  export type MemberWithdrawFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    /**
     * Filter, which MemberWithdraw to fetch.
     */
    where?: MemberWithdrawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberWithdraws to fetch.
     */
    orderBy?: MemberWithdrawOrderByWithRelationInput | MemberWithdrawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberWithdraws.
     */
    cursor?: MemberWithdrawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberWithdraws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberWithdraws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberWithdraws.
     */
    distinct?: MemberWithdrawScalarFieldEnum | MemberWithdrawScalarFieldEnum[]
  }


  /**
   * MemberWithdraw findMany
   */
  export type MemberWithdrawFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    /**
     * Filter, which MemberWithdraws to fetch.
     */
    where?: MemberWithdrawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberWithdraws to fetch.
     */
    orderBy?: MemberWithdrawOrderByWithRelationInput | MemberWithdrawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberWithdraws.
     */
    cursor?: MemberWithdrawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberWithdraws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberWithdraws.
     */
    skip?: number
    distinct?: MemberWithdrawScalarFieldEnum | MemberWithdrawScalarFieldEnum[]
  }


  /**
   * MemberWithdraw create
   */
  export type MemberWithdrawCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberWithdraw.
     */
    data: XOR<MemberWithdrawCreateInput, MemberWithdrawUncheckedCreateInput>
  }


  /**
   * MemberWithdraw createMany
   */
  export type MemberWithdrawCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberWithdraws.
     */
    data: MemberWithdrawCreateManyInput | MemberWithdrawCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MemberWithdraw update
   */
  export type MemberWithdrawUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberWithdraw.
     */
    data: XOR<MemberWithdrawUpdateInput, MemberWithdrawUncheckedUpdateInput>
    /**
     * Choose, which MemberWithdraw to update.
     */
    where: MemberWithdrawWhereUniqueInput
  }


  /**
   * MemberWithdraw updateMany
   */
  export type MemberWithdrawUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberWithdraws.
     */
    data: XOR<MemberWithdrawUpdateManyMutationInput, MemberWithdrawUncheckedUpdateManyInput>
    /**
     * Filter which MemberWithdraws to update
     */
    where?: MemberWithdrawWhereInput
  }


  /**
   * MemberWithdraw upsert
   */
  export type MemberWithdrawUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberWithdraw to update in case it exists.
     */
    where: MemberWithdrawWhereUniqueInput
    /**
     * In case the MemberWithdraw found by the `where` argument doesn't exist, create a new MemberWithdraw with this data.
     */
    create: XOR<MemberWithdrawCreateInput, MemberWithdrawUncheckedCreateInput>
    /**
     * In case the MemberWithdraw was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberWithdrawUpdateInput, MemberWithdrawUncheckedUpdateInput>
  }


  /**
   * MemberWithdraw delete
   */
  export type MemberWithdrawDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
    /**
     * Filter which MemberWithdraw to delete.
     */
    where: MemberWithdrawWhereUniqueInput
  }


  /**
   * MemberWithdraw deleteMany
   */
  export type MemberWithdrawDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberWithdraws to delete
     */
    where?: MemberWithdrawWhereInput
  }


  /**
   * MemberWithdraw without action
   */
  export type MemberWithdrawDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberWithdraw
     */
    select?: MemberWithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberWithdrawInclude<ExtArgs> | null
  }



  /**
   * Model StockSymbol
   */

  export type AggregateStockSymbol = {
    _count: StockSymbolCountAggregateOutputType | null
    _avg: StockSymbolAvgAggregateOutputType | null
    _sum: StockSymbolSumAggregateOutputType | null
    _min: StockSymbolMinAggregateOutputType | null
    _max: StockSymbolMaxAggregateOutputType | null
  }

  export type StockSymbolAvgAggregateOutputType = {
    id: number | null
    online: number | null
    trade: number | null
    type: number | null
  }

  export type StockSymbolSumAggregateOutputType = {
    id: bigint | null
    online: number | null
    trade: number | null
    type: number | null
  }

  export type StockSymbolMinAggregateOutputType = {
    id: bigint | null
    code: string | null
    cat: string | null
    market: string | null
    online: number | null
    symbol: string | null
    showName: string | null
    name: string | null
    symbolShowName: string | null
    trade: number | null
    type: number | null
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    change: string | null
    changePercent: string | null
    date: string | null
    syncMarket: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockSymbolMaxAggregateOutputType = {
    id: bigint | null
    code: string | null
    cat: string | null
    market: string | null
    online: number | null
    symbol: string | null
    showName: string | null
    name: string | null
    symbolShowName: string | null
    trade: number | null
    type: number | null
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    change: string | null
    changePercent: string | null
    date: string | null
    syncMarket: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockSymbolCountAggregateOutputType = {
    id: number
    code: number
    cat: number
    market: number
    online: number
    symbol: number
    showName: number
    name: number
    symbolShowName: number
    trade: number
    type: number
    newPrice: number
    open: number
    close: number
    high: number
    low: number
    amount: number
    volume: number
    change: number
    changePercent: number
    date: number
    sync: number
    syncMarket: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockSymbolAvgAggregateInputType = {
    id?: true
    online?: true
    trade?: true
    type?: true
  }

  export type StockSymbolSumAggregateInputType = {
    id?: true
    online?: true
    trade?: true
    type?: true
  }

  export type StockSymbolMinAggregateInputType = {
    id?: true
    code?: true
    cat?: true
    market?: true
    online?: true
    symbol?: true
    showName?: true
    name?: true
    symbolShowName?: true
    trade?: true
    type?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    change?: true
    changePercent?: true
    date?: true
    syncMarket?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockSymbolMaxAggregateInputType = {
    id?: true
    code?: true
    cat?: true
    market?: true
    online?: true
    symbol?: true
    showName?: true
    name?: true
    symbolShowName?: true
    trade?: true
    type?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    change?: true
    changePercent?: true
    date?: true
    syncMarket?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockSymbolCountAggregateInputType = {
    id?: true
    code?: true
    cat?: true
    market?: true
    online?: true
    symbol?: true
    showName?: true
    name?: true
    symbolShowName?: true
    trade?: true
    type?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    change?: true
    changePercent?: true
    date?: true
    sync?: true
    syncMarket?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockSymbolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockSymbol to aggregate.
     */
    where?: StockSymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockSymbols to fetch.
     */
    orderBy?: StockSymbolOrderByWithRelationInput | StockSymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockSymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockSymbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockSymbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockSymbols
    **/
    _count?: true | StockSymbolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockSymbolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSymbolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockSymbolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockSymbolMaxAggregateInputType
  }

  export type GetStockSymbolAggregateType<T extends StockSymbolAggregateArgs> = {
        [P in keyof T & keyof AggregateStockSymbol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockSymbol[P]>
      : GetScalarType<T[P], AggregateStockSymbol[P]>
  }




  export type StockSymbolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockSymbolWhereInput
    orderBy?: StockSymbolOrderByWithAggregationInput | StockSymbolOrderByWithAggregationInput[]
    by: StockSymbolScalarFieldEnum[] | StockSymbolScalarFieldEnum
    having?: StockSymbolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockSymbolCountAggregateInputType | true
    _avg?: StockSymbolAvgAggregateInputType
    _sum?: StockSymbolSumAggregateInputType
    _min?: StockSymbolMinAggregateInputType
    _max?: StockSymbolMaxAggregateInputType
  }

  export type StockSymbolGroupByOutputType = {
    id: bigint
    code: string
    cat: string | null
    market: string
    online: number
    symbol: string
    showName: string
    name: string | null
    symbolShowName: string | null
    trade: number
    type: number
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    change: string | null
    changePercent: string | null
    date: string | null
    sync: JsonValue | null
    syncMarket: string
    createdAt: Date
    updatedAt: Date | null
    _count: StockSymbolCountAggregateOutputType | null
    _avg: StockSymbolAvgAggregateOutputType | null
    _sum: StockSymbolSumAggregateOutputType | null
    _min: StockSymbolMinAggregateOutputType | null
    _max: StockSymbolMaxAggregateOutputType | null
  }

  type GetStockSymbolGroupByPayload<T extends StockSymbolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockSymbolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockSymbolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockSymbolGroupByOutputType[P]>
            : GetScalarType<T[P], StockSymbolGroupByOutputType[P]>
        }
      >
    >


  export type StockSymbolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    cat?: boolean
    market?: boolean
    online?: boolean
    symbol?: boolean
    showName?: boolean
    name?: boolean
    symbolShowName?: boolean
    trade?: boolean
    type?: boolean
    newPrice?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    amount?: boolean
    volume?: boolean
    change?: boolean
    changePercent?: boolean
    date?: boolean
    sync?: boolean
    syncMarket?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockPostion?: boolean | StockSymbol$stockPostionArgs<ExtArgs>
    _count?: boolean | StockSymbolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockSymbol"]>

  export type StockSymbolSelectScalar = {
    id?: boolean
    code?: boolean
    cat?: boolean
    market?: boolean
    online?: boolean
    symbol?: boolean
    showName?: boolean
    name?: boolean
    symbolShowName?: boolean
    trade?: boolean
    type?: boolean
    newPrice?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    amount?: boolean
    volume?: boolean
    change?: boolean
    changePercent?: boolean
    date?: boolean
    sync?: boolean
    syncMarket?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockSymbolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockPostion?: boolean | StockSymbol$stockPostionArgs<ExtArgs>
    _count?: boolean | StockSymbolCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StockSymbolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockSymbol"
    objects: {
      stockPostion: Prisma.$StockPositionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      code: string
      cat: string | null
      market: string
      online: number
      symbol: string
      showName: string
      name: string | null
      symbolShowName: string | null
      trade: number
      type: number
      newPrice: string | null
      open: string | null
      close: string | null
      high: string | null
      low: string | null
      amount: string | null
      volume: string | null
      change: string | null
      changePercent: string | null
      date: string | null
      sync: Prisma.JsonValue | null
      syncMarket: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["stockSymbol"]>
    composites: {}
  }


  type StockSymbolGetPayload<S extends boolean | null | undefined | StockSymbolDefaultArgs> = $Result.GetResult<Prisma.$StockSymbolPayload, S>

  type StockSymbolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockSymbolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockSymbolCountAggregateInputType | true
    }

  export interface StockSymbolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockSymbol'], meta: { name: 'StockSymbol' } }
    /**
     * Find zero or one StockSymbol that matches the filter.
     * @param {StockSymbolFindUniqueArgs} args - Arguments to find a StockSymbol
     * @example
     * // Get one StockSymbol
     * const stockSymbol = await prisma.stockSymbol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockSymbolFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockSymbolFindUniqueArgs<ExtArgs>>
    ): Prisma__StockSymbolClient<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockSymbol that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockSymbolFindUniqueOrThrowArgs} args - Arguments to find a StockSymbol
     * @example
     * // Get one StockSymbol
     * const stockSymbol = await prisma.stockSymbol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockSymbolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSymbolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockSymbolClient<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockSymbol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSymbolFindFirstArgs} args - Arguments to find a StockSymbol
     * @example
     * // Get one StockSymbol
     * const stockSymbol = await prisma.stockSymbol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockSymbolFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSymbolFindFirstArgs<ExtArgs>>
    ): Prisma__StockSymbolClient<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockSymbol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSymbolFindFirstOrThrowArgs} args - Arguments to find a StockSymbol
     * @example
     * // Get one StockSymbol
     * const stockSymbol = await prisma.stockSymbol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockSymbolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSymbolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockSymbolClient<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockSymbols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSymbolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockSymbols
     * const stockSymbols = await prisma.stockSymbol.findMany()
     * 
     * // Get first 10 StockSymbols
     * const stockSymbols = await prisma.stockSymbol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockSymbolWithIdOnly = await prisma.stockSymbol.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockSymbolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSymbolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockSymbol.
     * @param {StockSymbolCreateArgs} args - Arguments to create a StockSymbol.
     * @example
     * // Create one StockSymbol
     * const StockSymbol = await prisma.stockSymbol.create({
     *   data: {
     *     // ... data to create a StockSymbol
     *   }
     * })
     * 
    **/
    create<T extends StockSymbolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockSymbolCreateArgs<ExtArgs>>
    ): Prisma__StockSymbolClient<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockSymbols.
     *     @param {StockSymbolCreateManyArgs} args - Arguments to create many StockSymbols.
     *     @example
     *     // Create many StockSymbols
     *     const stockSymbol = await prisma.stockSymbol.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockSymbolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSymbolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockSymbol.
     * @param {StockSymbolDeleteArgs} args - Arguments to delete one StockSymbol.
     * @example
     * // Delete one StockSymbol
     * const StockSymbol = await prisma.stockSymbol.delete({
     *   where: {
     *     // ... filter to delete one StockSymbol
     *   }
     * })
     * 
    **/
    delete<T extends StockSymbolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockSymbolDeleteArgs<ExtArgs>>
    ): Prisma__StockSymbolClient<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockSymbol.
     * @param {StockSymbolUpdateArgs} args - Arguments to update one StockSymbol.
     * @example
     * // Update one StockSymbol
     * const stockSymbol = await prisma.stockSymbol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockSymbolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockSymbolUpdateArgs<ExtArgs>>
    ): Prisma__StockSymbolClient<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockSymbols.
     * @param {StockSymbolDeleteManyArgs} args - Arguments to filter StockSymbols to delete.
     * @example
     * // Delete a few StockSymbols
     * const { count } = await prisma.stockSymbol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockSymbolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSymbolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockSymbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSymbolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockSymbols
     * const stockSymbol = await prisma.stockSymbol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockSymbolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockSymbolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockSymbol.
     * @param {StockSymbolUpsertArgs} args - Arguments to update or create a StockSymbol.
     * @example
     * // Update or create a StockSymbol
     * const stockSymbol = await prisma.stockSymbol.upsert({
     *   create: {
     *     // ... data to create a StockSymbol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockSymbol we want to update
     *   }
     * })
    **/
    upsert<T extends StockSymbolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockSymbolUpsertArgs<ExtArgs>>
    ): Prisma__StockSymbolClient<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockSymbols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSymbolCountArgs} args - Arguments to filter StockSymbols to count.
     * @example
     * // Count the number of StockSymbols
     * const count = await prisma.stockSymbol.count({
     *   where: {
     *     // ... the filter for the StockSymbols we want to count
     *   }
     * })
    **/
    count<T extends StockSymbolCountArgs>(
      args?: Subset<T, StockSymbolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockSymbolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockSymbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSymbolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockSymbolAggregateArgs>(args: Subset<T, StockSymbolAggregateArgs>): Prisma.PrismaPromise<GetStockSymbolAggregateType<T>>

    /**
     * Group by StockSymbol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSymbolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockSymbolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockSymbolGroupByArgs['orderBy'] }
        : { orderBy?: StockSymbolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockSymbolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockSymbolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockSymbol model
   */
  readonly fields: StockSymbolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockSymbol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockSymbolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stockPostion<T extends StockSymbol$stockPostionArgs<ExtArgs> = {}>(args?: Subset<T, StockSymbol$stockPostionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockSymbol model
   */ 
  interface StockSymbolFieldRefs {
    readonly id: FieldRef<"StockSymbol", 'BigInt'>
    readonly code: FieldRef<"StockSymbol", 'String'>
    readonly cat: FieldRef<"StockSymbol", 'String'>
    readonly market: FieldRef<"StockSymbol", 'String'>
    readonly online: FieldRef<"StockSymbol", 'Int'>
    readonly symbol: FieldRef<"StockSymbol", 'String'>
    readonly showName: FieldRef<"StockSymbol", 'String'>
    readonly name: FieldRef<"StockSymbol", 'String'>
    readonly symbolShowName: FieldRef<"StockSymbol", 'String'>
    readonly trade: FieldRef<"StockSymbol", 'Int'>
    readonly type: FieldRef<"StockSymbol", 'Int'>
    readonly newPrice: FieldRef<"StockSymbol", 'String'>
    readonly open: FieldRef<"StockSymbol", 'String'>
    readonly close: FieldRef<"StockSymbol", 'String'>
    readonly high: FieldRef<"StockSymbol", 'String'>
    readonly low: FieldRef<"StockSymbol", 'String'>
    readonly amount: FieldRef<"StockSymbol", 'String'>
    readonly volume: FieldRef<"StockSymbol", 'String'>
    readonly change: FieldRef<"StockSymbol", 'String'>
    readonly changePercent: FieldRef<"StockSymbol", 'String'>
    readonly date: FieldRef<"StockSymbol", 'String'>
    readonly sync: FieldRef<"StockSymbol", 'Json'>
    readonly syncMarket: FieldRef<"StockSymbol", 'String'>
    readonly createdAt: FieldRef<"StockSymbol", 'DateTime'>
    readonly updatedAt: FieldRef<"StockSymbol", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StockSymbol findUnique
   */
  export type StockSymbolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
    /**
     * Filter, which StockSymbol to fetch.
     */
    where: StockSymbolWhereUniqueInput
  }


  /**
   * StockSymbol findUniqueOrThrow
   */
  export type StockSymbolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
    /**
     * Filter, which StockSymbol to fetch.
     */
    where: StockSymbolWhereUniqueInput
  }


  /**
   * StockSymbol findFirst
   */
  export type StockSymbolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
    /**
     * Filter, which StockSymbol to fetch.
     */
    where?: StockSymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockSymbols to fetch.
     */
    orderBy?: StockSymbolOrderByWithRelationInput | StockSymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockSymbols.
     */
    cursor?: StockSymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockSymbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockSymbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockSymbols.
     */
    distinct?: StockSymbolScalarFieldEnum | StockSymbolScalarFieldEnum[]
  }


  /**
   * StockSymbol findFirstOrThrow
   */
  export type StockSymbolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
    /**
     * Filter, which StockSymbol to fetch.
     */
    where?: StockSymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockSymbols to fetch.
     */
    orderBy?: StockSymbolOrderByWithRelationInput | StockSymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockSymbols.
     */
    cursor?: StockSymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockSymbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockSymbols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockSymbols.
     */
    distinct?: StockSymbolScalarFieldEnum | StockSymbolScalarFieldEnum[]
  }


  /**
   * StockSymbol findMany
   */
  export type StockSymbolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
    /**
     * Filter, which StockSymbols to fetch.
     */
    where?: StockSymbolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockSymbols to fetch.
     */
    orderBy?: StockSymbolOrderByWithRelationInput | StockSymbolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockSymbols.
     */
    cursor?: StockSymbolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockSymbols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockSymbols.
     */
    skip?: number
    distinct?: StockSymbolScalarFieldEnum | StockSymbolScalarFieldEnum[]
  }


  /**
   * StockSymbol create
   */
  export type StockSymbolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
    /**
     * The data needed to create a StockSymbol.
     */
    data: XOR<StockSymbolCreateInput, StockSymbolUncheckedCreateInput>
  }


  /**
   * StockSymbol createMany
   */
  export type StockSymbolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockSymbols.
     */
    data: StockSymbolCreateManyInput | StockSymbolCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockSymbol update
   */
  export type StockSymbolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
    /**
     * The data needed to update a StockSymbol.
     */
    data: XOR<StockSymbolUpdateInput, StockSymbolUncheckedUpdateInput>
    /**
     * Choose, which StockSymbol to update.
     */
    where: StockSymbolWhereUniqueInput
  }


  /**
   * StockSymbol updateMany
   */
  export type StockSymbolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockSymbols.
     */
    data: XOR<StockSymbolUpdateManyMutationInput, StockSymbolUncheckedUpdateManyInput>
    /**
     * Filter which StockSymbols to update
     */
    where?: StockSymbolWhereInput
  }


  /**
   * StockSymbol upsert
   */
  export type StockSymbolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
    /**
     * The filter to search for the StockSymbol to update in case it exists.
     */
    where: StockSymbolWhereUniqueInput
    /**
     * In case the StockSymbol found by the `where` argument doesn't exist, create a new StockSymbol with this data.
     */
    create: XOR<StockSymbolCreateInput, StockSymbolUncheckedCreateInput>
    /**
     * In case the StockSymbol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockSymbolUpdateInput, StockSymbolUncheckedUpdateInput>
  }


  /**
   * StockSymbol delete
   */
  export type StockSymbolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
    /**
     * Filter which StockSymbol to delete.
     */
    where: StockSymbolWhereUniqueInput
  }


  /**
   * StockSymbol deleteMany
   */
  export type StockSymbolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockSymbols to delete
     */
    where?: StockSymbolWhereInput
  }


  /**
   * StockSymbol.stockPostion
   */
  export type StockSymbol$stockPostionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    where?: StockPositionWhereInput
    orderBy?: StockPositionOrderByWithRelationInput | StockPositionOrderByWithRelationInput[]
    cursor?: StockPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockPositionScalarFieldEnum | StockPositionScalarFieldEnum[]
  }


  /**
   * StockSymbol without action
   */
  export type StockSymbolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSymbol
     */
    select?: StockSymbolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockSymbolInclude<ExtArgs> | null
  }



  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    id: number | null
  }

  export type StockSumAggregateOutputType = {
    id: bigint | null
  }

  export type StockMinAggregateOutputType = {
    id: bigint | null
    code: string | null
    symbol: string | null
    name: string | null
    cname: string | null
    type: string | null
    logo: string | null
    sok: string | null
    optional: boolean | null
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    status: $Enums.STOCK_STATUS | null
    change: string | null
    changePercent: string | null
    date: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockMaxAggregateOutputType = {
    id: bigint | null
    code: string | null
    symbol: string | null
    name: string | null
    cname: string | null
    type: string | null
    logo: string | null
    sok: string | null
    optional: boolean | null
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    status: $Enums.STOCK_STATUS | null
    change: string | null
    changePercent: string | null
    date: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockCountAggregateOutputType = {
    id: number
    code: number
    symbol: number
    name: number
    cname: number
    type: number
    logo: number
    sok: number
    optional: number
    newPrice: number
    open: number
    close: number
    high: number
    low: number
    amount: number
    volume: number
    status: number
    change: number
    changePercent: number
    date: number
    extra: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    id?: true
  }

  export type StockSumAggregateInputType = {
    id?: true
  }

  export type StockMinAggregateInputType = {
    id?: true
    code?: true
    symbol?: true
    name?: true
    cname?: true
    type?: true
    logo?: true
    sok?: true
    optional?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    status?: true
    change?: true
    changePercent?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockMaxAggregateInputType = {
    id?: true
    code?: true
    symbol?: true
    name?: true
    cname?: true
    type?: true
    logo?: true
    sok?: true
    optional?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    status?: true
    change?: true
    changePercent?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockCountAggregateInputType = {
    id?: true
    code?: true
    symbol?: true
    name?: true
    cname?: true
    type?: true
    logo?: true
    sok?: true
    optional?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    status?: true
    change?: true
    changePercent?: true
    date?: true
    extra?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    id: bigint
    code: string
    symbol: string
    name: string
    cname: string | null
    type: string
    logo: string | null
    sok: string | null
    optional: boolean
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    status: $Enums.STOCK_STATUS
    change: string | null
    changePercent: string | null
    date: string | null
    extra: JsonValue | null
    createdAt: Date
    updatedAt: Date | null
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    symbol?: boolean
    name?: boolean
    cname?: boolean
    type?: boolean
    logo?: boolean
    sok?: boolean
    optional?: boolean
    newPrice?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    amount?: boolean
    volume?: boolean
    status?: boolean
    change?: boolean
    changePercent?: boolean
    date?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockRecord?: boolean | Stock$stockRecordArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectScalar = {
    id?: boolean
    code?: boolean
    symbol?: boolean
    name?: boolean
    cname?: boolean
    type?: boolean
    logo?: boolean
    sok?: boolean
    optional?: boolean
    newPrice?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    amount?: boolean
    volume?: boolean
    status?: boolean
    change?: boolean
    changePercent?: boolean
    date?: boolean
    extra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockRecord?: boolean | Stock$stockRecordArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      stockRecord: Prisma.$StockRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      code: string
      symbol: string
      name: string
      cname: string | null
      type: string
      logo: string | null
      sok: string | null
      optional: boolean
      newPrice: string | null
      open: string | null
      close: string | null
      high: string | null
      low: string | null
      amount: string | null
      volume: string | null
      status: $Enums.STOCK_STATUS
      change: string | null
      changePercent: string | null
      date: string | null
      extra: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }


  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>
    ): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Stock that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>
    ): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockWithIdOnly = await prisma.stock.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
    **/
    create<T extends StockCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockCreateArgs<ExtArgs>>
    ): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Stocks.
     *     @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     *     @example
     *     // Create many Stocks
     *     const stock = await prisma.stock.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
    **/
    delete<T extends StockDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockDeleteArgs<ExtArgs>>
    ): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockUpdateArgs<ExtArgs>>
    ): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
    **/
    upsert<T extends StockUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockUpsertArgs<ExtArgs>>
    ): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stockRecord<T extends Stock$stockRecordArgs<ExtArgs> = {}>(args?: Subset<T, Stock$stockRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Stock model
   */ 
  interface StockFieldRefs {
    readonly id: FieldRef<"Stock", 'BigInt'>
    readonly code: FieldRef<"Stock", 'String'>
    readonly symbol: FieldRef<"Stock", 'String'>
    readonly name: FieldRef<"Stock", 'String'>
    readonly cname: FieldRef<"Stock", 'String'>
    readonly type: FieldRef<"Stock", 'String'>
    readonly logo: FieldRef<"Stock", 'String'>
    readonly sok: FieldRef<"Stock", 'String'>
    readonly optional: FieldRef<"Stock", 'Boolean'>
    readonly newPrice: FieldRef<"Stock", 'String'>
    readonly open: FieldRef<"Stock", 'String'>
    readonly close: FieldRef<"Stock", 'String'>
    readonly high: FieldRef<"Stock", 'String'>
    readonly low: FieldRef<"Stock", 'String'>
    readonly amount: FieldRef<"Stock", 'String'>
    readonly volume: FieldRef<"Stock", 'String'>
    readonly status: FieldRef<"Stock", 'STOCK_STATUS'>
    readonly change: FieldRef<"Stock", 'String'>
    readonly changePercent: FieldRef<"Stock", 'String'>
    readonly date: FieldRef<"Stock", 'String'>
    readonly extra: FieldRef<"Stock", 'Json'>
    readonly createdAt: FieldRef<"Stock", 'DateTime'>
    readonly updatedAt: FieldRef<"Stock", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }


  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }


  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }


  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }


  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }


  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }


  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }


  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
  }


  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }


  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }


  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
  }


  /**
   * Stock.stockRecord
   */
  export type Stock$stockRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    where?: StockRecordWhereInput
    orderBy?: StockRecordOrderByWithRelationInput | StockRecordOrderByWithRelationInput[]
    cursor?: StockRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockRecordScalarFieldEnum | StockRecordScalarFieldEnum[]
  }


  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockInclude<ExtArgs> | null
  }



  /**
   * Model StockRecord
   */

  export type AggregateStockRecord = {
    _count: StockRecordCountAggregateOutputType | null
    _avg: StockRecordAvgAggregateOutputType | null
    _sum: StockRecordSumAggregateOutputType | null
    _min: StockRecordMinAggregateOutputType | null
    _max: StockRecordMaxAggregateOutputType | null
  }

  export type StockRecordAvgAggregateOutputType = {
    id: number | null
    stockId: number | null
  }

  export type StockRecordSumAggregateOutputType = {
    id: bigint | null
    stockId: bigint | null
  }

  export type StockRecordMinAggregateOutputType = {
    id: bigint | null
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    date: string | null
    createdAt: Date | null
    stockId: bigint | null
  }

  export type StockRecordMaxAggregateOutputType = {
    id: bigint | null
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    date: string | null
    createdAt: Date | null
    stockId: bigint | null
  }

  export type StockRecordCountAggregateOutputType = {
    id: number
    newPrice: number
    open: number
    close: number
    high: number
    low: number
    amount: number
    volume: number
    date: number
    extra: number
    createdAt: number
    stockId: number
    _all: number
  }


  export type StockRecordAvgAggregateInputType = {
    id?: true
    stockId?: true
  }

  export type StockRecordSumAggregateInputType = {
    id?: true
    stockId?: true
  }

  export type StockRecordMinAggregateInputType = {
    id?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    date?: true
    createdAt?: true
    stockId?: true
  }

  export type StockRecordMaxAggregateInputType = {
    id?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    date?: true
    createdAt?: true
    stockId?: true
  }

  export type StockRecordCountAggregateInputType = {
    id?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    date?: true
    extra?: true
    createdAt?: true
    stockId?: true
    _all?: true
  }

  export type StockRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockRecord to aggregate.
     */
    where?: StockRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockRecords to fetch.
     */
    orderBy?: StockRecordOrderByWithRelationInput | StockRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockRecords
    **/
    _count?: true | StockRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockRecordMaxAggregateInputType
  }

  export type GetStockRecordAggregateType<T extends StockRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateStockRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockRecord[P]>
      : GetScalarType<T[P], AggregateStockRecord[P]>
  }




  export type StockRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockRecordWhereInput
    orderBy?: StockRecordOrderByWithAggregationInput | StockRecordOrderByWithAggregationInput[]
    by: StockRecordScalarFieldEnum[] | StockRecordScalarFieldEnum
    having?: StockRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockRecordCountAggregateInputType | true
    _avg?: StockRecordAvgAggregateInputType
    _sum?: StockRecordSumAggregateInputType
    _min?: StockRecordMinAggregateInputType
    _max?: StockRecordMaxAggregateInputType
  }

  export type StockRecordGroupByOutputType = {
    id: bigint
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date: string
    extra: JsonValue
    createdAt: Date
    stockId: bigint
    _count: StockRecordCountAggregateOutputType | null
    _avg: StockRecordAvgAggregateOutputType | null
    _sum: StockRecordSumAggregateOutputType | null
    _min: StockRecordMinAggregateOutputType | null
    _max: StockRecordMaxAggregateOutputType | null
  }

  type GetStockRecordGroupByPayload<T extends StockRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockRecordGroupByOutputType[P]>
            : GetScalarType<T[P], StockRecordGroupByOutputType[P]>
        }
      >
    >


  export type StockRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    newPrice?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    amount?: boolean
    volume?: boolean
    date?: boolean
    extra?: boolean
    createdAt?: boolean
    stockId?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockRecord"]>

  export type StockRecordSelectScalar = {
    id?: boolean
    newPrice?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    amount?: boolean
    volume?: boolean
    date?: boolean
    extra?: boolean
    createdAt?: boolean
    stockId?: boolean
  }

  export type StockRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
  }


  export type $StockRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockRecord"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      newPrice: string
      open: string
      close: string
      high: string
      low: string
      amount: string
      volume: string
      date: string
      extra: Prisma.JsonValue
      createdAt: Date
      stockId: bigint
    }, ExtArgs["result"]["stockRecord"]>
    composites: {}
  }


  type StockRecordGetPayload<S extends boolean | null | undefined | StockRecordDefaultArgs> = $Result.GetResult<Prisma.$StockRecordPayload, S>

  type StockRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockRecordCountAggregateInputType | true
    }

  export interface StockRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockRecord'], meta: { name: 'StockRecord' } }
    /**
     * Find zero or one StockRecord that matches the filter.
     * @param {StockRecordFindUniqueArgs} args - Arguments to find a StockRecord
     * @example
     * // Get one StockRecord
     * const stockRecord = await prisma.stockRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockRecordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockRecordFindUniqueArgs<ExtArgs>>
    ): Prisma__StockRecordClient<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockRecordFindUniqueOrThrowArgs} args - Arguments to find a StockRecord
     * @example
     * // Get one StockRecord
     * const stockRecord = await prisma.stockRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockRecordClient<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockRecordFindFirstArgs} args - Arguments to find a StockRecord
     * @example
     * // Get one StockRecord
     * const stockRecord = await prisma.stockRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockRecordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockRecordFindFirstArgs<ExtArgs>>
    ): Prisma__StockRecordClient<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockRecordFindFirstOrThrowArgs} args - Arguments to find a StockRecord
     * @example
     * // Get one StockRecord
     * const stockRecord = await prisma.stockRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockRecordClient<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockRecords
     * const stockRecords = await prisma.stockRecord.findMany()
     * 
     * // Get first 10 StockRecords
     * const stockRecords = await prisma.stockRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockRecordWithIdOnly = await prisma.stockRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockRecord.
     * @param {StockRecordCreateArgs} args - Arguments to create a StockRecord.
     * @example
     * // Create one StockRecord
     * const StockRecord = await prisma.stockRecord.create({
     *   data: {
     *     // ... data to create a StockRecord
     *   }
     * })
     * 
    **/
    create<T extends StockRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockRecordCreateArgs<ExtArgs>>
    ): Prisma__StockRecordClient<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockRecords.
     *     @param {StockRecordCreateManyArgs} args - Arguments to create many StockRecords.
     *     @example
     *     // Create many StockRecords
     *     const stockRecord = await prisma.stockRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockRecord.
     * @param {StockRecordDeleteArgs} args - Arguments to delete one StockRecord.
     * @example
     * // Delete one StockRecord
     * const StockRecord = await prisma.stockRecord.delete({
     *   where: {
     *     // ... filter to delete one StockRecord
     *   }
     * })
     * 
    **/
    delete<T extends StockRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockRecordDeleteArgs<ExtArgs>>
    ): Prisma__StockRecordClient<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockRecord.
     * @param {StockRecordUpdateArgs} args - Arguments to update one StockRecord.
     * @example
     * // Update one StockRecord
     * const stockRecord = await prisma.stockRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockRecordUpdateArgs<ExtArgs>>
    ): Prisma__StockRecordClient<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockRecords.
     * @param {StockRecordDeleteManyArgs} args - Arguments to filter StockRecords to delete.
     * @example
     * // Delete a few StockRecords
     * const { count } = await prisma.stockRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockRecords
     * const stockRecord = await prisma.stockRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockRecord.
     * @param {StockRecordUpsertArgs} args - Arguments to update or create a StockRecord.
     * @example
     * // Update or create a StockRecord
     * const stockRecord = await prisma.stockRecord.upsert({
     *   create: {
     *     // ... data to create a StockRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockRecord we want to update
     *   }
     * })
    **/
    upsert<T extends StockRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockRecordUpsertArgs<ExtArgs>>
    ): Prisma__StockRecordClient<$Result.GetResult<Prisma.$StockRecordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockRecordCountArgs} args - Arguments to filter StockRecords to count.
     * @example
     * // Count the number of StockRecords
     * const count = await prisma.stockRecord.count({
     *   where: {
     *     // ... the filter for the StockRecords we want to count
     *   }
     * })
    **/
    count<T extends StockRecordCountArgs>(
      args?: Subset<T, StockRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockRecordAggregateArgs>(args: Subset<T, StockRecordAggregateArgs>): Prisma.PrismaPromise<GetStockRecordAggregateType<T>>

    /**
     * Group by StockRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockRecordGroupByArgs['orderBy'] }
        : { orderBy?: StockRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockRecord model
   */
  readonly fields: StockRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockRecord model
   */ 
  interface StockRecordFieldRefs {
    readonly id: FieldRef<"StockRecord", 'BigInt'>
    readonly newPrice: FieldRef<"StockRecord", 'String'>
    readonly open: FieldRef<"StockRecord", 'String'>
    readonly close: FieldRef<"StockRecord", 'String'>
    readonly high: FieldRef<"StockRecord", 'String'>
    readonly low: FieldRef<"StockRecord", 'String'>
    readonly amount: FieldRef<"StockRecord", 'String'>
    readonly volume: FieldRef<"StockRecord", 'String'>
    readonly date: FieldRef<"StockRecord", 'String'>
    readonly extra: FieldRef<"StockRecord", 'Json'>
    readonly createdAt: FieldRef<"StockRecord", 'DateTime'>
    readonly stockId: FieldRef<"StockRecord", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * StockRecord findUnique
   */
  export type StockRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    /**
     * Filter, which StockRecord to fetch.
     */
    where: StockRecordWhereUniqueInput
  }


  /**
   * StockRecord findUniqueOrThrow
   */
  export type StockRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    /**
     * Filter, which StockRecord to fetch.
     */
    where: StockRecordWhereUniqueInput
  }


  /**
   * StockRecord findFirst
   */
  export type StockRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    /**
     * Filter, which StockRecord to fetch.
     */
    where?: StockRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockRecords to fetch.
     */
    orderBy?: StockRecordOrderByWithRelationInput | StockRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockRecords.
     */
    cursor?: StockRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockRecords.
     */
    distinct?: StockRecordScalarFieldEnum | StockRecordScalarFieldEnum[]
  }


  /**
   * StockRecord findFirstOrThrow
   */
  export type StockRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    /**
     * Filter, which StockRecord to fetch.
     */
    where?: StockRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockRecords to fetch.
     */
    orderBy?: StockRecordOrderByWithRelationInput | StockRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockRecords.
     */
    cursor?: StockRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockRecords.
     */
    distinct?: StockRecordScalarFieldEnum | StockRecordScalarFieldEnum[]
  }


  /**
   * StockRecord findMany
   */
  export type StockRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    /**
     * Filter, which StockRecords to fetch.
     */
    where?: StockRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockRecords to fetch.
     */
    orderBy?: StockRecordOrderByWithRelationInput | StockRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockRecords.
     */
    cursor?: StockRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockRecords.
     */
    skip?: number
    distinct?: StockRecordScalarFieldEnum | StockRecordScalarFieldEnum[]
  }


  /**
   * StockRecord create
   */
  export type StockRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a StockRecord.
     */
    data: XOR<StockRecordCreateInput, StockRecordUncheckedCreateInput>
  }


  /**
   * StockRecord createMany
   */
  export type StockRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockRecords.
     */
    data: StockRecordCreateManyInput | StockRecordCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockRecord update
   */
  export type StockRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a StockRecord.
     */
    data: XOR<StockRecordUpdateInput, StockRecordUncheckedUpdateInput>
    /**
     * Choose, which StockRecord to update.
     */
    where: StockRecordWhereUniqueInput
  }


  /**
   * StockRecord updateMany
   */
  export type StockRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockRecords.
     */
    data: XOR<StockRecordUpdateManyMutationInput, StockRecordUncheckedUpdateManyInput>
    /**
     * Filter which StockRecords to update
     */
    where?: StockRecordWhereInput
  }


  /**
   * StockRecord upsert
   */
  export type StockRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the StockRecord to update in case it exists.
     */
    where: StockRecordWhereUniqueInput
    /**
     * In case the StockRecord found by the `where` argument doesn't exist, create a new StockRecord with this data.
     */
    create: XOR<StockRecordCreateInput, StockRecordUncheckedCreateInput>
    /**
     * In case the StockRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockRecordUpdateInput, StockRecordUncheckedUpdateInput>
  }


  /**
   * StockRecord delete
   */
  export type StockRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
    /**
     * Filter which StockRecord to delete.
     */
    where: StockRecordWhereUniqueInput
  }


  /**
   * StockRecord deleteMany
   */
  export type StockRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockRecords to delete
     */
    where?: StockRecordWhereInput
  }


  /**
   * StockRecord without action
   */
  export type StockRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockRecord
     */
    select?: StockRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockRecordInclude<ExtArgs> | null
  }



  /**
   * Model StockMarket
   */

  export type AggregateStockMarket = {
    _count: StockMarketCountAggregateOutputType | null
    _avg: StockMarketAvgAggregateOutputType | null
    _sum: StockMarketSumAggregateOutputType | null
    _min: StockMarketMinAggregateOutputType | null
    _max: StockMarketMaxAggregateOutputType | null
  }

  export type StockMarketAvgAggregateOutputType = {
    id: number | null
    frequency: number | null
    bindingHours: number | null
    sort: number | null
    online: number | null
    conline: number | null
  }

  export type StockMarketSumAggregateOutputType = {
    id: bigint | null
    frequency: number | null
    bindingHours: number | null
    sort: number | null
    online: number | null
    conline: number | null
  }

  export type StockMarketMinAggregateOutputType = {
    id: bigint | null
    code: string | null
    currency: string | null
    showName: string | null
    maxWithdrawal: string | null
    minWithdrawal: string | null
    feeRate: string | null
    minFee: string | null
    lever: string | null
    mmr: string | null
    allocationRate: string | null
    frequency: number | null
    bindingHours: number | null
    headSymbols: string | null
    sort: number | null
    online: number | null
    conline: number | null
    openTime: string | null
    timezone: string | null
    beforeTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockMarketMaxAggregateOutputType = {
    id: bigint | null
    code: string | null
    currency: string | null
    showName: string | null
    maxWithdrawal: string | null
    minWithdrawal: string | null
    feeRate: string | null
    minFee: string | null
    lever: string | null
    mmr: string | null
    allocationRate: string | null
    frequency: number | null
    bindingHours: number | null
    headSymbols: string | null
    sort: number | null
    online: number | null
    conline: number | null
    openTime: string | null
    timezone: string | null
    beforeTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockMarketCountAggregateOutputType = {
    id: number
    code: number
    currency: number
    showName: number
    maxWithdrawal: number
    minWithdrawal: number
    feeRate: number
    minFee: number
    lever: number
    mmr: number
    allocationRate: number
    frequency: number
    bindingHours: number
    headSymbols: number
    sort: number
    online: number
    conline: number
    openTime: number
    timezone: number
    beforeTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockMarketAvgAggregateInputType = {
    id?: true
    frequency?: true
    bindingHours?: true
    sort?: true
    online?: true
    conline?: true
  }

  export type StockMarketSumAggregateInputType = {
    id?: true
    frequency?: true
    bindingHours?: true
    sort?: true
    online?: true
    conline?: true
  }

  export type StockMarketMinAggregateInputType = {
    id?: true
    code?: true
    currency?: true
    showName?: true
    maxWithdrawal?: true
    minWithdrawal?: true
    feeRate?: true
    minFee?: true
    lever?: true
    mmr?: true
    allocationRate?: true
    frequency?: true
    bindingHours?: true
    headSymbols?: true
    sort?: true
    online?: true
    conline?: true
    openTime?: true
    timezone?: true
    beforeTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockMarketMaxAggregateInputType = {
    id?: true
    code?: true
    currency?: true
    showName?: true
    maxWithdrawal?: true
    minWithdrawal?: true
    feeRate?: true
    minFee?: true
    lever?: true
    mmr?: true
    allocationRate?: true
    frequency?: true
    bindingHours?: true
    headSymbols?: true
    sort?: true
    online?: true
    conline?: true
    openTime?: true
    timezone?: true
    beforeTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockMarketCountAggregateInputType = {
    id?: true
    code?: true
    currency?: true
    showName?: true
    maxWithdrawal?: true
    minWithdrawal?: true
    feeRate?: true
    minFee?: true
    lever?: true
    mmr?: true
    allocationRate?: true
    frequency?: true
    bindingHours?: true
    headSymbols?: true
    sort?: true
    online?: true
    conline?: true
    openTime?: true
    timezone?: true
    beforeTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockMarketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMarket to aggregate.
     */
    where?: StockMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMarkets to fetch.
     */
    orderBy?: StockMarketOrderByWithRelationInput | StockMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMarkets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMarkets
    **/
    _count?: true | StockMarketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMarketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMarketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMarketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMarketMaxAggregateInputType
  }

  export type GetStockMarketAggregateType<T extends StockMarketAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMarket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMarket[P]>
      : GetScalarType<T[P], AggregateStockMarket[P]>
  }




  export type StockMarketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMarketWhereInput
    orderBy?: StockMarketOrderByWithAggregationInput | StockMarketOrderByWithAggregationInput[]
    by: StockMarketScalarFieldEnum[] | StockMarketScalarFieldEnum
    having?: StockMarketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMarketCountAggregateInputType | true
    _avg?: StockMarketAvgAggregateInputType
    _sum?: StockMarketSumAggregateInputType
    _min?: StockMarketMinAggregateInputType
    _max?: StockMarketMaxAggregateInputType
  }

  export type StockMarketGroupByOutputType = {
    id: bigint
    code: string | null
    currency: string | null
    showName: string | null
    maxWithdrawal: string | null
    minWithdrawal: string | null
    feeRate: string | null
    minFee: string | null
    lever: string | null
    mmr: string | null
    allocationRate: string | null
    frequency: number | null
    bindingHours: number | null
    headSymbols: string | null
    sort: number | null
    online: number | null
    conline: number | null
    openTime: string | null
    timezone: string | null
    beforeTime: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: StockMarketCountAggregateOutputType | null
    _avg: StockMarketAvgAggregateOutputType | null
    _sum: StockMarketSumAggregateOutputType | null
    _min: StockMarketMinAggregateOutputType | null
    _max: StockMarketMaxAggregateOutputType | null
  }

  type GetStockMarketGroupByPayload<T extends StockMarketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMarketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMarketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMarketGroupByOutputType[P]>
            : GetScalarType<T[P], StockMarketGroupByOutputType[P]>
        }
      >
    >


  export type StockMarketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    currency?: boolean
    showName?: boolean
    maxWithdrawal?: boolean
    minWithdrawal?: boolean
    feeRate?: boolean
    minFee?: boolean
    lever?: boolean
    mmr?: boolean
    allocationRate?: boolean
    frequency?: boolean
    bindingHours?: boolean
    headSymbols?: boolean
    sort?: boolean
    online?: boolean
    conline?: boolean
    openTime?: boolean
    timezone?: boolean
    beforeTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stockMarket"]>

  export type StockMarketSelectScalar = {
    id?: boolean
    code?: boolean
    currency?: boolean
    showName?: boolean
    maxWithdrawal?: boolean
    minWithdrawal?: boolean
    feeRate?: boolean
    minFee?: boolean
    lever?: boolean
    mmr?: boolean
    allocationRate?: boolean
    frequency?: boolean
    bindingHours?: boolean
    headSymbols?: boolean
    sort?: boolean
    online?: boolean
    conline?: boolean
    openTime?: boolean
    timezone?: boolean
    beforeTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $StockMarketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMarket"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      code: string | null
      currency: string | null
      showName: string | null
      maxWithdrawal: string | null
      minWithdrawal: string | null
      feeRate: string | null
      minFee: string | null
      lever: string | null
      mmr: string | null
      allocationRate: string | null
      frequency: number | null
      bindingHours: number | null
      headSymbols: string | null
      sort: number | null
      online: number | null
      conline: number | null
      openTime: string | null
      timezone: string | null
      beforeTime: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["stockMarket"]>
    composites: {}
  }


  type StockMarketGetPayload<S extends boolean | null | undefined | StockMarketDefaultArgs> = $Result.GetResult<Prisma.$StockMarketPayload, S>

  type StockMarketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockMarketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockMarketCountAggregateInputType | true
    }

  export interface StockMarketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMarket'], meta: { name: 'StockMarket' } }
    /**
     * Find zero or one StockMarket that matches the filter.
     * @param {StockMarketFindUniqueArgs} args - Arguments to find a StockMarket
     * @example
     * // Get one StockMarket
     * const stockMarket = await prisma.stockMarket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockMarketFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockMarketFindUniqueArgs<ExtArgs>>
    ): Prisma__StockMarketClient<$Result.GetResult<Prisma.$StockMarketPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockMarket that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockMarketFindUniqueOrThrowArgs} args - Arguments to find a StockMarket
     * @example
     * // Get one StockMarket
     * const stockMarket = await prisma.stockMarket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockMarketFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMarketFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockMarketClient<$Result.GetResult<Prisma.$StockMarketPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockMarket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMarketFindFirstArgs} args - Arguments to find a StockMarket
     * @example
     * // Get one StockMarket
     * const stockMarket = await prisma.stockMarket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockMarketFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMarketFindFirstArgs<ExtArgs>>
    ): Prisma__StockMarketClient<$Result.GetResult<Prisma.$StockMarketPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockMarket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMarketFindFirstOrThrowArgs} args - Arguments to find a StockMarket
     * @example
     * // Get one StockMarket
     * const stockMarket = await prisma.stockMarket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockMarketFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMarketFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockMarketClient<$Result.GetResult<Prisma.$StockMarketPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockMarkets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMarketFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMarkets
     * const stockMarkets = await prisma.stockMarket.findMany()
     * 
     * // Get first 10 StockMarkets
     * const stockMarkets = await prisma.stockMarket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMarketWithIdOnly = await prisma.stockMarket.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockMarketFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMarketFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMarketPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockMarket.
     * @param {StockMarketCreateArgs} args - Arguments to create a StockMarket.
     * @example
     * // Create one StockMarket
     * const StockMarket = await prisma.stockMarket.create({
     *   data: {
     *     // ... data to create a StockMarket
     *   }
     * })
     * 
    **/
    create<T extends StockMarketCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockMarketCreateArgs<ExtArgs>>
    ): Prisma__StockMarketClient<$Result.GetResult<Prisma.$StockMarketPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockMarkets.
     *     @param {StockMarketCreateManyArgs} args - Arguments to create many StockMarkets.
     *     @example
     *     // Create many StockMarkets
     *     const stockMarket = await prisma.stockMarket.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockMarketCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMarketCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockMarket.
     * @param {StockMarketDeleteArgs} args - Arguments to delete one StockMarket.
     * @example
     * // Delete one StockMarket
     * const StockMarket = await prisma.stockMarket.delete({
     *   where: {
     *     // ... filter to delete one StockMarket
     *   }
     * })
     * 
    **/
    delete<T extends StockMarketDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockMarketDeleteArgs<ExtArgs>>
    ): Prisma__StockMarketClient<$Result.GetResult<Prisma.$StockMarketPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockMarket.
     * @param {StockMarketUpdateArgs} args - Arguments to update one StockMarket.
     * @example
     * // Update one StockMarket
     * const stockMarket = await prisma.stockMarket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockMarketUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockMarketUpdateArgs<ExtArgs>>
    ): Prisma__StockMarketClient<$Result.GetResult<Prisma.$StockMarketPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockMarkets.
     * @param {StockMarketDeleteManyArgs} args - Arguments to filter StockMarkets to delete.
     * @example
     * // Delete a few StockMarkets
     * const { count } = await prisma.stockMarket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockMarketDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockMarketDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMarkets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMarketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMarkets
     * const stockMarket = await prisma.stockMarket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockMarketUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockMarketUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockMarket.
     * @param {StockMarketUpsertArgs} args - Arguments to update or create a StockMarket.
     * @example
     * // Update or create a StockMarket
     * const stockMarket = await prisma.stockMarket.upsert({
     *   create: {
     *     // ... data to create a StockMarket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMarket we want to update
     *   }
     * })
    **/
    upsert<T extends StockMarketUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockMarketUpsertArgs<ExtArgs>>
    ): Prisma__StockMarketClient<$Result.GetResult<Prisma.$StockMarketPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockMarkets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMarketCountArgs} args - Arguments to filter StockMarkets to count.
     * @example
     * // Count the number of StockMarkets
     * const count = await prisma.stockMarket.count({
     *   where: {
     *     // ... the filter for the StockMarkets we want to count
     *   }
     * })
    **/
    count<T extends StockMarketCountArgs>(
      args?: Subset<T, StockMarketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMarketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMarket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMarketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMarketAggregateArgs>(args: Subset<T, StockMarketAggregateArgs>): Prisma.PrismaPromise<GetStockMarketAggregateType<T>>

    /**
     * Group by StockMarket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMarketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMarketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMarketGroupByArgs['orderBy'] }
        : { orderBy?: StockMarketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMarketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMarketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMarket model
   */
  readonly fields: StockMarketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMarket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMarketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockMarket model
   */ 
  interface StockMarketFieldRefs {
    readonly id: FieldRef<"StockMarket", 'BigInt'>
    readonly code: FieldRef<"StockMarket", 'String'>
    readonly currency: FieldRef<"StockMarket", 'String'>
    readonly showName: FieldRef<"StockMarket", 'String'>
    readonly maxWithdrawal: FieldRef<"StockMarket", 'String'>
    readonly minWithdrawal: FieldRef<"StockMarket", 'String'>
    readonly feeRate: FieldRef<"StockMarket", 'String'>
    readonly minFee: FieldRef<"StockMarket", 'String'>
    readonly lever: FieldRef<"StockMarket", 'String'>
    readonly mmr: FieldRef<"StockMarket", 'String'>
    readonly allocationRate: FieldRef<"StockMarket", 'String'>
    readonly frequency: FieldRef<"StockMarket", 'Int'>
    readonly bindingHours: FieldRef<"StockMarket", 'Int'>
    readonly headSymbols: FieldRef<"StockMarket", 'String'>
    readonly sort: FieldRef<"StockMarket", 'Int'>
    readonly online: FieldRef<"StockMarket", 'Int'>
    readonly conline: FieldRef<"StockMarket", 'Int'>
    readonly openTime: FieldRef<"StockMarket", 'String'>
    readonly timezone: FieldRef<"StockMarket", 'String'>
    readonly beforeTime: FieldRef<"StockMarket", 'String'>
    readonly createdAt: FieldRef<"StockMarket", 'DateTime'>
    readonly updatedAt: FieldRef<"StockMarket", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StockMarket findUnique
   */
  export type StockMarketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
    /**
     * Filter, which StockMarket to fetch.
     */
    where: StockMarketWhereUniqueInput
  }


  /**
   * StockMarket findUniqueOrThrow
   */
  export type StockMarketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
    /**
     * Filter, which StockMarket to fetch.
     */
    where: StockMarketWhereUniqueInput
  }


  /**
   * StockMarket findFirst
   */
  export type StockMarketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
    /**
     * Filter, which StockMarket to fetch.
     */
    where?: StockMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMarkets to fetch.
     */
    orderBy?: StockMarketOrderByWithRelationInput | StockMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMarkets.
     */
    cursor?: StockMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMarkets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMarkets.
     */
    distinct?: StockMarketScalarFieldEnum | StockMarketScalarFieldEnum[]
  }


  /**
   * StockMarket findFirstOrThrow
   */
  export type StockMarketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
    /**
     * Filter, which StockMarket to fetch.
     */
    where?: StockMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMarkets to fetch.
     */
    orderBy?: StockMarketOrderByWithRelationInput | StockMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMarkets.
     */
    cursor?: StockMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMarkets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMarkets.
     */
    distinct?: StockMarketScalarFieldEnum | StockMarketScalarFieldEnum[]
  }


  /**
   * StockMarket findMany
   */
  export type StockMarketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
    /**
     * Filter, which StockMarkets to fetch.
     */
    where?: StockMarketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMarkets to fetch.
     */
    orderBy?: StockMarketOrderByWithRelationInput | StockMarketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMarkets.
     */
    cursor?: StockMarketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMarkets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMarkets.
     */
    skip?: number
    distinct?: StockMarketScalarFieldEnum | StockMarketScalarFieldEnum[]
  }


  /**
   * StockMarket create
   */
  export type StockMarketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
    /**
     * The data needed to create a StockMarket.
     */
    data?: XOR<StockMarketCreateInput, StockMarketUncheckedCreateInput>
  }


  /**
   * StockMarket createMany
   */
  export type StockMarketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMarkets.
     */
    data: StockMarketCreateManyInput | StockMarketCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockMarket update
   */
  export type StockMarketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
    /**
     * The data needed to update a StockMarket.
     */
    data: XOR<StockMarketUpdateInput, StockMarketUncheckedUpdateInput>
    /**
     * Choose, which StockMarket to update.
     */
    where: StockMarketWhereUniqueInput
  }


  /**
   * StockMarket updateMany
   */
  export type StockMarketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMarkets.
     */
    data: XOR<StockMarketUpdateManyMutationInput, StockMarketUncheckedUpdateManyInput>
    /**
     * Filter which StockMarkets to update
     */
    where?: StockMarketWhereInput
  }


  /**
   * StockMarket upsert
   */
  export type StockMarketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
    /**
     * The filter to search for the StockMarket to update in case it exists.
     */
    where: StockMarketWhereUniqueInput
    /**
     * In case the StockMarket found by the `where` argument doesn't exist, create a new StockMarket with this data.
     */
    create: XOR<StockMarketCreateInput, StockMarketUncheckedCreateInput>
    /**
     * In case the StockMarket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMarketUpdateInput, StockMarketUncheckedUpdateInput>
  }


  /**
   * StockMarket delete
   */
  export type StockMarketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
    /**
     * Filter which StockMarket to delete.
     */
    where: StockMarketWhereUniqueInput
  }


  /**
   * StockMarket deleteMany
   */
  export type StockMarketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMarkets to delete
     */
    where?: StockMarketWhereInput
  }


  /**
   * StockMarket without action
   */
  export type StockMarketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMarket
     */
    select?: StockMarketSelect<ExtArgs> | null
  }



  /**
   * Model StockFavorite
   */

  export type AggregateStockFavorite = {
    _count: StockFavoriteCountAggregateOutputType | null
    _avg: StockFavoriteAvgAggregateOutputType | null
    _sum: StockFavoriteSumAggregateOutputType | null
    _min: StockFavoriteMinAggregateOutputType | null
    _max: StockFavoriteMaxAggregateOutputType | null
  }

  export type StockFavoriteAvgAggregateOutputType = {
    id: number | null
    memberId: number | null
    stockSymbolId: number | null
  }

  export type StockFavoriteSumAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
    stockSymbolId: bigint | null
  }

  export type StockFavoriteMinAggregateOutputType = {
    id: bigint | null
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    date: string | null
    memberId: bigint | null
    stockSymbolId: bigint | null
    createdAt: Date | null
  }

  export type StockFavoriteMaxAggregateOutputType = {
    id: bigint | null
    newPrice: string | null
    open: string | null
    close: string | null
    high: string | null
    low: string | null
    amount: string | null
    volume: string | null
    date: string | null
    memberId: bigint | null
    stockSymbolId: bigint | null
    createdAt: Date | null
  }

  export type StockFavoriteCountAggregateOutputType = {
    id: number
    newPrice: number
    open: number
    close: number
    high: number
    low: number
    amount: number
    volume: number
    date: number
    extra: number
    memberId: number
    stockSymbolId: number
    createdAt: number
    _all: number
  }


  export type StockFavoriteAvgAggregateInputType = {
    id?: true
    memberId?: true
    stockSymbolId?: true
  }

  export type StockFavoriteSumAggregateInputType = {
    id?: true
    memberId?: true
    stockSymbolId?: true
  }

  export type StockFavoriteMinAggregateInputType = {
    id?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    date?: true
    memberId?: true
    stockSymbolId?: true
    createdAt?: true
  }

  export type StockFavoriteMaxAggregateInputType = {
    id?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    date?: true
    memberId?: true
    stockSymbolId?: true
    createdAt?: true
  }

  export type StockFavoriteCountAggregateInputType = {
    id?: true
    newPrice?: true
    open?: true
    close?: true
    high?: true
    low?: true
    amount?: true
    volume?: true
    date?: true
    extra?: true
    memberId?: true
    stockSymbolId?: true
    createdAt?: true
    _all?: true
  }

  export type StockFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockFavorite to aggregate.
     */
    where?: StockFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockFavorites to fetch.
     */
    orderBy?: StockFavoriteOrderByWithRelationInput | StockFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockFavorites
    **/
    _count?: true | StockFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockFavoriteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockFavoriteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockFavoriteMaxAggregateInputType
  }

  export type GetStockFavoriteAggregateType<T extends StockFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateStockFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockFavorite[P]>
      : GetScalarType<T[P], AggregateStockFavorite[P]>
  }




  export type StockFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockFavoriteWhereInput
    orderBy?: StockFavoriteOrderByWithAggregationInput | StockFavoriteOrderByWithAggregationInput[]
    by: StockFavoriteScalarFieldEnum[] | StockFavoriteScalarFieldEnum
    having?: StockFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockFavoriteCountAggregateInputType | true
    _avg?: StockFavoriteAvgAggregateInputType
    _sum?: StockFavoriteSumAggregateInputType
    _min?: StockFavoriteMinAggregateInputType
    _max?: StockFavoriteMaxAggregateInputType
  }

  export type StockFavoriteGroupByOutputType = {
    id: bigint
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date: string | null
    extra: JsonValue | null
    memberId: bigint
    stockSymbolId: bigint
    createdAt: Date
    _count: StockFavoriteCountAggregateOutputType | null
    _avg: StockFavoriteAvgAggregateOutputType | null
    _sum: StockFavoriteSumAggregateOutputType | null
    _min: StockFavoriteMinAggregateOutputType | null
    _max: StockFavoriteMaxAggregateOutputType | null
  }

  type GetStockFavoriteGroupByPayload<T extends StockFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], StockFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type StockFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    newPrice?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    amount?: boolean
    volume?: boolean
    date?: boolean
    extra?: boolean
    memberId?: boolean
    stockSymbolId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["stockFavorite"]>

  export type StockFavoriteSelectScalar = {
    id?: boolean
    newPrice?: boolean
    open?: boolean
    close?: boolean
    high?: boolean
    low?: boolean
    amount?: boolean
    volume?: boolean
    date?: boolean
    extra?: boolean
    memberId?: boolean
    stockSymbolId?: boolean
    createdAt?: boolean
  }


  export type $StockFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockFavorite"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      newPrice: string
      open: string
      close: string
      high: string
      low: string
      amount: string
      volume: string
      date: string | null
      extra: Prisma.JsonValue | null
      memberId: bigint
      stockSymbolId: bigint
      createdAt: Date
    }, ExtArgs["result"]["stockFavorite"]>
    composites: {}
  }


  type StockFavoriteGetPayload<S extends boolean | null | undefined | StockFavoriteDefaultArgs> = $Result.GetResult<Prisma.$StockFavoritePayload, S>

  type StockFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockFavoriteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockFavoriteCountAggregateInputType | true
    }

  export interface StockFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockFavorite'], meta: { name: 'StockFavorite' } }
    /**
     * Find zero or one StockFavorite that matches the filter.
     * @param {StockFavoriteFindUniqueArgs} args - Arguments to find a StockFavorite
     * @example
     * // Get one StockFavorite
     * const stockFavorite = await prisma.stockFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockFavoriteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockFavoriteFindUniqueArgs<ExtArgs>>
    ): Prisma__StockFavoriteClient<$Result.GetResult<Prisma.$StockFavoritePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockFavorite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockFavoriteFindUniqueOrThrowArgs} args - Arguments to find a StockFavorite
     * @example
     * // Get one StockFavorite
     * const stockFavorite = await prisma.stockFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockFavoriteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFavoriteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockFavoriteClient<$Result.GetResult<Prisma.$StockFavoritePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFavoriteFindFirstArgs} args - Arguments to find a StockFavorite
     * @example
     * // Get one StockFavorite
     * const stockFavorite = await prisma.stockFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockFavoriteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFavoriteFindFirstArgs<ExtArgs>>
    ): Prisma__StockFavoriteClient<$Result.GetResult<Prisma.$StockFavoritePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFavoriteFindFirstOrThrowArgs} args - Arguments to find a StockFavorite
     * @example
     * // Get one StockFavorite
     * const stockFavorite = await prisma.stockFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockFavoriteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFavoriteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockFavoriteClient<$Result.GetResult<Prisma.$StockFavoritePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFavoriteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockFavorites
     * const stockFavorites = await prisma.stockFavorite.findMany()
     * 
     * // Get first 10 StockFavorites
     * const stockFavorites = await prisma.stockFavorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockFavoriteWithIdOnly = await prisma.stockFavorite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockFavoriteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFavoriteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockFavoritePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockFavorite.
     * @param {StockFavoriteCreateArgs} args - Arguments to create a StockFavorite.
     * @example
     * // Create one StockFavorite
     * const StockFavorite = await prisma.stockFavorite.create({
     *   data: {
     *     // ... data to create a StockFavorite
     *   }
     * })
     * 
    **/
    create<T extends StockFavoriteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockFavoriteCreateArgs<ExtArgs>>
    ): Prisma__StockFavoriteClient<$Result.GetResult<Prisma.$StockFavoritePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockFavorites.
     *     @param {StockFavoriteCreateManyArgs} args - Arguments to create many StockFavorites.
     *     @example
     *     // Create many StockFavorites
     *     const stockFavorite = await prisma.stockFavorite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockFavoriteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFavoriteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockFavorite.
     * @param {StockFavoriteDeleteArgs} args - Arguments to delete one StockFavorite.
     * @example
     * // Delete one StockFavorite
     * const StockFavorite = await prisma.stockFavorite.delete({
     *   where: {
     *     // ... filter to delete one StockFavorite
     *   }
     * })
     * 
    **/
    delete<T extends StockFavoriteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockFavoriteDeleteArgs<ExtArgs>>
    ): Prisma__StockFavoriteClient<$Result.GetResult<Prisma.$StockFavoritePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockFavorite.
     * @param {StockFavoriteUpdateArgs} args - Arguments to update one StockFavorite.
     * @example
     * // Update one StockFavorite
     * const stockFavorite = await prisma.stockFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockFavoriteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockFavoriteUpdateArgs<ExtArgs>>
    ): Prisma__StockFavoriteClient<$Result.GetResult<Prisma.$StockFavoritePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockFavorites.
     * @param {StockFavoriteDeleteManyArgs} args - Arguments to filter StockFavorites to delete.
     * @example
     * // Delete a few StockFavorites
     * const { count } = await prisma.stockFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockFavoriteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockFavoriteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockFavorites
     * const stockFavorite = await prisma.stockFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockFavoriteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockFavoriteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockFavorite.
     * @param {StockFavoriteUpsertArgs} args - Arguments to update or create a StockFavorite.
     * @example
     * // Update or create a StockFavorite
     * const stockFavorite = await prisma.stockFavorite.upsert({
     *   create: {
     *     // ... data to create a StockFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockFavorite we want to update
     *   }
     * })
    **/
    upsert<T extends StockFavoriteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockFavoriteUpsertArgs<ExtArgs>>
    ): Prisma__StockFavoriteClient<$Result.GetResult<Prisma.$StockFavoritePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFavoriteCountArgs} args - Arguments to filter StockFavorites to count.
     * @example
     * // Count the number of StockFavorites
     * const count = await prisma.stockFavorite.count({
     *   where: {
     *     // ... the filter for the StockFavorites we want to count
     *   }
     * })
    **/
    count<T extends StockFavoriteCountArgs>(
      args?: Subset<T, StockFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockFavoriteAggregateArgs>(args: Subset<T, StockFavoriteAggregateArgs>): Prisma.PrismaPromise<GetStockFavoriteAggregateType<T>>

    /**
     * Group by StockFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: StockFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockFavorite model
   */
  readonly fields: StockFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockFavorite model
   */ 
  interface StockFavoriteFieldRefs {
    readonly id: FieldRef<"StockFavorite", 'BigInt'>
    readonly newPrice: FieldRef<"StockFavorite", 'String'>
    readonly open: FieldRef<"StockFavorite", 'String'>
    readonly close: FieldRef<"StockFavorite", 'String'>
    readonly high: FieldRef<"StockFavorite", 'String'>
    readonly low: FieldRef<"StockFavorite", 'String'>
    readonly amount: FieldRef<"StockFavorite", 'String'>
    readonly volume: FieldRef<"StockFavorite", 'String'>
    readonly date: FieldRef<"StockFavorite", 'String'>
    readonly extra: FieldRef<"StockFavorite", 'Json'>
    readonly memberId: FieldRef<"StockFavorite", 'BigInt'>
    readonly stockSymbolId: FieldRef<"StockFavorite", 'BigInt'>
    readonly createdAt: FieldRef<"StockFavorite", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StockFavorite findUnique
   */
  export type StockFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
    /**
     * Filter, which StockFavorite to fetch.
     */
    where: StockFavoriteWhereUniqueInput
  }


  /**
   * StockFavorite findUniqueOrThrow
   */
  export type StockFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
    /**
     * Filter, which StockFavorite to fetch.
     */
    where: StockFavoriteWhereUniqueInput
  }


  /**
   * StockFavorite findFirst
   */
  export type StockFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
    /**
     * Filter, which StockFavorite to fetch.
     */
    where?: StockFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockFavorites to fetch.
     */
    orderBy?: StockFavoriteOrderByWithRelationInput | StockFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockFavorites.
     */
    cursor?: StockFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockFavorites.
     */
    distinct?: StockFavoriteScalarFieldEnum | StockFavoriteScalarFieldEnum[]
  }


  /**
   * StockFavorite findFirstOrThrow
   */
  export type StockFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
    /**
     * Filter, which StockFavorite to fetch.
     */
    where?: StockFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockFavorites to fetch.
     */
    orderBy?: StockFavoriteOrderByWithRelationInput | StockFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockFavorites.
     */
    cursor?: StockFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockFavorites.
     */
    distinct?: StockFavoriteScalarFieldEnum | StockFavoriteScalarFieldEnum[]
  }


  /**
   * StockFavorite findMany
   */
  export type StockFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
    /**
     * Filter, which StockFavorites to fetch.
     */
    where?: StockFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockFavorites to fetch.
     */
    orderBy?: StockFavoriteOrderByWithRelationInput | StockFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockFavorites.
     */
    cursor?: StockFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockFavorites.
     */
    skip?: number
    distinct?: StockFavoriteScalarFieldEnum | StockFavoriteScalarFieldEnum[]
  }


  /**
   * StockFavorite create
   */
  export type StockFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
    /**
     * The data needed to create a StockFavorite.
     */
    data: XOR<StockFavoriteCreateInput, StockFavoriteUncheckedCreateInput>
  }


  /**
   * StockFavorite createMany
   */
  export type StockFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockFavorites.
     */
    data: StockFavoriteCreateManyInput | StockFavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockFavorite update
   */
  export type StockFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
    /**
     * The data needed to update a StockFavorite.
     */
    data: XOR<StockFavoriteUpdateInput, StockFavoriteUncheckedUpdateInput>
    /**
     * Choose, which StockFavorite to update.
     */
    where: StockFavoriteWhereUniqueInput
  }


  /**
   * StockFavorite updateMany
   */
  export type StockFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockFavorites.
     */
    data: XOR<StockFavoriteUpdateManyMutationInput, StockFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which StockFavorites to update
     */
    where?: StockFavoriteWhereInput
  }


  /**
   * StockFavorite upsert
   */
  export type StockFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
    /**
     * The filter to search for the StockFavorite to update in case it exists.
     */
    where: StockFavoriteWhereUniqueInput
    /**
     * In case the StockFavorite found by the `where` argument doesn't exist, create a new StockFavorite with this data.
     */
    create: XOR<StockFavoriteCreateInput, StockFavoriteUncheckedCreateInput>
    /**
     * In case the StockFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockFavoriteUpdateInput, StockFavoriteUncheckedUpdateInput>
  }


  /**
   * StockFavorite delete
   */
  export type StockFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
    /**
     * Filter which StockFavorite to delete.
     */
    where: StockFavoriteWhereUniqueInput
  }


  /**
   * StockFavorite deleteMany
   */
  export type StockFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockFavorites to delete
     */
    where?: StockFavoriteWhereInput
  }


  /**
   * StockFavorite without action
   */
  export type StockFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockFavorite
     */
    select?: StockFavoriteSelect<ExtArgs> | null
  }



  /**
   * Model StockSubscribe
   */

  export type AggregateStockSubscribe = {
    _count: StockSubscribeCountAggregateOutputType | null
    _avg: StockSubscribeAvgAggregateOutputType | null
    _sum: StockSubscribeSumAggregateOutputType | null
    _min: StockSubscribeMinAggregateOutputType | null
    _max: StockSubscribeMaxAggregateOutputType | null
  }

  export type StockSubscribeAvgAggregateOutputType = {
    id: number | null
    circulation: number | null
    remainCirculation: number | null
    ipoPrice: Decimal | null
    issuePrice: Decimal | null
    status: number | null
    type: number | null
  }

  export type StockSubscribeSumAggregateOutputType = {
    id: bigint | null
    circulation: number | null
    remainCirculation: number | null
    ipoPrice: Decimal | null
    issuePrice: Decimal | null
    status: number | null
    type: number | null
  }

  export type StockSubscribeMinAggregateOutputType = {
    id: bigint | null
    market: string | null
    name: string | null
    code: string | null
    startAt: Date | null
    endAt: Date | null
    upAt: Date | null
    circulation: number | null
    remainCirculation: number | null
    ipoPrice: Decimal | null
    issuePrice: Decimal | null
    resultAt: Date | null
    status: number | null
    type: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockSubscribeMaxAggregateOutputType = {
    id: bigint | null
    market: string | null
    name: string | null
    code: string | null
    startAt: Date | null
    endAt: Date | null
    upAt: Date | null
    circulation: number | null
    remainCirculation: number | null
    ipoPrice: Decimal | null
    issuePrice: Decimal | null
    resultAt: Date | null
    status: number | null
    type: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockSubscribeCountAggregateOutputType = {
    id: number
    market: number
    name: number
    code: number
    startAt: number
    endAt: number
    upAt: number
    circulation: number
    remainCirculation: number
    ipoPrice: number
    issuePrice: number
    resultAt: number
    subAmount: number
    status: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockSubscribeAvgAggregateInputType = {
    id?: true
    circulation?: true
    remainCirculation?: true
    ipoPrice?: true
    issuePrice?: true
    status?: true
    type?: true
  }

  export type StockSubscribeSumAggregateInputType = {
    id?: true
    circulation?: true
    remainCirculation?: true
    ipoPrice?: true
    issuePrice?: true
    status?: true
    type?: true
  }

  export type StockSubscribeMinAggregateInputType = {
    id?: true
    market?: true
    name?: true
    code?: true
    startAt?: true
    endAt?: true
    upAt?: true
    circulation?: true
    remainCirculation?: true
    ipoPrice?: true
    issuePrice?: true
    resultAt?: true
    status?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockSubscribeMaxAggregateInputType = {
    id?: true
    market?: true
    name?: true
    code?: true
    startAt?: true
    endAt?: true
    upAt?: true
    circulation?: true
    remainCirculation?: true
    ipoPrice?: true
    issuePrice?: true
    resultAt?: true
    status?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockSubscribeCountAggregateInputType = {
    id?: true
    market?: true
    name?: true
    code?: true
    startAt?: true
    endAt?: true
    upAt?: true
    circulation?: true
    remainCirculation?: true
    ipoPrice?: true
    issuePrice?: true
    resultAt?: true
    subAmount?: true
    status?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockSubscribeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockSubscribe to aggregate.
     */
    where?: StockSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockSubscribes to fetch.
     */
    orderBy?: StockSubscribeOrderByWithRelationInput | StockSubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockSubscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockSubscribes
    **/
    _count?: true | StockSubscribeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockSubscribeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSubscribeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockSubscribeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockSubscribeMaxAggregateInputType
  }

  export type GetStockSubscribeAggregateType<T extends StockSubscribeAggregateArgs> = {
        [P in keyof T & keyof AggregateStockSubscribe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockSubscribe[P]>
      : GetScalarType<T[P], AggregateStockSubscribe[P]>
  }




  export type StockSubscribeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockSubscribeWhereInput
    orderBy?: StockSubscribeOrderByWithAggregationInput | StockSubscribeOrderByWithAggregationInput[]
    by: StockSubscribeScalarFieldEnum[] | StockSubscribeScalarFieldEnum
    having?: StockSubscribeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockSubscribeCountAggregateInputType | true
    _avg?: StockSubscribeAvgAggregateInputType
    _sum?: StockSubscribeSumAggregateInputType
    _min?: StockSubscribeMinAggregateInputType
    _max?: StockSubscribeMaxAggregateInputType
  }

  export type StockSubscribeGroupByOutputType = {
    id: bigint
    market: string
    name: string
    code: string
    startAt: Date | null
    endAt: Date | null
    upAt: Date | null
    circulation: number | null
    remainCirculation: number | null
    ipoPrice: Decimal
    issuePrice: Decimal
    resultAt: Date | null
    subAmount: JsonValue | null
    status: number
    type: number
    createdAt: Date
    updatedAt: Date | null
    _count: StockSubscribeCountAggregateOutputType | null
    _avg: StockSubscribeAvgAggregateOutputType | null
    _sum: StockSubscribeSumAggregateOutputType | null
    _min: StockSubscribeMinAggregateOutputType | null
    _max: StockSubscribeMaxAggregateOutputType | null
  }

  type GetStockSubscribeGroupByPayload<T extends StockSubscribeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockSubscribeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockSubscribeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockSubscribeGroupByOutputType[P]>
            : GetScalarType<T[P], StockSubscribeGroupByOutputType[P]>
        }
      >
    >


  export type StockSubscribeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    market?: boolean
    name?: boolean
    code?: boolean
    startAt?: boolean
    endAt?: boolean
    upAt?: boolean
    circulation?: boolean
    remainCirculation?: boolean
    ipoPrice?: boolean
    issuePrice?: boolean
    resultAt?: boolean
    subAmount?: boolean
    status?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stockSubscribe"]>

  export type StockSubscribeSelectScalar = {
    id?: boolean
    market?: boolean
    name?: boolean
    code?: boolean
    startAt?: boolean
    endAt?: boolean
    upAt?: boolean
    circulation?: boolean
    remainCirculation?: boolean
    ipoPrice?: boolean
    issuePrice?: boolean
    resultAt?: boolean
    subAmount?: boolean
    status?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $StockSubscribePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockSubscribe"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      market: string
      name: string
      code: string
      startAt: Date | null
      endAt: Date | null
      upAt: Date | null
      circulation: number | null
      remainCirculation: number | null
      ipoPrice: Prisma.Decimal
      issuePrice: Prisma.Decimal
      resultAt: Date | null
      subAmount: Prisma.JsonValue | null
      status: number
      type: number
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["stockSubscribe"]>
    composites: {}
  }


  type StockSubscribeGetPayload<S extends boolean | null | undefined | StockSubscribeDefaultArgs> = $Result.GetResult<Prisma.$StockSubscribePayload, S>

  type StockSubscribeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockSubscribeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockSubscribeCountAggregateInputType | true
    }

  export interface StockSubscribeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockSubscribe'], meta: { name: 'StockSubscribe' } }
    /**
     * Find zero or one StockSubscribe that matches the filter.
     * @param {StockSubscribeFindUniqueArgs} args - Arguments to find a StockSubscribe
     * @example
     * // Get one StockSubscribe
     * const stockSubscribe = await prisma.stockSubscribe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockSubscribeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockSubscribeFindUniqueArgs<ExtArgs>>
    ): Prisma__StockSubscribeClient<$Result.GetResult<Prisma.$StockSubscribePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockSubscribe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockSubscribeFindUniqueOrThrowArgs} args - Arguments to find a StockSubscribe
     * @example
     * // Get one StockSubscribe
     * const stockSubscribe = await prisma.stockSubscribe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockSubscribeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSubscribeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockSubscribeClient<$Result.GetResult<Prisma.$StockSubscribePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockSubscribe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSubscribeFindFirstArgs} args - Arguments to find a StockSubscribe
     * @example
     * // Get one StockSubscribe
     * const stockSubscribe = await prisma.stockSubscribe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockSubscribeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSubscribeFindFirstArgs<ExtArgs>>
    ): Prisma__StockSubscribeClient<$Result.GetResult<Prisma.$StockSubscribePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockSubscribe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSubscribeFindFirstOrThrowArgs} args - Arguments to find a StockSubscribe
     * @example
     * // Get one StockSubscribe
     * const stockSubscribe = await prisma.stockSubscribe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockSubscribeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSubscribeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockSubscribeClient<$Result.GetResult<Prisma.$StockSubscribePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockSubscribes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSubscribeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockSubscribes
     * const stockSubscribes = await prisma.stockSubscribe.findMany()
     * 
     * // Get first 10 StockSubscribes
     * const stockSubscribes = await prisma.stockSubscribe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockSubscribeWithIdOnly = await prisma.stockSubscribe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockSubscribeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSubscribeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockSubscribePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockSubscribe.
     * @param {StockSubscribeCreateArgs} args - Arguments to create a StockSubscribe.
     * @example
     * // Create one StockSubscribe
     * const StockSubscribe = await prisma.stockSubscribe.create({
     *   data: {
     *     // ... data to create a StockSubscribe
     *   }
     * })
     * 
    **/
    create<T extends StockSubscribeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockSubscribeCreateArgs<ExtArgs>>
    ): Prisma__StockSubscribeClient<$Result.GetResult<Prisma.$StockSubscribePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockSubscribes.
     *     @param {StockSubscribeCreateManyArgs} args - Arguments to create many StockSubscribes.
     *     @example
     *     // Create many StockSubscribes
     *     const stockSubscribe = await prisma.stockSubscribe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockSubscribeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSubscribeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockSubscribe.
     * @param {StockSubscribeDeleteArgs} args - Arguments to delete one StockSubscribe.
     * @example
     * // Delete one StockSubscribe
     * const StockSubscribe = await prisma.stockSubscribe.delete({
     *   where: {
     *     // ... filter to delete one StockSubscribe
     *   }
     * })
     * 
    **/
    delete<T extends StockSubscribeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockSubscribeDeleteArgs<ExtArgs>>
    ): Prisma__StockSubscribeClient<$Result.GetResult<Prisma.$StockSubscribePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockSubscribe.
     * @param {StockSubscribeUpdateArgs} args - Arguments to update one StockSubscribe.
     * @example
     * // Update one StockSubscribe
     * const stockSubscribe = await prisma.stockSubscribe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockSubscribeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockSubscribeUpdateArgs<ExtArgs>>
    ): Prisma__StockSubscribeClient<$Result.GetResult<Prisma.$StockSubscribePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockSubscribes.
     * @param {StockSubscribeDeleteManyArgs} args - Arguments to filter StockSubscribes to delete.
     * @example
     * // Delete a few StockSubscribes
     * const { count } = await prisma.stockSubscribe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockSubscribeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockSubscribeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockSubscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSubscribeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockSubscribes
     * const stockSubscribe = await prisma.stockSubscribe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockSubscribeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockSubscribeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockSubscribe.
     * @param {StockSubscribeUpsertArgs} args - Arguments to update or create a StockSubscribe.
     * @example
     * // Update or create a StockSubscribe
     * const stockSubscribe = await prisma.stockSubscribe.upsert({
     *   create: {
     *     // ... data to create a StockSubscribe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockSubscribe we want to update
     *   }
     * })
    **/
    upsert<T extends StockSubscribeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockSubscribeUpsertArgs<ExtArgs>>
    ): Prisma__StockSubscribeClient<$Result.GetResult<Prisma.$StockSubscribePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockSubscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSubscribeCountArgs} args - Arguments to filter StockSubscribes to count.
     * @example
     * // Count the number of StockSubscribes
     * const count = await prisma.stockSubscribe.count({
     *   where: {
     *     // ... the filter for the StockSubscribes we want to count
     *   }
     * })
    **/
    count<T extends StockSubscribeCountArgs>(
      args?: Subset<T, StockSubscribeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockSubscribeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockSubscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSubscribeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockSubscribeAggregateArgs>(args: Subset<T, StockSubscribeAggregateArgs>): Prisma.PrismaPromise<GetStockSubscribeAggregateType<T>>

    /**
     * Group by StockSubscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockSubscribeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockSubscribeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockSubscribeGroupByArgs['orderBy'] }
        : { orderBy?: StockSubscribeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockSubscribeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockSubscribeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockSubscribe model
   */
  readonly fields: StockSubscribeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockSubscribe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockSubscribeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockSubscribe model
   */ 
  interface StockSubscribeFieldRefs {
    readonly id: FieldRef<"StockSubscribe", 'BigInt'>
    readonly market: FieldRef<"StockSubscribe", 'String'>
    readonly name: FieldRef<"StockSubscribe", 'String'>
    readonly code: FieldRef<"StockSubscribe", 'String'>
    readonly startAt: FieldRef<"StockSubscribe", 'DateTime'>
    readonly endAt: FieldRef<"StockSubscribe", 'DateTime'>
    readonly upAt: FieldRef<"StockSubscribe", 'DateTime'>
    readonly circulation: FieldRef<"StockSubscribe", 'Int'>
    readonly remainCirculation: FieldRef<"StockSubscribe", 'Int'>
    readonly ipoPrice: FieldRef<"StockSubscribe", 'Decimal'>
    readonly issuePrice: FieldRef<"StockSubscribe", 'Decimal'>
    readonly resultAt: FieldRef<"StockSubscribe", 'DateTime'>
    readonly subAmount: FieldRef<"StockSubscribe", 'Json'>
    readonly status: FieldRef<"StockSubscribe", 'Int'>
    readonly type: FieldRef<"StockSubscribe", 'Int'>
    readonly createdAt: FieldRef<"StockSubscribe", 'DateTime'>
    readonly updatedAt: FieldRef<"StockSubscribe", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StockSubscribe findUnique
   */
  export type StockSubscribeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
    /**
     * Filter, which StockSubscribe to fetch.
     */
    where: StockSubscribeWhereUniqueInput
  }


  /**
   * StockSubscribe findUniqueOrThrow
   */
  export type StockSubscribeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
    /**
     * Filter, which StockSubscribe to fetch.
     */
    where: StockSubscribeWhereUniqueInput
  }


  /**
   * StockSubscribe findFirst
   */
  export type StockSubscribeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
    /**
     * Filter, which StockSubscribe to fetch.
     */
    where?: StockSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockSubscribes to fetch.
     */
    orderBy?: StockSubscribeOrderByWithRelationInput | StockSubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockSubscribes.
     */
    cursor?: StockSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockSubscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockSubscribes.
     */
    distinct?: StockSubscribeScalarFieldEnum | StockSubscribeScalarFieldEnum[]
  }


  /**
   * StockSubscribe findFirstOrThrow
   */
  export type StockSubscribeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
    /**
     * Filter, which StockSubscribe to fetch.
     */
    where?: StockSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockSubscribes to fetch.
     */
    orderBy?: StockSubscribeOrderByWithRelationInput | StockSubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockSubscribes.
     */
    cursor?: StockSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockSubscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockSubscribes.
     */
    distinct?: StockSubscribeScalarFieldEnum | StockSubscribeScalarFieldEnum[]
  }


  /**
   * StockSubscribe findMany
   */
  export type StockSubscribeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
    /**
     * Filter, which StockSubscribes to fetch.
     */
    where?: StockSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockSubscribes to fetch.
     */
    orderBy?: StockSubscribeOrderByWithRelationInput | StockSubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockSubscribes.
     */
    cursor?: StockSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockSubscribes.
     */
    skip?: number
    distinct?: StockSubscribeScalarFieldEnum | StockSubscribeScalarFieldEnum[]
  }


  /**
   * StockSubscribe create
   */
  export type StockSubscribeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
    /**
     * The data needed to create a StockSubscribe.
     */
    data: XOR<StockSubscribeCreateInput, StockSubscribeUncheckedCreateInput>
  }


  /**
   * StockSubscribe createMany
   */
  export type StockSubscribeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockSubscribes.
     */
    data: StockSubscribeCreateManyInput | StockSubscribeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockSubscribe update
   */
  export type StockSubscribeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
    /**
     * The data needed to update a StockSubscribe.
     */
    data: XOR<StockSubscribeUpdateInput, StockSubscribeUncheckedUpdateInput>
    /**
     * Choose, which StockSubscribe to update.
     */
    where: StockSubscribeWhereUniqueInput
  }


  /**
   * StockSubscribe updateMany
   */
  export type StockSubscribeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockSubscribes.
     */
    data: XOR<StockSubscribeUpdateManyMutationInput, StockSubscribeUncheckedUpdateManyInput>
    /**
     * Filter which StockSubscribes to update
     */
    where?: StockSubscribeWhereInput
  }


  /**
   * StockSubscribe upsert
   */
  export type StockSubscribeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
    /**
     * The filter to search for the StockSubscribe to update in case it exists.
     */
    where: StockSubscribeWhereUniqueInput
    /**
     * In case the StockSubscribe found by the `where` argument doesn't exist, create a new StockSubscribe with this data.
     */
    create: XOR<StockSubscribeCreateInput, StockSubscribeUncheckedCreateInput>
    /**
     * In case the StockSubscribe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockSubscribeUpdateInput, StockSubscribeUncheckedUpdateInput>
  }


  /**
   * StockSubscribe delete
   */
  export type StockSubscribeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
    /**
     * Filter which StockSubscribe to delete.
     */
    where: StockSubscribeWhereUniqueInput
  }


  /**
   * StockSubscribe deleteMany
   */
  export type StockSubscribeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockSubscribes to delete
     */
    where?: StockSubscribeWhereInput
  }


  /**
   * StockSubscribe without action
   */
  export type StockSubscribeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockSubscribe
     */
    select?: StockSubscribeSelect<ExtArgs> | null
  }



  /**
   * Model MemberSubscribe
   */

  export type AggregateMemberSubscribe = {
    _count: MemberSubscribeCountAggregateOutputType | null
    _avg: MemberSubscribeAvgAggregateOutputType | null
    _sum: MemberSubscribeSumAggregateOutputType | null
    _min: MemberSubscribeMinAggregateOutputType | null
    _max: MemberSubscribeMaxAggregateOutputType | null
  }

  export type MemberSubscribeAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    money: Decimal | null
    winningAmount: number | null
    winningPrice: Decimal | null
    totalWinningPrice: Decimal | null
    actualAmount: Decimal | null
    status: number | null
    type: number | null
    position: number | null
    stockSubscribeId: number | null
    memberId: number | null
  }

  export type MemberSubscribeSumAggregateOutputType = {
    id: bigint | null
    amount: number | null
    money: Decimal | null
    winningAmount: number | null
    winningPrice: Decimal | null
    totalWinningPrice: Decimal | null
    actualAmount: Decimal | null
    status: number | null
    type: number | null
    position: number | null
    stockSubscribeId: bigint | null
    memberId: bigint | null
  }

  export type MemberSubscribeMinAggregateOutputType = {
    id: bigint | null
    market: string | null
    code: string | null
    name: string | null
    amount: number | null
    money: Decimal | null
    no: string | null
    winningAmount: number | null
    winningPrice: Decimal | null
    totalWinningPrice: Decimal | null
    actualAmount: Decimal | null
    status: number | null
    type: number | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    stockSubscribeId: bigint | null
    memberId: bigint | null
  }

  export type MemberSubscribeMaxAggregateOutputType = {
    id: bigint | null
    market: string | null
    code: string | null
    name: string | null
    amount: number | null
    money: Decimal | null
    no: string | null
    winningAmount: number | null
    winningPrice: Decimal | null
    totalWinningPrice: Decimal | null
    actualAmount: Decimal | null
    status: number | null
    type: number | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    stockSubscribeId: bigint | null
    memberId: bigint | null
  }

  export type MemberSubscribeCountAggregateOutputType = {
    id: number
    market: number
    code: number
    name: number
    amount: number
    money: number
    no: number
    winningAmount: number
    winningPrice: number
    totalWinningPrice: number
    actualAmount: number
    status: number
    type: number
    position: number
    createdAt: number
    updatedAt: number
    stockSubscribeId: number
    memberId: number
    _all: number
  }


  export type MemberSubscribeAvgAggregateInputType = {
    id?: true
    amount?: true
    money?: true
    winningAmount?: true
    winningPrice?: true
    totalWinningPrice?: true
    actualAmount?: true
    status?: true
    type?: true
    position?: true
    stockSubscribeId?: true
    memberId?: true
  }

  export type MemberSubscribeSumAggregateInputType = {
    id?: true
    amount?: true
    money?: true
    winningAmount?: true
    winningPrice?: true
    totalWinningPrice?: true
    actualAmount?: true
    status?: true
    type?: true
    position?: true
    stockSubscribeId?: true
    memberId?: true
  }

  export type MemberSubscribeMinAggregateInputType = {
    id?: true
    market?: true
    code?: true
    name?: true
    amount?: true
    money?: true
    no?: true
    winningAmount?: true
    winningPrice?: true
    totalWinningPrice?: true
    actualAmount?: true
    status?: true
    type?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    stockSubscribeId?: true
    memberId?: true
  }

  export type MemberSubscribeMaxAggregateInputType = {
    id?: true
    market?: true
    code?: true
    name?: true
    amount?: true
    money?: true
    no?: true
    winningAmount?: true
    winningPrice?: true
    totalWinningPrice?: true
    actualAmount?: true
    status?: true
    type?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    stockSubscribeId?: true
    memberId?: true
  }

  export type MemberSubscribeCountAggregateInputType = {
    id?: true
    market?: true
    code?: true
    name?: true
    amount?: true
    money?: true
    no?: true
    winningAmount?: true
    winningPrice?: true
    totalWinningPrice?: true
    actualAmount?: true
    status?: true
    type?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    stockSubscribeId?: true
    memberId?: true
    _all?: true
  }

  export type MemberSubscribeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberSubscribe to aggregate.
     */
    where?: MemberSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberSubscribes to fetch.
     */
    orderBy?: MemberSubscribeOrderByWithRelationInput | MemberSubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberSubscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberSubscribes
    **/
    _count?: true | MemberSubscribeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberSubscribeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSubscribeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberSubscribeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberSubscribeMaxAggregateInputType
  }

  export type GetMemberSubscribeAggregateType<T extends MemberSubscribeAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberSubscribe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberSubscribe[P]>
      : GetScalarType<T[P], AggregateMemberSubscribe[P]>
  }




  export type MemberSubscribeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberSubscribeWhereInput
    orderBy?: MemberSubscribeOrderByWithAggregationInput | MemberSubscribeOrderByWithAggregationInput[]
    by: MemberSubscribeScalarFieldEnum[] | MemberSubscribeScalarFieldEnum
    having?: MemberSubscribeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberSubscribeCountAggregateInputType | true
    _avg?: MemberSubscribeAvgAggregateInputType
    _sum?: MemberSubscribeSumAggregateInputType
    _min?: MemberSubscribeMinAggregateInputType
    _max?: MemberSubscribeMaxAggregateInputType
  }

  export type MemberSubscribeGroupByOutputType = {
    id: bigint
    market: string
    code: string
    name: string
    amount: number
    money: Decimal
    no: string
    winningAmount: number | null
    winningPrice: Decimal | null
    totalWinningPrice: Decimal | null
    actualAmount: Decimal | null
    status: number
    type: number
    position: number
    createdAt: Date
    updatedAt: Date | null
    stockSubscribeId: bigint
    memberId: bigint
    _count: MemberSubscribeCountAggregateOutputType | null
    _avg: MemberSubscribeAvgAggregateOutputType | null
    _sum: MemberSubscribeSumAggregateOutputType | null
    _min: MemberSubscribeMinAggregateOutputType | null
    _max: MemberSubscribeMaxAggregateOutputType | null
  }

  type GetMemberSubscribeGroupByPayload<T extends MemberSubscribeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberSubscribeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberSubscribeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberSubscribeGroupByOutputType[P]>
            : GetScalarType<T[P], MemberSubscribeGroupByOutputType[P]>
        }
      >
    >


  export type MemberSubscribeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    market?: boolean
    code?: boolean
    name?: boolean
    amount?: boolean
    money?: boolean
    no?: boolean
    winningAmount?: boolean
    winningPrice?: boolean
    totalWinningPrice?: boolean
    actualAmount?: boolean
    status?: boolean
    type?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockSubscribeId?: boolean
    memberId?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberSubscribe"]>

  export type MemberSubscribeSelectScalar = {
    id?: boolean
    market?: boolean
    code?: boolean
    name?: boolean
    amount?: boolean
    money?: boolean
    no?: boolean
    winningAmount?: boolean
    winningPrice?: boolean
    totalWinningPrice?: boolean
    actualAmount?: boolean
    status?: boolean
    type?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockSubscribeId?: boolean
    memberId?: boolean
  }

  export type MemberSubscribeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }


  export type $MemberSubscribePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberSubscribe"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      market: string
      code: string
      name: string
      amount: number
      money: Prisma.Decimal
      no: string
      winningAmount: number | null
      winningPrice: Prisma.Decimal | null
      totalWinningPrice: Prisma.Decimal | null
      actualAmount: Prisma.Decimal | null
      status: number
      type: number
      position: number
      createdAt: Date
      updatedAt: Date | null
      stockSubscribeId: bigint
      memberId: bigint
    }, ExtArgs["result"]["memberSubscribe"]>
    composites: {}
  }


  type MemberSubscribeGetPayload<S extends boolean | null | undefined | MemberSubscribeDefaultArgs> = $Result.GetResult<Prisma.$MemberSubscribePayload, S>

  type MemberSubscribeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberSubscribeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberSubscribeCountAggregateInputType | true
    }

  export interface MemberSubscribeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberSubscribe'], meta: { name: 'MemberSubscribe' } }
    /**
     * Find zero or one MemberSubscribe that matches the filter.
     * @param {MemberSubscribeFindUniqueArgs} args - Arguments to find a MemberSubscribe
     * @example
     * // Get one MemberSubscribe
     * const memberSubscribe = await prisma.memberSubscribe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberSubscribeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MemberSubscribeFindUniqueArgs<ExtArgs>>
    ): Prisma__MemberSubscribeClient<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MemberSubscribe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MemberSubscribeFindUniqueOrThrowArgs} args - Arguments to find a MemberSubscribe
     * @example
     * // Get one MemberSubscribe
     * const memberSubscribe = await prisma.memberSubscribe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MemberSubscribeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberSubscribeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MemberSubscribeClient<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MemberSubscribe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSubscribeFindFirstArgs} args - Arguments to find a MemberSubscribe
     * @example
     * // Get one MemberSubscribe
     * const memberSubscribe = await prisma.memberSubscribe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberSubscribeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberSubscribeFindFirstArgs<ExtArgs>>
    ): Prisma__MemberSubscribeClient<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MemberSubscribe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSubscribeFindFirstOrThrowArgs} args - Arguments to find a MemberSubscribe
     * @example
     * // Get one MemberSubscribe
     * const memberSubscribe = await prisma.memberSubscribe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MemberSubscribeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberSubscribeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MemberSubscribeClient<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MemberSubscribes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSubscribeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberSubscribes
     * const memberSubscribes = await prisma.memberSubscribe.findMany()
     * 
     * // Get first 10 MemberSubscribes
     * const memberSubscribes = await prisma.memberSubscribe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberSubscribeWithIdOnly = await prisma.memberSubscribe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MemberSubscribeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberSubscribeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MemberSubscribe.
     * @param {MemberSubscribeCreateArgs} args - Arguments to create a MemberSubscribe.
     * @example
     * // Create one MemberSubscribe
     * const MemberSubscribe = await prisma.memberSubscribe.create({
     *   data: {
     *     // ... data to create a MemberSubscribe
     *   }
     * })
     * 
    **/
    create<T extends MemberSubscribeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberSubscribeCreateArgs<ExtArgs>>
    ): Prisma__MemberSubscribeClient<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MemberSubscribes.
     *     @param {MemberSubscribeCreateManyArgs} args - Arguments to create many MemberSubscribes.
     *     @example
     *     // Create many MemberSubscribes
     *     const memberSubscribe = await prisma.memberSubscribe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberSubscribeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberSubscribeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MemberSubscribe.
     * @param {MemberSubscribeDeleteArgs} args - Arguments to delete one MemberSubscribe.
     * @example
     * // Delete one MemberSubscribe
     * const MemberSubscribe = await prisma.memberSubscribe.delete({
     *   where: {
     *     // ... filter to delete one MemberSubscribe
     *   }
     * })
     * 
    **/
    delete<T extends MemberSubscribeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MemberSubscribeDeleteArgs<ExtArgs>>
    ): Prisma__MemberSubscribeClient<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MemberSubscribe.
     * @param {MemberSubscribeUpdateArgs} args - Arguments to update one MemberSubscribe.
     * @example
     * // Update one MemberSubscribe
     * const memberSubscribe = await prisma.memberSubscribe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberSubscribeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberSubscribeUpdateArgs<ExtArgs>>
    ): Prisma__MemberSubscribeClient<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MemberSubscribes.
     * @param {MemberSubscribeDeleteManyArgs} args - Arguments to filter MemberSubscribes to delete.
     * @example
     * // Delete a few MemberSubscribes
     * const { count } = await prisma.memberSubscribe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberSubscribeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberSubscribeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberSubscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSubscribeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberSubscribes
     * const memberSubscribe = await prisma.memberSubscribe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberSubscribeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MemberSubscribeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MemberSubscribe.
     * @param {MemberSubscribeUpsertArgs} args - Arguments to update or create a MemberSubscribe.
     * @example
     * // Update or create a MemberSubscribe
     * const memberSubscribe = await prisma.memberSubscribe.upsert({
     *   create: {
     *     // ... data to create a MemberSubscribe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberSubscribe we want to update
     *   }
     * })
    **/
    upsert<T extends MemberSubscribeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MemberSubscribeUpsertArgs<ExtArgs>>
    ): Prisma__MemberSubscribeClient<$Result.GetResult<Prisma.$MemberSubscribePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MemberSubscribes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSubscribeCountArgs} args - Arguments to filter MemberSubscribes to count.
     * @example
     * // Count the number of MemberSubscribes
     * const count = await prisma.memberSubscribe.count({
     *   where: {
     *     // ... the filter for the MemberSubscribes we want to count
     *   }
     * })
    **/
    count<T extends MemberSubscribeCountArgs>(
      args?: Subset<T, MemberSubscribeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberSubscribeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberSubscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSubscribeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberSubscribeAggregateArgs>(args: Subset<T, MemberSubscribeAggregateArgs>): Prisma.PrismaPromise<GetMemberSubscribeAggregateType<T>>

    /**
     * Group by MemberSubscribe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberSubscribeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberSubscribeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberSubscribeGroupByArgs['orderBy'] }
        : { orderBy?: MemberSubscribeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberSubscribeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberSubscribeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberSubscribe model
   */
  readonly fields: MemberSubscribeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberSubscribe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberSubscribeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MemberSubscribe model
   */ 
  interface MemberSubscribeFieldRefs {
    readonly id: FieldRef<"MemberSubscribe", 'BigInt'>
    readonly market: FieldRef<"MemberSubscribe", 'String'>
    readonly code: FieldRef<"MemberSubscribe", 'String'>
    readonly name: FieldRef<"MemberSubscribe", 'String'>
    readonly amount: FieldRef<"MemberSubscribe", 'Int'>
    readonly money: FieldRef<"MemberSubscribe", 'Decimal'>
    readonly no: FieldRef<"MemberSubscribe", 'String'>
    readonly winningAmount: FieldRef<"MemberSubscribe", 'Int'>
    readonly winningPrice: FieldRef<"MemberSubscribe", 'Decimal'>
    readonly totalWinningPrice: FieldRef<"MemberSubscribe", 'Decimal'>
    readonly actualAmount: FieldRef<"MemberSubscribe", 'Decimal'>
    readonly status: FieldRef<"MemberSubscribe", 'Int'>
    readonly type: FieldRef<"MemberSubscribe", 'Int'>
    readonly position: FieldRef<"MemberSubscribe", 'Int'>
    readonly createdAt: FieldRef<"MemberSubscribe", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberSubscribe", 'DateTime'>
    readonly stockSubscribeId: FieldRef<"MemberSubscribe", 'BigInt'>
    readonly memberId: FieldRef<"MemberSubscribe", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * MemberSubscribe findUnique
   */
  export type MemberSubscribeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    /**
     * Filter, which MemberSubscribe to fetch.
     */
    where: MemberSubscribeWhereUniqueInput
  }


  /**
   * MemberSubscribe findUniqueOrThrow
   */
  export type MemberSubscribeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    /**
     * Filter, which MemberSubscribe to fetch.
     */
    where: MemberSubscribeWhereUniqueInput
  }


  /**
   * MemberSubscribe findFirst
   */
  export type MemberSubscribeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    /**
     * Filter, which MemberSubscribe to fetch.
     */
    where?: MemberSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberSubscribes to fetch.
     */
    orderBy?: MemberSubscribeOrderByWithRelationInput | MemberSubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberSubscribes.
     */
    cursor?: MemberSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberSubscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberSubscribes.
     */
    distinct?: MemberSubscribeScalarFieldEnum | MemberSubscribeScalarFieldEnum[]
  }


  /**
   * MemberSubscribe findFirstOrThrow
   */
  export type MemberSubscribeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    /**
     * Filter, which MemberSubscribe to fetch.
     */
    where?: MemberSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberSubscribes to fetch.
     */
    orderBy?: MemberSubscribeOrderByWithRelationInput | MemberSubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberSubscribes.
     */
    cursor?: MemberSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberSubscribes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberSubscribes.
     */
    distinct?: MemberSubscribeScalarFieldEnum | MemberSubscribeScalarFieldEnum[]
  }


  /**
   * MemberSubscribe findMany
   */
  export type MemberSubscribeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    /**
     * Filter, which MemberSubscribes to fetch.
     */
    where?: MemberSubscribeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberSubscribes to fetch.
     */
    orderBy?: MemberSubscribeOrderByWithRelationInput | MemberSubscribeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberSubscribes.
     */
    cursor?: MemberSubscribeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberSubscribes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberSubscribes.
     */
    skip?: number
    distinct?: MemberSubscribeScalarFieldEnum | MemberSubscribeScalarFieldEnum[]
  }


  /**
   * MemberSubscribe create
   */
  export type MemberSubscribeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberSubscribe.
     */
    data: XOR<MemberSubscribeCreateInput, MemberSubscribeUncheckedCreateInput>
  }


  /**
   * MemberSubscribe createMany
   */
  export type MemberSubscribeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberSubscribes.
     */
    data: MemberSubscribeCreateManyInput | MemberSubscribeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MemberSubscribe update
   */
  export type MemberSubscribeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberSubscribe.
     */
    data: XOR<MemberSubscribeUpdateInput, MemberSubscribeUncheckedUpdateInput>
    /**
     * Choose, which MemberSubscribe to update.
     */
    where: MemberSubscribeWhereUniqueInput
  }


  /**
   * MemberSubscribe updateMany
   */
  export type MemberSubscribeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberSubscribes.
     */
    data: XOR<MemberSubscribeUpdateManyMutationInput, MemberSubscribeUncheckedUpdateManyInput>
    /**
     * Filter which MemberSubscribes to update
     */
    where?: MemberSubscribeWhereInput
  }


  /**
   * MemberSubscribe upsert
   */
  export type MemberSubscribeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberSubscribe to update in case it exists.
     */
    where: MemberSubscribeWhereUniqueInput
    /**
     * In case the MemberSubscribe found by the `where` argument doesn't exist, create a new MemberSubscribe with this data.
     */
    create: XOR<MemberSubscribeCreateInput, MemberSubscribeUncheckedCreateInput>
    /**
     * In case the MemberSubscribe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberSubscribeUpdateInput, MemberSubscribeUncheckedUpdateInput>
  }


  /**
   * MemberSubscribe delete
   */
  export type MemberSubscribeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
    /**
     * Filter which MemberSubscribe to delete.
     */
    where: MemberSubscribeWhereUniqueInput
  }


  /**
   * MemberSubscribe deleteMany
   */
  export type MemberSubscribeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberSubscribes to delete
     */
    where?: MemberSubscribeWhereInput
  }


  /**
   * MemberSubscribe without action
   */
  export type MemberSubscribeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberSubscribe
     */
    select?: MemberSubscribeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberSubscribeInclude<ExtArgs> | null
  }



  /**
   * Model StockPosition
   */

  export type AggregateStockPosition = {
    _count: StockPositionCountAggregateOutputType | null
    _avg: StockPositionAvgAggregateOutputType | null
    _sum: StockPositionSumAggregateOutputType | null
    _min: StockPositionMinAggregateOutputType | null
    _max: StockPositionMaxAggregateOutputType | null
  }

  export type StockPositionAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    mode: number | null
    status: number | null
    type: number | null
    memberId: number | null
    stockSymbolId: number | null
  }

  export type StockPositionSumAggregateOutputType = {
    id: bigint | null
    amount: number | null
    mode: number | null
    status: number | null
    type: number | null
    memberId: bigint | null
    stockSymbolId: bigint | null
  }

  export type StockPositionMinAggregateOutputType = {
    id: bigint | null
    amount: number | null
    blast: string | null
    price: string | null
    mode: number | null
    status: number | null
    bond: string | null
    identifier: string | null
    lever: string | null
    stopLoss: string | null
    takeProfit: string | null
    market: string | null
    type: number | null
    pl: string | null
    rate: string | null
    isBefore: boolean | null
    currentPrice: string | null
    memberId: bigint | null
    stockSymbolId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockPositionMaxAggregateOutputType = {
    id: bigint | null
    amount: number | null
    blast: string | null
    price: string | null
    mode: number | null
    status: number | null
    bond: string | null
    identifier: string | null
    lever: string | null
    stopLoss: string | null
    takeProfit: string | null
    market: string | null
    type: number | null
    pl: string | null
    rate: string | null
    isBefore: boolean | null
    currentPrice: string | null
    memberId: bigint | null
    stockSymbolId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockPositionCountAggregateOutputType = {
    id: number
    amount: number
    blast: number
    price: number
    mode: number
    status: number
    bond: number
    identifier: number
    lever: number
    stopLoss: number
    takeProfit: number
    market: number
    type: number
    pl: number
    rate: number
    isBefore: number
    currentPrice: number
    memberId: number
    stockSymbolId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockPositionAvgAggregateInputType = {
    id?: true
    amount?: true
    mode?: true
    status?: true
    type?: true
    memberId?: true
    stockSymbolId?: true
  }

  export type StockPositionSumAggregateInputType = {
    id?: true
    amount?: true
    mode?: true
    status?: true
    type?: true
    memberId?: true
    stockSymbolId?: true
  }

  export type StockPositionMinAggregateInputType = {
    id?: true
    amount?: true
    blast?: true
    price?: true
    mode?: true
    status?: true
    bond?: true
    identifier?: true
    lever?: true
    stopLoss?: true
    takeProfit?: true
    market?: true
    type?: true
    pl?: true
    rate?: true
    isBefore?: true
    currentPrice?: true
    memberId?: true
    stockSymbolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockPositionMaxAggregateInputType = {
    id?: true
    amount?: true
    blast?: true
    price?: true
    mode?: true
    status?: true
    bond?: true
    identifier?: true
    lever?: true
    stopLoss?: true
    takeProfit?: true
    market?: true
    type?: true
    pl?: true
    rate?: true
    isBefore?: true
    currentPrice?: true
    memberId?: true
    stockSymbolId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockPositionCountAggregateInputType = {
    id?: true
    amount?: true
    blast?: true
    price?: true
    mode?: true
    status?: true
    bond?: true
    identifier?: true
    lever?: true
    stopLoss?: true
    takeProfit?: true
    market?: true
    type?: true
    pl?: true
    rate?: true
    isBefore?: true
    currentPrice?: true
    memberId?: true
    stockSymbolId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockPosition to aggregate.
     */
    where?: StockPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockPositions to fetch.
     */
    orderBy?: StockPositionOrderByWithRelationInput | StockPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockPositions
    **/
    _count?: true | StockPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockPositionMaxAggregateInputType
  }

  export type GetStockPositionAggregateType<T extends StockPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateStockPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockPosition[P]>
      : GetScalarType<T[P], AggregateStockPosition[P]>
  }




  export type StockPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockPositionWhereInput
    orderBy?: StockPositionOrderByWithAggregationInput | StockPositionOrderByWithAggregationInput[]
    by: StockPositionScalarFieldEnum[] | StockPositionScalarFieldEnum
    having?: StockPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockPositionCountAggregateInputType | true
    _avg?: StockPositionAvgAggregateInputType
    _sum?: StockPositionSumAggregateInputType
    _min?: StockPositionMinAggregateInputType
    _max?: StockPositionMaxAggregateInputType
  }

  export type StockPositionGroupByOutputType = {
    id: bigint
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond: string | null
    identifier: string | null
    lever: string | null
    stopLoss: string | null
    takeProfit: string | null
    market: string | null
    type: number
    pl: string | null
    rate: string | null
    isBefore: boolean
    currentPrice: string | null
    memberId: bigint
    stockSymbolId: bigint
    createdAt: Date
    updatedAt: Date | null
    _count: StockPositionCountAggregateOutputType | null
    _avg: StockPositionAvgAggregateOutputType | null
    _sum: StockPositionSumAggregateOutputType | null
    _min: StockPositionMinAggregateOutputType | null
    _max: StockPositionMaxAggregateOutputType | null
  }

  type GetStockPositionGroupByPayload<T extends StockPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockPositionGroupByOutputType[P]>
            : GetScalarType<T[P], StockPositionGroupByOutputType[P]>
        }
      >
    >


  export type StockPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    blast?: boolean
    price?: boolean
    mode?: boolean
    status?: boolean
    bond?: boolean
    identifier?: boolean
    lever?: boolean
    stopLoss?: boolean
    takeProfit?: boolean
    market?: boolean
    type?: boolean
    pl?: boolean
    rate?: boolean
    isBefore?: boolean
    currentPrice?: boolean
    memberId?: boolean
    stockSymbolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
    stockSymbol?: boolean | StockSymbolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockPosition"]>

  export type StockPositionSelectScalar = {
    id?: boolean
    amount?: boolean
    blast?: boolean
    price?: boolean
    mode?: boolean
    status?: boolean
    bond?: boolean
    identifier?: boolean
    lever?: boolean
    stopLoss?: boolean
    takeProfit?: boolean
    market?: boolean
    type?: boolean
    pl?: boolean
    rate?: boolean
    isBefore?: boolean
    currentPrice?: boolean
    memberId?: boolean
    stockSymbolId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockPositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
    stockSymbol?: boolean | StockSymbolDefaultArgs<ExtArgs>
  }


  export type $StockPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockPosition"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
      stockSymbol: Prisma.$StockSymbolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      amount: number
      blast: string
      price: string
      mode: number
      status: number
      bond: string | null
      identifier: string | null
      lever: string | null
      stopLoss: string | null
      takeProfit: string | null
      market: string | null
      type: number
      pl: string | null
      rate: string | null
      isBefore: boolean
      currentPrice: string | null
      memberId: bigint
      stockSymbolId: bigint
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["stockPosition"]>
    composites: {}
  }


  type StockPositionGetPayload<S extends boolean | null | undefined | StockPositionDefaultArgs> = $Result.GetResult<Prisma.$StockPositionPayload, S>

  type StockPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockPositionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockPositionCountAggregateInputType | true
    }

  export interface StockPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockPosition'], meta: { name: 'StockPosition' } }
    /**
     * Find zero or one StockPosition that matches the filter.
     * @param {StockPositionFindUniqueArgs} args - Arguments to find a StockPosition
     * @example
     * // Get one StockPosition
     * const stockPosition = await prisma.stockPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockPositionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockPositionFindUniqueArgs<ExtArgs>>
    ): Prisma__StockPositionClient<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockPosition that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockPositionFindUniqueOrThrowArgs} args - Arguments to find a StockPosition
     * @example
     * // Get one StockPosition
     * const stockPosition = await prisma.stockPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockPositionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockPositionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockPositionClient<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockPositionFindFirstArgs} args - Arguments to find a StockPosition
     * @example
     * // Get one StockPosition
     * const stockPosition = await prisma.stockPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockPositionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockPositionFindFirstArgs<ExtArgs>>
    ): Prisma__StockPositionClient<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockPositionFindFirstOrThrowArgs} args - Arguments to find a StockPosition
     * @example
     * // Get one StockPosition
     * const stockPosition = await prisma.stockPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockPositionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockPositionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockPositionClient<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockPositionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockPositions
     * const stockPositions = await prisma.stockPosition.findMany()
     * 
     * // Get first 10 StockPositions
     * const stockPositions = await prisma.stockPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockPositionWithIdOnly = await prisma.stockPosition.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockPositionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockPositionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockPosition.
     * @param {StockPositionCreateArgs} args - Arguments to create a StockPosition.
     * @example
     * // Create one StockPosition
     * const StockPosition = await prisma.stockPosition.create({
     *   data: {
     *     // ... data to create a StockPosition
     *   }
     * })
     * 
    **/
    create<T extends StockPositionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockPositionCreateArgs<ExtArgs>>
    ): Prisma__StockPositionClient<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockPositions.
     *     @param {StockPositionCreateManyArgs} args - Arguments to create many StockPositions.
     *     @example
     *     // Create many StockPositions
     *     const stockPosition = await prisma.stockPosition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockPositionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockPositionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockPosition.
     * @param {StockPositionDeleteArgs} args - Arguments to delete one StockPosition.
     * @example
     * // Delete one StockPosition
     * const StockPosition = await prisma.stockPosition.delete({
     *   where: {
     *     // ... filter to delete one StockPosition
     *   }
     * })
     * 
    **/
    delete<T extends StockPositionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockPositionDeleteArgs<ExtArgs>>
    ): Prisma__StockPositionClient<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockPosition.
     * @param {StockPositionUpdateArgs} args - Arguments to update one StockPosition.
     * @example
     * // Update one StockPosition
     * const stockPosition = await prisma.stockPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockPositionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockPositionUpdateArgs<ExtArgs>>
    ): Prisma__StockPositionClient<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockPositions.
     * @param {StockPositionDeleteManyArgs} args - Arguments to filter StockPositions to delete.
     * @example
     * // Delete a few StockPositions
     * const { count } = await prisma.stockPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockPositionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockPositionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockPositions
     * const stockPosition = await prisma.stockPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockPositionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockPositionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockPosition.
     * @param {StockPositionUpsertArgs} args - Arguments to update or create a StockPosition.
     * @example
     * // Update or create a StockPosition
     * const stockPosition = await prisma.stockPosition.upsert({
     *   create: {
     *     // ... data to create a StockPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockPosition we want to update
     *   }
     * })
    **/
    upsert<T extends StockPositionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockPositionUpsertArgs<ExtArgs>>
    ): Prisma__StockPositionClient<$Result.GetResult<Prisma.$StockPositionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockPositionCountArgs} args - Arguments to filter StockPositions to count.
     * @example
     * // Count the number of StockPositions
     * const count = await prisma.stockPosition.count({
     *   where: {
     *     // ... the filter for the StockPositions we want to count
     *   }
     * })
    **/
    count<T extends StockPositionCountArgs>(
      args?: Subset<T, StockPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockPositionAggregateArgs>(args: Subset<T, StockPositionAggregateArgs>): Prisma.PrismaPromise<GetStockPositionAggregateType<T>>

    /**
     * Group by StockPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockPositionGroupByArgs['orderBy'] }
        : { orderBy?: StockPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockPosition model
   */
  readonly fields: StockPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    stockSymbol<T extends StockSymbolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockSymbolDefaultArgs<ExtArgs>>): Prisma__StockSymbolClient<$Result.GetResult<Prisma.$StockSymbolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockPosition model
   */ 
  interface StockPositionFieldRefs {
    readonly id: FieldRef<"StockPosition", 'BigInt'>
    readonly amount: FieldRef<"StockPosition", 'Int'>
    readonly blast: FieldRef<"StockPosition", 'String'>
    readonly price: FieldRef<"StockPosition", 'String'>
    readonly mode: FieldRef<"StockPosition", 'Int'>
    readonly status: FieldRef<"StockPosition", 'Int'>
    readonly bond: FieldRef<"StockPosition", 'String'>
    readonly identifier: FieldRef<"StockPosition", 'String'>
    readonly lever: FieldRef<"StockPosition", 'String'>
    readonly stopLoss: FieldRef<"StockPosition", 'String'>
    readonly takeProfit: FieldRef<"StockPosition", 'String'>
    readonly market: FieldRef<"StockPosition", 'String'>
    readonly type: FieldRef<"StockPosition", 'Int'>
    readonly pl: FieldRef<"StockPosition", 'String'>
    readonly rate: FieldRef<"StockPosition", 'String'>
    readonly isBefore: FieldRef<"StockPosition", 'Boolean'>
    readonly currentPrice: FieldRef<"StockPosition", 'String'>
    readonly memberId: FieldRef<"StockPosition", 'BigInt'>
    readonly stockSymbolId: FieldRef<"StockPosition", 'BigInt'>
    readonly createdAt: FieldRef<"StockPosition", 'DateTime'>
    readonly updatedAt: FieldRef<"StockPosition", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StockPosition findUnique
   */
  export type StockPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    /**
     * Filter, which StockPosition to fetch.
     */
    where: StockPositionWhereUniqueInput
  }


  /**
   * StockPosition findUniqueOrThrow
   */
  export type StockPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    /**
     * Filter, which StockPosition to fetch.
     */
    where: StockPositionWhereUniqueInput
  }


  /**
   * StockPosition findFirst
   */
  export type StockPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    /**
     * Filter, which StockPosition to fetch.
     */
    where?: StockPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockPositions to fetch.
     */
    orderBy?: StockPositionOrderByWithRelationInput | StockPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockPositions.
     */
    cursor?: StockPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockPositions.
     */
    distinct?: StockPositionScalarFieldEnum | StockPositionScalarFieldEnum[]
  }


  /**
   * StockPosition findFirstOrThrow
   */
  export type StockPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    /**
     * Filter, which StockPosition to fetch.
     */
    where?: StockPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockPositions to fetch.
     */
    orderBy?: StockPositionOrderByWithRelationInput | StockPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockPositions.
     */
    cursor?: StockPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockPositions.
     */
    distinct?: StockPositionScalarFieldEnum | StockPositionScalarFieldEnum[]
  }


  /**
   * StockPosition findMany
   */
  export type StockPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    /**
     * Filter, which StockPositions to fetch.
     */
    where?: StockPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockPositions to fetch.
     */
    orderBy?: StockPositionOrderByWithRelationInput | StockPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockPositions.
     */
    cursor?: StockPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockPositions.
     */
    skip?: number
    distinct?: StockPositionScalarFieldEnum | StockPositionScalarFieldEnum[]
  }


  /**
   * StockPosition create
   */
  export type StockPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    /**
     * The data needed to create a StockPosition.
     */
    data: XOR<StockPositionCreateInput, StockPositionUncheckedCreateInput>
  }


  /**
   * StockPosition createMany
   */
  export type StockPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockPositions.
     */
    data: StockPositionCreateManyInput | StockPositionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockPosition update
   */
  export type StockPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    /**
     * The data needed to update a StockPosition.
     */
    data: XOR<StockPositionUpdateInput, StockPositionUncheckedUpdateInput>
    /**
     * Choose, which StockPosition to update.
     */
    where: StockPositionWhereUniqueInput
  }


  /**
   * StockPosition updateMany
   */
  export type StockPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockPositions.
     */
    data: XOR<StockPositionUpdateManyMutationInput, StockPositionUncheckedUpdateManyInput>
    /**
     * Filter which StockPositions to update
     */
    where?: StockPositionWhereInput
  }


  /**
   * StockPosition upsert
   */
  export type StockPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    /**
     * The filter to search for the StockPosition to update in case it exists.
     */
    where: StockPositionWhereUniqueInput
    /**
     * In case the StockPosition found by the `where` argument doesn't exist, create a new StockPosition with this data.
     */
    create: XOR<StockPositionCreateInput, StockPositionUncheckedCreateInput>
    /**
     * In case the StockPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockPositionUpdateInput, StockPositionUncheckedUpdateInput>
  }


  /**
   * StockPosition delete
   */
  export type StockPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
    /**
     * Filter which StockPosition to delete.
     */
    where: StockPositionWhereUniqueInput
  }


  /**
   * StockPosition deleteMany
   */
  export type StockPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockPositions to delete
     */
    where?: StockPositionWhereInput
  }


  /**
   * StockPosition without action
   */
  export type StockPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockPosition
     */
    select?: StockPositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StockPositionInclude<ExtArgs> | null
  }



  /**
   * Model MemberDetail
   */

  export type AggregateMemberDetail = {
    _count: MemberDetailCountAggregateOutputType | null
    _avg: MemberDetailAvgAggregateOutputType | null
    _sum: MemberDetailSumAggregateOutputType | null
    _min: MemberDetailMinAggregateOutputType | null
    _max: MemberDetailMaxAggregateOutputType | null
  }

  export type MemberDetailAvgAggregateOutputType = {
    id: number | null
    type: number | null
    memberId: number | null
  }

  export type MemberDetailSumAggregateOutputType = {
    id: bigint | null
    type: number | null
    memberId: bigint | null
  }

  export type MemberDetailMinAggregateOutputType = {
    id: bigint | null
    after: string | null
    amount: string | null
    before: string | null
    market: string | null
    type: number | null
    remark: string | null
    memberId: bigint | null
  }

  export type MemberDetailMaxAggregateOutputType = {
    id: bigint | null
    after: string | null
    amount: string | null
    before: string | null
    market: string | null
    type: number | null
    remark: string | null
    memberId: bigint | null
  }

  export type MemberDetailCountAggregateOutputType = {
    id: number
    after: number
    amount: number
    before: number
    market: number
    type: number
    remark: number
    memberId: number
    _all: number
  }


  export type MemberDetailAvgAggregateInputType = {
    id?: true
    type?: true
    memberId?: true
  }

  export type MemberDetailSumAggregateInputType = {
    id?: true
    type?: true
    memberId?: true
  }

  export type MemberDetailMinAggregateInputType = {
    id?: true
    after?: true
    amount?: true
    before?: true
    market?: true
    type?: true
    remark?: true
    memberId?: true
  }

  export type MemberDetailMaxAggregateInputType = {
    id?: true
    after?: true
    amount?: true
    before?: true
    market?: true
    type?: true
    remark?: true
    memberId?: true
  }

  export type MemberDetailCountAggregateInputType = {
    id?: true
    after?: true
    amount?: true
    before?: true
    market?: true
    type?: true
    remark?: true
    memberId?: true
    _all?: true
  }

  export type MemberDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberDetail to aggregate.
     */
    where?: MemberDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberDetails to fetch.
     */
    orderBy?: MemberDetailOrderByWithRelationInput | MemberDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberDetails
    **/
    _count?: true | MemberDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberDetailMaxAggregateInputType
  }

  export type GetMemberDetailAggregateType<T extends MemberDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberDetail[P]>
      : GetScalarType<T[P], AggregateMemberDetail[P]>
  }




  export type MemberDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberDetailWhereInput
    orderBy?: MemberDetailOrderByWithAggregationInput | MemberDetailOrderByWithAggregationInput[]
    by: MemberDetailScalarFieldEnum[] | MemberDetailScalarFieldEnum
    having?: MemberDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberDetailCountAggregateInputType | true
    _avg?: MemberDetailAvgAggregateInputType
    _sum?: MemberDetailSumAggregateInputType
    _min?: MemberDetailMinAggregateInputType
    _max?: MemberDetailMaxAggregateInputType
  }

  export type MemberDetailGroupByOutputType = {
    id: bigint
    after: string | null
    amount: string | null
    before: string | null
    market: string | null
    type: number
    remark: string | null
    memberId: bigint
    _count: MemberDetailCountAggregateOutputType | null
    _avg: MemberDetailAvgAggregateOutputType | null
    _sum: MemberDetailSumAggregateOutputType | null
    _min: MemberDetailMinAggregateOutputType | null
    _max: MemberDetailMaxAggregateOutputType | null
  }

  type GetMemberDetailGroupByPayload<T extends MemberDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberDetailGroupByOutputType[P]>
            : GetScalarType<T[P], MemberDetailGroupByOutputType[P]>
        }
      >
    >


  export type MemberDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    after?: boolean
    amount?: boolean
    before?: boolean
    market?: boolean
    type?: boolean
    remark?: boolean
    memberId?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberDetail"]>

  export type MemberDetailSelectScalar = {
    id?: boolean
    after?: boolean
    amount?: boolean
    before?: boolean
    market?: boolean
    type?: boolean
    remark?: boolean
    memberId?: boolean
  }

  export type MemberDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }


  export type $MemberDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberDetail"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      after: string | null
      amount: string | null
      before: string | null
      market: string | null
      type: number
      remark: string | null
      memberId: bigint
    }, ExtArgs["result"]["memberDetail"]>
    composites: {}
  }


  type MemberDetailGetPayload<S extends boolean | null | undefined | MemberDetailDefaultArgs> = $Result.GetResult<Prisma.$MemberDetailPayload, S>

  type MemberDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberDetailCountAggregateInputType | true
    }

  export interface MemberDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberDetail'], meta: { name: 'MemberDetail' } }
    /**
     * Find zero or one MemberDetail that matches the filter.
     * @param {MemberDetailFindUniqueArgs} args - Arguments to find a MemberDetail
     * @example
     * // Get one MemberDetail
     * const memberDetail = await prisma.memberDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberDetailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MemberDetailFindUniqueArgs<ExtArgs>>
    ): Prisma__MemberDetailClient<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MemberDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MemberDetailFindUniqueOrThrowArgs} args - Arguments to find a MemberDetail
     * @example
     * // Get one MemberDetail
     * const memberDetail = await prisma.memberDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MemberDetailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberDetailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MemberDetailClient<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MemberDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberDetailFindFirstArgs} args - Arguments to find a MemberDetail
     * @example
     * // Get one MemberDetail
     * const memberDetail = await prisma.memberDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberDetailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberDetailFindFirstArgs<ExtArgs>>
    ): Prisma__MemberDetailClient<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MemberDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberDetailFindFirstOrThrowArgs} args - Arguments to find a MemberDetail
     * @example
     * // Get one MemberDetail
     * const memberDetail = await prisma.memberDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MemberDetailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberDetailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MemberDetailClient<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MemberDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberDetails
     * const memberDetails = await prisma.memberDetail.findMany()
     * 
     * // Get first 10 MemberDetails
     * const memberDetails = await prisma.memberDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberDetailWithIdOnly = await prisma.memberDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MemberDetailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberDetailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MemberDetail.
     * @param {MemberDetailCreateArgs} args - Arguments to create a MemberDetail.
     * @example
     * // Create one MemberDetail
     * const MemberDetail = await prisma.memberDetail.create({
     *   data: {
     *     // ... data to create a MemberDetail
     *   }
     * })
     * 
    **/
    create<T extends MemberDetailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberDetailCreateArgs<ExtArgs>>
    ): Prisma__MemberDetailClient<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MemberDetails.
     *     @param {MemberDetailCreateManyArgs} args - Arguments to create many MemberDetails.
     *     @example
     *     // Create many MemberDetails
     *     const memberDetail = await prisma.memberDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberDetailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberDetailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MemberDetail.
     * @param {MemberDetailDeleteArgs} args - Arguments to delete one MemberDetail.
     * @example
     * // Delete one MemberDetail
     * const MemberDetail = await prisma.memberDetail.delete({
     *   where: {
     *     // ... filter to delete one MemberDetail
     *   }
     * })
     * 
    **/
    delete<T extends MemberDetailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MemberDetailDeleteArgs<ExtArgs>>
    ): Prisma__MemberDetailClient<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MemberDetail.
     * @param {MemberDetailUpdateArgs} args - Arguments to update one MemberDetail.
     * @example
     * // Update one MemberDetail
     * const memberDetail = await prisma.memberDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberDetailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberDetailUpdateArgs<ExtArgs>>
    ): Prisma__MemberDetailClient<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MemberDetails.
     * @param {MemberDetailDeleteManyArgs} args - Arguments to filter MemberDetails to delete.
     * @example
     * // Delete a few MemberDetails
     * const { count } = await prisma.memberDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberDetailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberDetailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberDetails
     * const memberDetail = await prisma.memberDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberDetailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MemberDetailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MemberDetail.
     * @param {MemberDetailUpsertArgs} args - Arguments to update or create a MemberDetail.
     * @example
     * // Update or create a MemberDetail
     * const memberDetail = await prisma.memberDetail.upsert({
     *   create: {
     *     // ... data to create a MemberDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberDetail we want to update
     *   }
     * })
    **/
    upsert<T extends MemberDetailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MemberDetailUpsertArgs<ExtArgs>>
    ): Prisma__MemberDetailClient<$Result.GetResult<Prisma.$MemberDetailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MemberDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberDetailCountArgs} args - Arguments to filter MemberDetails to count.
     * @example
     * // Count the number of MemberDetails
     * const count = await prisma.memberDetail.count({
     *   where: {
     *     // ... the filter for the MemberDetails we want to count
     *   }
     * })
    **/
    count<T extends MemberDetailCountArgs>(
      args?: Subset<T, MemberDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberDetailAggregateArgs>(args: Subset<T, MemberDetailAggregateArgs>): Prisma.PrismaPromise<GetMemberDetailAggregateType<T>>

    /**
     * Group by MemberDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberDetailGroupByArgs['orderBy'] }
        : { orderBy?: MemberDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberDetail model
   */
  readonly fields: MemberDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MemberDetail model
   */ 
  interface MemberDetailFieldRefs {
    readonly id: FieldRef<"MemberDetail", 'BigInt'>
    readonly after: FieldRef<"MemberDetail", 'String'>
    readonly amount: FieldRef<"MemberDetail", 'String'>
    readonly before: FieldRef<"MemberDetail", 'String'>
    readonly market: FieldRef<"MemberDetail", 'String'>
    readonly type: FieldRef<"MemberDetail", 'Int'>
    readonly remark: FieldRef<"MemberDetail", 'String'>
    readonly memberId: FieldRef<"MemberDetail", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * MemberDetail findUnique
   */
  export type MemberDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    /**
     * Filter, which MemberDetail to fetch.
     */
    where: MemberDetailWhereUniqueInput
  }


  /**
   * MemberDetail findUniqueOrThrow
   */
  export type MemberDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    /**
     * Filter, which MemberDetail to fetch.
     */
    where: MemberDetailWhereUniqueInput
  }


  /**
   * MemberDetail findFirst
   */
  export type MemberDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    /**
     * Filter, which MemberDetail to fetch.
     */
    where?: MemberDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberDetails to fetch.
     */
    orderBy?: MemberDetailOrderByWithRelationInput | MemberDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberDetails.
     */
    cursor?: MemberDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberDetails.
     */
    distinct?: MemberDetailScalarFieldEnum | MemberDetailScalarFieldEnum[]
  }


  /**
   * MemberDetail findFirstOrThrow
   */
  export type MemberDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    /**
     * Filter, which MemberDetail to fetch.
     */
    where?: MemberDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberDetails to fetch.
     */
    orderBy?: MemberDetailOrderByWithRelationInput | MemberDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberDetails.
     */
    cursor?: MemberDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberDetails.
     */
    distinct?: MemberDetailScalarFieldEnum | MemberDetailScalarFieldEnum[]
  }


  /**
   * MemberDetail findMany
   */
  export type MemberDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    /**
     * Filter, which MemberDetails to fetch.
     */
    where?: MemberDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberDetails to fetch.
     */
    orderBy?: MemberDetailOrderByWithRelationInput | MemberDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberDetails.
     */
    cursor?: MemberDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberDetails.
     */
    skip?: number
    distinct?: MemberDetailScalarFieldEnum | MemberDetailScalarFieldEnum[]
  }


  /**
   * MemberDetail create
   */
  export type MemberDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberDetail.
     */
    data: XOR<MemberDetailCreateInput, MemberDetailUncheckedCreateInput>
  }


  /**
   * MemberDetail createMany
   */
  export type MemberDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberDetails.
     */
    data: MemberDetailCreateManyInput | MemberDetailCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MemberDetail update
   */
  export type MemberDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberDetail.
     */
    data: XOR<MemberDetailUpdateInput, MemberDetailUncheckedUpdateInput>
    /**
     * Choose, which MemberDetail to update.
     */
    where: MemberDetailWhereUniqueInput
  }


  /**
   * MemberDetail updateMany
   */
  export type MemberDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberDetails.
     */
    data: XOR<MemberDetailUpdateManyMutationInput, MemberDetailUncheckedUpdateManyInput>
    /**
     * Filter which MemberDetails to update
     */
    where?: MemberDetailWhereInput
  }


  /**
   * MemberDetail upsert
   */
  export type MemberDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberDetail to update in case it exists.
     */
    where: MemberDetailWhereUniqueInput
    /**
     * In case the MemberDetail found by the `where` argument doesn't exist, create a new MemberDetail with this data.
     */
    create: XOR<MemberDetailCreateInput, MemberDetailUncheckedCreateInput>
    /**
     * In case the MemberDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberDetailUpdateInput, MemberDetailUncheckedUpdateInput>
  }


  /**
   * MemberDetail delete
   */
  export type MemberDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
    /**
     * Filter which MemberDetail to delete.
     */
    where: MemberDetailWhereUniqueInput
  }


  /**
   * MemberDetail deleteMany
   */
  export type MemberDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberDetails to delete
     */
    where?: MemberDetailWhereInput
  }


  /**
   * MemberDetail without action
   */
  export type MemberDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberDetail
     */
    select?: MemberDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberDetailInclude<ExtArgs> | null
  }



  /**
   * Model MemberCard
   */

  export type AggregateMemberCard = {
    _count: MemberCardCountAggregateOutputType | null
    _avg: MemberCardAvgAggregateOutputType | null
    _sum: MemberCardSumAggregateOutputType | null
    _min: MemberCardMinAggregateOutputType | null
    _max: MemberCardMaxAggregateOutputType | null
  }

  export type MemberCardAvgAggregateOutputType = {
    id: number | null
    memberId: number | null
  }

  export type MemberCardSumAggregateOutputType = {
    id: bigint | null
    memberId: bigint | null
  }

  export type MemberCardMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    type: $Enums.RechargeType | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCardMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    type: $Enums.RechargeType | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCardCountAggregateOutputType = {
    id: number
    name: number
    type: number
    detail: number
    memberId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberCardAvgAggregateInputType = {
    id?: true
    memberId?: true
  }

  export type MemberCardSumAggregateInputType = {
    id?: true
    memberId?: true
  }

  export type MemberCardMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCardMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCardCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    detail?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberCard to aggregate.
     */
    where?: MemberCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCards to fetch.
     */
    orderBy?: MemberCardOrderByWithRelationInput | MemberCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MemberCards
    **/
    _count?: true | MemberCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberCardMaxAggregateInputType
  }

  export type GetMemberCardAggregateType<T extends MemberCardAggregateArgs> = {
        [P in keyof T & keyof AggregateMemberCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemberCard[P]>
      : GetScalarType<T[P], AggregateMemberCard[P]>
  }




  export type MemberCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberCardWhereInput
    orderBy?: MemberCardOrderByWithAggregationInput | MemberCardOrderByWithAggregationInput[]
    by: MemberCardScalarFieldEnum[] | MemberCardScalarFieldEnum
    having?: MemberCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCardCountAggregateInputType | true
    _avg?: MemberCardAvgAggregateInputType
    _sum?: MemberCardSumAggregateInputType
    _min?: MemberCardMinAggregateInputType
    _max?: MemberCardMaxAggregateInputType
  }

  export type MemberCardGroupByOutputType = {
    id: bigint
    name: string | null
    type: $Enums.RechargeType
    detail: JsonValue
    memberId: bigint
    createdAt: Date
    updatedAt: Date | null
    _count: MemberCardCountAggregateOutputType | null
    _avg: MemberCardAvgAggregateOutputType | null
    _sum: MemberCardSumAggregateOutputType | null
    _min: MemberCardMinAggregateOutputType | null
    _max: MemberCardMaxAggregateOutputType | null
  }

  type GetMemberCardGroupByPayload<T extends MemberCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberCardGroupByOutputType[P]>
            : GetScalarType<T[P], MemberCardGroupByOutputType[P]>
        }
      >
    >


  export type MemberCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    detail?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["memberCard"]>

  export type MemberCardSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    detail?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }


  export type $MemberCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MemberCard"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string | null
      type: $Enums.RechargeType
      detail: Prisma.JsonValue
      memberId: bigint
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["memberCard"]>
    composites: {}
  }


  type MemberCardGetPayload<S extends boolean | null | undefined | MemberCardDefaultArgs> = $Result.GetResult<Prisma.$MemberCardPayload, S>

  type MemberCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberCardCountAggregateInputType | true
    }

  export interface MemberCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MemberCard'], meta: { name: 'MemberCard' } }
    /**
     * Find zero or one MemberCard that matches the filter.
     * @param {MemberCardFindUniqueArgs} args - Arguments to find a MemberCard
     * @example
     * // Get one MemberCard
     * const memberCard = await prisma.memberCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberCardFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MemberCardFindUniqueArgs<ExtArgs>>
    ): Prisma__MemberCardClient<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MemberCard that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MemberCardFindUniqueOrThrowArgs} args - Arguments to find a MemberCard
     * @example
     * // Get one MemberCard
     * const memberCard = await prisma.memberCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MemberCardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberCardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MemberCardClient<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MemberCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCardFindFirstArgs} args - Arguments to find a MemberCard
     * @example
     * // Get one MemberCard
     * const memberCard = await prisma.memberCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberCardFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberCardFindFirstArgs<ExtArgs>>
    ): Prisma__MemberCardClient<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MemberCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCardFindFirstOrThrowArgs} args - Arguments to find a MemberCard
     * @example
     * // Get one MemberCard
     * const memberCard = await prisma.memberCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MemberCardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberCardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MemberCardClient<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MemberCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MemberCards
     * const memberCards = await prisma.memberCard.findMany()
     * 
     * // Get first 10 MemberCards
     * const memberCards = await prisma.memberCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberCardWithIdOnly = await prisma.memberCard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MemberCardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberCardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MemberCard.
     * @param {MemberCardCreateArgs} args - Arguments to create a MemberCard.
     * @example
     * // Create one MemberCard
     * const MemberCard = await prisma.memberCard.create({
     *   data: {
     *     // ... data to create a MemberCard
     *   }
     * })
     * 
    **/
    create<T extends MemberCardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberCardCreateArgs<ExtArgs>>
    ): Prisma__MemberCardClient<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MemberCards.
     *     @param {MemberCardCreateManyArgs} args - Arguments to create many MemberCards.
     *     @example
     *     // Create many MemberCards
     *     const memberCard = await prisma.memberCard.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberCardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberCardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MemberCard.
     * @param {MemberCardDeleteArgs} args - Arguments to delete one MemberCard.
     * @example
     * // Delete one MemberCard
     * const MemberCard = await prisma.memberCard.delete({
     *   where: {
     *     // ... filter to delete one MemberCard
     *   }
     * })
     * 
    **/
    delete<T extends MemberCardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MemberCardDeleteArgs<ExtArgs>>
    ): Prisma__MemberCardClient<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MemberCard.
     * @param {MemberCardUpdateArgs} args - Arguments to update one MemberCard.
     * @example
     * // Update one MemberCard
     * const memberCard = await prisma.memberCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberCardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MemberCardUpdateArgs<ExtArgs>>
    ): Prisma__MemberCardClient<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MemberCards.
     * @param {MemberCardDeleteManyArgs} args - Arguments to filter MemberCards to delete.
     * @example
     * // Delete a few MemberCards
     * const { count } = await prisma.memberCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberCardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MemberCardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MemberCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MemberCards
     * const memberCard = await prisma.memberCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberCardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MemberCardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MemberCard.
     * @param {MemberCardUpsertArgs} args - Arguments to update or create a MemberCard.
     * @example
     * // Update or create a MemberCard
     * const memberCard = await prisma.memberCard.upsert({
     *   create: {
     *     // ... data to create a MemberCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MemberCard we want to update
     *   }
     * })
    **/
    upsert<T extends MemberCardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MemberCardUpsertArgs<ExtArgs>>
    ): Prisma__MemberCardClient<$Result.GetResult<Prisma.$MemberCardPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MemberCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCardCountArgs} args - Arguments to filter MemberCards to count.
     * @example
     * // Count the number of MemberCards
     * const count = await prisma.memberCard.count({
     *   where: {
     *     // ... the filter for the MemberCards we want to count
     *   }
     * })
    **/
    count<T extends MemberCardCountArgs>(
      args?: Subset<T, MemberCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MemberCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberCardAggregateArgs>(args: Subset<T, MemberCardAggregateArgs>): Prisma.PrismaPromise<GetMemberCardAggregateType<T>>

    /**
     * Group by MemberCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberCardGroupByArgs['orderBy'] }
        : { orderBy?: MemberCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MemberCard model
   */
  readonly fields: MemberCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MemberCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MemberCard model
   */ 
  interface MemberCardFieldRefs {
    readonly id: FieldRef<"MemberCard", 'BigInt'>
    readonly name: FieldRef<"MemberCard", 'String'>
    readonly type: FieldRef<"MemberCard", 'RechargeType'>
    readonly detail: FieldRef<"MemberCard", 'Json'>
    readonly memberId: FieldRef<"MemberCard", 'BigInt'>
    readonly createdAt: FieldRef<"MemberCard", 'DateTime'>
    readonly updatedAt: FieldRef<"MemberCard", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MemberCard findUnique
   */
  export type MemberCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    /**
     * Filter, which MemberCard to fetch.
     */
    where: MemberCardWhereUniqueInput
  }


  /**
   * MemberCard findUniqueOrThrow
   */
  export type MemberCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    /**
     * Filter, which MemberCard to fetch.
     */
    where: MemberCardWhereUniqueInput
  }


  /**
   * MemberCard findFirst
   */
  export type MemberCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    /**
     * Filter, which MemberCard to fetch.
     */
    where?: MemberCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCards to fetch.
     */
    orderBy?: MemberCardOrderByWithRelationInput | MemberCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberCards.
     */
    cursor?: MemberCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberCards.
     */
    distinct?: MemberCardScalarFieldEnum | MemberCardScalarFieldEnum[]
  }


  /**
   * MemberCard findFirstOrThrow
   */
  export type MemberCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    /**
     * Filter, which MemberCard to fetch.
     */
    where?: MemberCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCards to fetch.
     */
    orderBy?: MemberCardOrderByWithRelationInput | MemberCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MemberCards.
     */
    cursor?: MemberCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MemberCards.
     */
    distinct?: MemberCardScalarFieldEnum | MemberCardScalarFieldEnum[]
  }


  /**
   * MemberCard findMany
   */
  export type MemberCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    /**
     * Filter, which MemberCards to fetch.
     */
    where?: MemberCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MemberCards to fetch.
     */
    orderBy?: MemberCardOrderByWithRelationInput | MemberCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MemberCards.
     */
    cursor?: MemberCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MemberCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MemberCards.
     */
    skip?: number
    distinct?: MemberCardScalarFieldEnum | MemberCardScalarFieldEnum[]
  }


  /**
   * MemberCard create
   */
  export type MemberCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    /**
     * The data needed to create a MemberCard.
     */
    data: XOR<MemberCardCreateInput, MemberCardUncheckedCreateInput>
  }


  /**
   * MemberCard createMany
   */
  export type MemberCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MemberCards.
     */
    data: MemberCardCreateManyInput | MemberCardCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MemberCard update
   */
  export type MemberCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    /**
     * The data needed to update a MemberCard.
     */
    data: XOR<MemberCardUpdateInput, MemberCardUncheckedUpdateInput>
    /**
     * Choose, which MemberCard to update.
     */
    where: MemberCardWhereUniqueInput
  }


  /**
   * MemberCard updateMany
   */
  export type MemberCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MemberCards.
     */
    data: XOR<MemberCardUpdateManyMutationInput, MemberCardUncheckedUpdateManyInput>
    /**
     * Filter which MemberCards to update
     */
    where?: MemberCardWhereInput
  }


  /**
   * MemberCard upsert
   */
  export type MemberCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    /**
     * The filter to search for the MemberCard to update in case it exists.
     */
    where: MemberCardWhereUniqueInput
    /**
     * In case the MemberCard found by the `where` argument doesn't exist, create a new MemberCard with this data.
     */
    create: XOR<MemberCardCreateInput, MemberCardUncheckedCreateInput>
    /**
     * In case the MemberCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberCardUpdateInput, MemberCardUncheckedUpdateInput>
  }


  /**
   * MemberCard delete
   */
  export type MemberCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
    /**
     * Filter which MemberCard to delete.
     */
    where: MemberCardWhereUniqueInput
  }


  /**
   * MemberCard deleteMany
   */
  export type MemberCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MemberCards to delete
     */
    where?: MemberCardWhereInput
  }


  /**
   * MemberCard without action
   */
  export type MemberCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCard
     */
    select?: MemberCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberCardInclude<ExtArgs> | null
  }



  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: bigint | null
  }

  export type CountryMinAggregateOutputType = {
    id: bigint | null
    code: string | null
    name: string | null
    en: string | null
    tel: string | null
    py: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: bigint | null
    code: string | null
    name: string | null
    en: string | null
    tel: string | null
    py: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    code: number
    name: number
    en: number
    tel: number
    py: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    en?: true
    tel?: true
    py?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    en?: true
    tel?: true
    py?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    en?: true
    tel?: true
    py?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: bigint
    code: string | null
    name: string
    en: string
    tel: string
    py: string
    createdAt: Date
    updatedAt: Date | null
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    en?: boolean
    tel?: boolean
    py?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    en?: boolean
    tel?: boolean
    py?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      code: string | null
      name: string
      en: string
      tel: string
      py: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["country"]>
    composites: {}
  }


  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryCreateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>
    ): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'BigInt'>
    readonly code: FieldRef<"Country", 'String'>
    readonly name: FieldRef<"Country", 'String'>
    readonly en: FieldRef<"Country", 'String'>
    readonly tel: FieldRef<"Country", 'String'>
    readonly py: FieldRef<"Country", 'String'>
    readonly createdAt: FieldRef<"Country", 'DateTime'>
    readonly updatedAt: FieldRef<"Country", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }


  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }


  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }


  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }


  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
  }



  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingAvgAggregateOutputType = {
    id: number | null
  }

  export type SettingSumAggregateOutputType = {
    id: bigint | null
  }

  export type SettingMinAggregateOutputType = {
    id: bigint | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: bigint | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingAvgAggregateInputType = {
    id?: true
  }

  export type SettingSumAggregateInputType = {
    id?: true
  }

  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _avg?: SettingAvgAggregateInputType
    _sum?: SettingSumAggregateInputType
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: bigint
    key: string
    value: string
    createdAt: Date
    updatedAt: Date | null
    _count: SettingCountAggregateOutputType | null
    _avg: SettingAvgAggregateOutputType | null
    _sum: SettingSumAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      key: string
      value: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }


  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SettingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Setting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SettingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SettingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
    **/
    create<T extends SettingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SettingCreateArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Settings.
     *     @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     *     @example
     *     // Create many Settings
     *     const setting = await prisma.setting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SettingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
    **/
    delete<T extends SettingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SettingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SettingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SettingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
    **/
    upsert<T extends SettingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>
    ): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Setting model
   */ 
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'BigInt'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }


  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }


  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }


  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }


  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }


  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }


  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }


  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
  }


  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }


  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }


  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
  }


  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
  }



  /**
   * Model StockResource
   */

  export type AggregateStockResource = {
    _count: StockResourceCountAggregateOutputType | null
    _avg: StockResourceAvgAggregateOutputType | null
    _sum: StockResourceSumAggregateOutputType | null
    _min: StockResourceMinAggregateOutputType | null
    _max: StockResourceMaxAggregateOutputType | null
  }

  export type StockResourceAvgAggregateOutputType = {
    id: number | null
    type: number | null
    status: number | null
  }

  export type StockResourceSumAggregateOutputType = {
    id: bigint | null
    type: number | null
    status: number | null
  }

  export type StockResourceMinAggregateOutputType = {
    id: bigint | null
    amountScope: string | null
    frequencyScope: string | null
    market: string | null
    spreadScope: string | null
    endAt: string | null
    startAt: string | null
    symbol: string | null
    type: number | null
    status: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockResourceMaxAggregateOutputType = {
    id: bigint | null
    amountScope: string | null
    frequencyScope: string | null
    market: string | null
    spreadScope: string | null
    endAt: string | null
    startAt: string | null
    symbol: string | null
    type: number | null
    status: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockResourceCountAggregateOutputType = {
    id: number
    amountScope: number
    frequencyScope: number
    market: number
    spreadScope: number
    endAt: number
    startAt: number
    symbol: number
    type: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockResourceAvgAggregateInputType = {
    id?: true
    type?: true
    status?: true
  }

  export type StockResourceSumAggregateInputType = {
    id?: true
    type?: true
    status?: true
  }

  export type StockResourceMinAggregateInputType = {
    id?: true
    amountScope?: true
    frequencyScope?: true
    market?: true
    spreadScope?: true
    endAt?: true
    startAt?: true
    symbol?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockResourceMaxAggregateInputType = {
    id?: true
    amountScope?: true
    frequencyScope?: true
    market?: true
    spreadScope?: true
    endAt?: true
    startAt?: true
    symbol?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockResourceCountAggregateInputType = {
    id?: true
    amountScope?: true
    frequencyScope?: true
    market?: true
    spreadScope?: true
    endAt?: true
    startAt?: true
    symbol?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockResource to aggregate.
     */
    where?: StockResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockResources to fetch.
     */
    orderBy?: StockResourceOrderByWithRelationInput | StockResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockResources
    **/
    _count?: true | StockResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockResourceMaxAggregateInputType
  }

  export type GetStockResourceAggregateType<T extends StockResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateStockResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockResource[P]>
      : GetScalarType<T[P], AggregateStockResource[P]>
  }




  export type StockResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockResourceWhereInput
    orderBy?: StockResourceOrderByWithAggregationInput | StockResourceOrderByWithAggregationInput[]
    by: StockResourceScalarFieldEnum[] | StockResourceScalarFieldEnum
    having?: StockResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockResourceCountAggregateInputType | true
    _avg?: StockResourceAvgAggregateInputType
    _sum?: StockResourceSumAggregateInputType
    _min?: StockResourceMinAggregateInputType
    _max?: StockResourceMaxAggregateInputType
  }

  export type StockResourceGroupByOutputType = {
    id: bigint
    amountScope: string
    frequencyScope: string
    market: string
    spreadScope: string
    endAt: string
    startAt: string
    symbol: string
    type: number
    status: number
    createdAt: Date
    updatedAt: Date | null
    _count: StockResourceCountAggregateOutputType | null
    _avg: StockResourceAvgAggregateOutputType | null
    _sum: StockResourceSumAggregateOutputType | null
    _min: StockResourceMinAggregateOutputType | null
    _max: StockResourceMaxAggregateOutputType | null
  }

  type GetStockResourceGroupByPayload<T extends StockResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockResourceGroupByOutputType[P]>
            : GetScalarType<T[P], StockResourceGroupByOutputType[P]>
        }
      >
    >


  export type StockResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amountScope?: boolean
    frequencyScope?: boolean
    market?: boolean
    spreadScope?: boolean
    endAt?: boolean
    startAt?: boolean
    symbol?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stockResource"]>

  export type StockResourceSelectScalar = {
    id?: boolean
    amountScope?: boolean
    frequencyScope?: boolean
    market?: boolean
    spreadScope?: boolean
    endAt?: boolean
    startAt?: boolean
    symbol?: boolean
    type?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $StockResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockResource"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      amountScope: string
      frequencyScope: string
      market: string
      spreadScope: string
      endAt: string
      startAt: string
      symbol: string
      type: number
      status: number
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["stockResource"]>
    composites: {}
  }


  type StockResourceGetPayload<S extends boolean | null | undefined | StockResourceDefaultArgs> = $Result.GetResult<Prisma.$StockResourcePayload, S>

  type StockResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockResourceCountAggregateInputType | true
    }

  export interface StockResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockResource'], meta: { name: 'StockResource' } }
    /**
     * Find zero or one StockResource that matches the filter.
     * @param {StockResourceFindUniqueArgs} args - Arguments to find a StockResource
     * @example
     * // Get one StockResource
     * const stockResource = await prisma.stockResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockResourceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceFindUniqueArgs<ExtArgs>>
    ): Prisma__StockResourceClient<$Result.GetResult<Prisma.$StockResourcePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockResource that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockResourceFindUniqueOrThrowArgs} args - Arguments to find a StockResource
     * @example
     * // Get one StockResource
     * const stockResource = await prisma.stockResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockResourceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockResourceClient<$Result.GetResult<Prisma.$StockResourcePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceFindFirstArgs} args - Arguments to find a StockResource
     * @example
     * // Get one StockResource
     * const stockResource = await prisma.stockResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockResourceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceFindFirstArgs<ExtArgs>>
    ): Prisma__StockResourceClient<$Result.GetResult<Prisma.$StockResourcePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceFindFirstOrThrowArgs} args - Arguments to find a StockResource
     * @example
     * // Get one StockResource
     * const stockResource = await prisma.stockResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockResourceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockResourceClient<$Result.GetResult<Prisma.$StockResourcePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockResources
     * const stockResources = await prisma.stockResource.findMany()
     * 
     * // Get first 10 StockResources
     * const stockResources = await prisma.stockResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockResourceWithIdOnly = await prisma.stockResource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockResourceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockResourcePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockResource.
     * @param {StockResourceCreateArgs} args - Arguments to create a StockResource.
     * @example
     * // Create one StockResource
     * const StockResource = await prisma.stockResource.create({
     *   data: {
     *     // ... data to create a StockResource
     *   }
     * })
     * 
    **/
    create<T extends StockResourceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceCreateArgs<ExtArgs>>
    ): Prisma__StockResourceClient<$Result.GetResult<Prisma.$StockResourcePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockResources.
     *     @param {StockResourceCreateManyArgs} args - Arguments to create many StockResources.
     *     @example
     *     // Create many StockResources
     *     const stockResource = await prisma.stockResource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockResourceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockResource.
     * @param {StockResourceDeleteArgs} args - Arguments to delete one StockResource.
     * @example
     * // Delete one StockResource
     * const StockResource = await prisma.stockResource.delete({
     *   where: {
     *     // ... filter to delete one StockResource
     *   }
     * })
     * 
    **/
    delete<T extends StockResourceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceDeleteArgs<ExtArgs>>
    ): Prisma__StockResourceClient<$Result.GetResult<Prisma.$StockResourcePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockResource.
     * @param {StockResourceUpdateArgs} args - Arguments to update one StockResource.
     * @example
     * // Update one StockResource
     * const stockResource = await prisma.stockResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockResourceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceUpdateArgs<ExtArgs>>
    ): Prisma__StockResourceClient<$Result.GetResult<Prisma.$StockResourcePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockResources.
     * @param {StockResourceDeleteManyArgs} args - Arguments to filter StockResources to delete.
     * @example
     * // Delete a few StockResources
     * const { count } = await prisma.stockResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockResourceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockResources
     * const stockResource = await prisma.stockResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockResourceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockResource.
     * @param {StockResourceUpsertArgs} args - Arguments to update or create a StockResource.
     * @example
     * // Update or create a StockResource
     * const stockResource = await prisma.stockResource.upsert({
     *   create: {
     *     // ... data to create a StockResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockResource we want to update
     *   }
     * })
    **/
    upsert<T extends StockResourceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceUpsertArgs<ExtArgs>>
    ): Prisma__StockResourceClient<$Result.GetResult<Prisma.$StockResourcePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceCountArgs} args - Arguments to filter StockResources to count.
     * @example
     * // Count the number of StockResources
     * const count = await prisma.stockResource.count({
     *   where: {
     *     // ... the filter for the StockResources we want to count
     *   }
     * })
    **/
    count<T extends StockResourceCountArgs>(
      args?: Subset<T, StockResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockResourceAggregateArgs>(args: Subset<T, StockResourceAggregateArgs>): Prisma.PrismaPromise<GetStockResourceAggregateType<T>>

    /**
     * Group by StockResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockResourceGroupByArgs['orderBy'] }
        : { orderBy?: StockResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockResource model
   */
  readonly fields: StockResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockResource model
   */ 
  interface StockResourceFieldRefs {
    readonly id: FieldRef<"StockResource", 'BigInt'>
    readonly amountScope: FieldRef<"StockResource", 'String'>
    readonly frequencyScope: FieldRef<"StockResource", 'String'>
    readonly market: FieldRef<"StockResource", 'String'>
    readonly spreadScope: FieldRef<"StockResource", 'String'>
    readonly endAt: FieldRef<"StockResource", 'String'>
    readonly startAt: FieldRef<"StockResource", 'String'>
    readonly symbol: FieldRef<"StockResource", 'String'>
    readonly type: FieldRef<"StockResource", 'Int'>
    readonly status: FieldRef<"StockResource", 'Int'>
    readonly createdAt: FieldRef<"StockResource", 'DateTime'>
    readonly updatedAt: FieldRef<"StockResource", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StockResource findUnique
   */
  export type StockResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
    /**
     * Filter, which StockResource to fetch.
     */
    where: StockResourceWhereUniqueInput
  }


  /**
   * StockResource findUniqueOrThrow
   */
  export type StockResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
    /**
     * Filter, which StockResource to fetch.
     */
    where: StockResourceWhereUniqueInput
  }


  /**
   * StockResource findFirst
   */
  export type StockResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
    /**
     * Filter, which StockResource to fetch.
     */
    where?: StockResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockResources to fetch.
     */
    orderBy?: StockResourceOrderByWithRelationInput | StockResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockResources.
     */
    cursor?: StockResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockResources.
     */
    distinct?: StockResourceScalarFieldEnum | StockResourceScalarFieldEnum[]
  }


  /**
   * StockResource findFirstOrThrow
   */
  export type StockResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
    /**
     * Filter, which StockResource to fetch.
     */
    where?: StockResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockResources to fetch.
     */
    orderBy?: StockResourceOrderByWithRelationInput | StockResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockResources.
     */
    cursor?: StockResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockResources.
     */
    distinct?: StockResourceScalarFieldEnum | StockResourceScalarFieldEnum[]
  }


  /**
   * StockResource findMany
   */
  export type StockResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
    /**
     * Filter, which StockResources to fetch.
     */
    where?: StockResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockResources to fetch.
     */
    orderBy?: StockResourceOrderByWithRelationInput | StockResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockResources.
     */
    cursor?: StockResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockResources.
     */
    skip?: number
    distinct?: StockResourceScalarFieldEnum | StockResourceScalarFieldEnum[]
  }


  /**
   * StockResource create
   */
  export type StockResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
    /**
     * The data needed to create a StockResource.
     */
    data: XOR<StockResourceCreateInput, StockResourceUncheckedCreateInput>
  }


  /**
   * StockResource createMany
   */
  export type StockResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockResources.
     */
    data: StockResourceCreateManyInput | StockResourceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockResource update
   */
  export type StockResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
    /**
     * The data needed to update a StockResource.
     */
    data: XOR<StockResourceUpdateInput, StockResourceUncheckedUpdateInput>
    /**
     * Choose, which StockResource to update.
     */
    where: StockResourceWhereUniqueInput
  }


  /**
   * StockResource updateMany
   */
  export type StockResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockResources.
     */
    data: XOR<StockResourceUpdateManyMutationInput, StockResourceUncheckedUpdateManyInput>
    /**
     * Filter which StockResources to update
     */
    where?: StockResourceWhereInput
  }


  /**
   * StockResource upsert
   */
  export type StockResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
    /**
     * The filter to search for the StockResource to update in case it exists.
     */
    where: StockResourceWhereUniqueInput
    /**
     * In case the StockResource found by the `where` argument doesn't exist, create a new StockResource with this data.
     */
    create: XOR<StockResourceCreateInput, StockResourceUncheckedCreateInput>
    /**
     * In case the StockResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockResourceUpdateInput, StockResourceUncheckedUpdateInput>
  }


  /**
   * StockResource delete
   */
  export type StockResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
    /**
     * Filter which StockResource to delete.
     */
    where: StockResourceWhereUniqueInput
  }


  /**
   * StockResource deleteMany
   */
  export type StockResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockResources to delete
     */
    where?: StockResourceWhereInput
  }


  /**
   * StockResource without action
   */
  export type StockResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResource
     */
    select?: StockResourceSelect<ExtArgs> | null
  }



  /**
   * Model StockResourceRecord
   */

  export type AggregateStockResourceRecord = {
    _count: StockResourceRecordCountAggregateOutputType | null
    _avg: StockResourceRecordAvgAggregateOutputType | null
    _sum: StockResourceRecordSumAggregateOutputType | null
    _min: StockResourceRecordMinAggregateOutputType | null
    _max: StockResourceRecordMaxAggregateOutputType | null
  }

  export type StockResourceRecordAvgAggregateOutputType = {
    id: number | null
    stockResourceId: number | null
  }

  export type StockResourceRecordSumAggregateOutputType = {
    id: bigint | null
    stockResourceId: bigint | null
  }

  export type StockResourceRecordMinAggregateOutputType = {
    id: bigint | null
    open: string | null
    high: string | null
    close: string | null
    low: string | null
    time: string | null
    stockResourceId: bigint | null
  }

  export type StockResourceRecordMaxAggregateOutputType = {
    id: bigint | null
    open: string | null
    high: string | null
    close: string | null
    low: string | null
    time: string | null
    stockResourceId: bigint | null
  }

  export type StockResourceRecordCountAggregateOutputType = {
    id: number
    open: number
    high: number
    close: number
    low: number
    time: number
    stockResourceId: number
    _all: number
  }


  export type StockResourceRecordAvgAggregateInputType = {
    id?: true
    stockResourceId?: true
  }

  export type StockResourceRecordSumAggregateInputType = {
    id?: true
    stockResourceId?: true
  }

  export type StockResourceRecordMinAggregateInputType = {
    id?: true
    open?: true
    high?: true
    close?: true
    low?: true
    time?: true
    stockResourceId?: true
  }

  export type StockResourceRecordMaxAggregateInputType = {
    id?: true
    open?: true
    high?: true
    close?: true
    low?: true
    time?: true
    stockResourceId?: true
  }

  export type StockResourceRecordCountAggregateInputType = {
    id?: true
    open?: true
    high?: true
    close?: true
    low?: true
    time?: true
    stockResourceId?: true
    _all?: true
  }

  export type StockResourceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockResourceRecord to aggregate.
     */
    where?: StockResourceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockResourceRecords to fetch.
     */
    orderBy?: StockResourceRecordOrderByWithRelationInput | StockResourceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockResourceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockResourceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockResourceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockResourceRecords
    **/
    _count?: true | StockResourceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockResourceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockResourceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockResourceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockResourceRecordMaxAggregateInputType
  }

  export type GetStockResourceRecordAggregateType<T extends StockResourceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateStockResourceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockResourceRecord[P]>
      : GetScalarType<T[P], AggregateStockResourceRecord[P]>
  }




  export type StockResourceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockResourceRecordWhereInput
    orderBy?: StockResourceRecordOrderByWithAggregationInput | StockResourceRecordOrderByWithAggregationInput[]
    by: StockResourceRecordScalarFieldEnum[] | StockResourceRecordScalarFieldEnum
    having?: StockResourceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockResourceRecordCountAggregateInputType | true
    _avg?: StockResourceRecordAvgAggregateInputType
    _sum?: StockResourceRecordSumAggregateInputType
    _min?: StockResourceRecordMinAggregateInputType
    _max?: StockResourceRecordMaxAggregateInputType
  }

  export type StockResourceRecordGroupByOutputType = {
    id: bigint
    open: string
    high: string
    close: string
    low: string
    time: string
    stockResourceId: bigint
    _count: StockResourceRecordCountAggregateOutputType | null
    _avg: StockResourceRecordAvgAggregateOutputType | null
    _sum: StockResourceRecordSumAggregateOutputType | null
    _min: StockResourceRecordMinAggregateOutputType | null
    _max: StockResourceRecordMaxAggregateOutputType | null
  }

  type GetStockResourceRecordGroupByPayload<T extends StockResourceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockResourceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockResourceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockResourceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], StockResourceRecordGroupByOutputType[P]>
        }
      >
    >


  export type StockResourceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    open?: boolean
    high?: boolean
    close?: boolean
    low?: boolean
    time?: boolean
    stockResourceId?: boolean
  }, ExtArgs["result"]["stockResourceRecord"]>

  export type StockResourceRecordSelectScalar = {
    id?: boolean
    open?: boolean
    high?: boolean
    close?: boolean
    low?: boolean
    time?: boolean
    stockResourceId?: boolean
  }


  export type $StockResourceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockResourceRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      open: string
      high: string
      close: string
      low: string
      time: string
      stockResourceId: bigint
    }, ExtArgs["result"]["stockResourceRecord"]>
    composites: {}
  }


  type StockResourceRecordGetPayload<S extends boolean | null | undefined | StockResourceRecordDefaultArgs> = $Result.GetResult<Prisma.$StockResourceRecordPayload, S>

  type StockResourceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockResourceRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockResourceRecordCountAggregateInputType | true
    }

  export interface StockResourceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockResourceRecord'], meta: { name: 'StockResourceRecord' } }
    /**
     * Find zero or one StockResourceRecord that matches the filter.
     * @param {StockResourceRecordFindUniqueArgs} args - Arguments to find a StockResourceRecord
     * @example
     * // Get one StockResourceRecord
     * const stockResourceRecord = await prisma.stockResourceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StockResourceRecordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceRecordFindUniqueArgs<ExtArgs>>
    ): Prisma__StockResourceRecordClient<$Result.GetResult<Prisma.$StockResourceRecordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StockResourceRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StockResourceRecordFindUniqueOrThrowArgs} args - Arguments to find a StockResourceRecord
     * @example
     * // Get one StockResourceRecord
     * const stockResourceRecord = await prisma.stockResourceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StockResourceRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StockResourceRecordClient<$Result.GetResult<Prisma.$StockResourceRecordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StockResourceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceRecordFindFirstArgs} args - Arguments to find a StockResourceRecord
     * @example
     * // Get one StockResourceRecord
     * const stockResourceRecord = await prisma.stockResourceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StockResourceRecordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceRecordFindFirstArgs<ExtArgs>>
    ): Prisma__StockResourceRecordClient<$Result.GetResult<Prisma.$StockResourceRecordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StockResourceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceRecordFindFirstOrThrowArgs} args - Arguments to find a StockResourceRecord
     * @example
     * // Get one StockResourceRecord
     * const stockResourceRecord = await prisma.stockResourceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StockResourceRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StockResourceRecordClient<$Result.GetResult<Prisma.$StockResourceRecordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StockResourceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockResourceRecords
     * const stockResourceRecords = await prisma.stockResourceRecord.findMany()
     * 
     * // Get first 10 StockResourceRecords
     * const stockResourceRecords = await prisma.stockResourceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockResourceRecordWithIdOnly = await prisma.stockResourceRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StockResourceRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockResourceRecordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StockResourceRecord.
     * @param {StockResourceRecordCreateArgs} args - Arguments to create a StockResourceRecord.
     * @example
     * // Create one StockResourceRecord
     * const StockResourceRecord = await prisma.stockResourceRecord.create({
     *   data: {
     *     // ... data to create a StockResourceRecord
     *   }
     * })
     * 
    **/
    create<T extends StockResourceRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceRecordCreateArgs<ExtArgs>>
    ): Prisma__StockResourceRecordClient<$Result.GetResult<Prisma.$StockResourceRecordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StockResourceRecords.
     *     @param {StockResourceRecordCreateManyArgs} args - Arguments to create many StockResourceRecords.
     *     @example
     *     // Create many StockResourceRecords
     *     const stockResourceRecord = await prisma.stockResourceRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StockResourceRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockResourceRecord.
     * @param {StockResourceRecordDeleteArgs} args - Arguments to delete one StockResourceRecord.
     * @example
     * // Delete one StockResourceRecord
     * const StockResourceRecord = await prisma.stockResourceRecord.delete({
     *   where: {
     *     // ... filter to delete one StockResourceRecord
     *   }
     * })
     * 
    **/
    delete<T extends StockResourceRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceRecordDeleteArgs<ExtArgs>>
    ): Prisma__StockResourceRecordClient<$Result.GetResult<Prisma.$StockResourceRecordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StockResourceRecord.
     * @param {StockResourceRecordUpdateArgs} args - Arguments to update one StockResourceRecord.
     * @example
     * // Update one StockResourceRecord
     * const stockResourceRecord = await prisma.stockResourceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StockResourceRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceRecordUpdateArgs<ExtArgs>>
    ): Prisma__StockResourceRecordClient<$Result.GetResult<Prisma.$StockResourceRecordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StockResourceRecords.
     * @param {StockResourceRecordDeleteManyArgs} args - Arguments to filter StockResourceRecords to delete.
     * @example
     * // Delete a few StockResourceRecords
     * const { count } = await prisma.stockResourceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StockResourceRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StockResourceRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockResourceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockResourceRecords
     * const stockResourceRecord = await prisma.stockResourceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StockResourceRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockResourceRecord.
     * @param {StockResourceRecordUpsertArgs} args - Arguments to update or create a StockResourceRecord.
     * @example
     * // Update or create a StockResourceRecord
     * const stockResourceRecord = await prisma.stockResourceRecord.upsert({
     *   create: {
     *     // ... data to create a StockResourceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockResourceRecord we want to update
     *   }
     * })
    **/
    upsert<T extends StockResourceRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StockResourceRecordUpsertArgs<ExtArgs>>
    ): Prisma__StockResourceRecordClient<$Result.GetResult<Prisma.$StockResourceRecordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StockResourceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceRecordCountArgs} args - Arguments to filter StockResourceRecords to count.
     * @example
     * // Count the number of StockResourceRecords
     * const count = await prisma.stockResourceRecord.count({
     *   where: {
     *     // ... the filter for the StockResourceRecords we want to count
     *   }
     * })
    **/
    count<T extends StockResourceRecordCountArgs>(
      args?: Subset<T, StockResourceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockResourceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockResourceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockResourceRecordAggregateArgs>(args: Subset<T, StockResourceRecordAggregateArgs>): Prisma.PrismaPromise<GetStockResourceRecordAggregateType<T>>

    /**
     * Group by StockResourceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockResourceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockResourceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockResourceRecordGroupByArgs['orderBy'] }
        : { orderBy?: StockResourceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockResourceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockResourceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockResourceRecord model
   */
  readonly fields: StockResourceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockResourceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockResourceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StockResourceRecord model
   */ 
  interface StockResourceRecordFieldRefs {
    readonly id: FieldRef<"StockResourceRecord", 'BigInt'>
    readonly open: FieldRef<"StockResourceRecord", 'String'>
    readonly high: FieldRef<"StockResourceRecord", 'String'>
    readonly close: FieldRef<"StockResourceRecord", 'String'>
    readonly low: FieldRef<"StockResourceRecord", 'String'>
    readonly time: FieldRef<"StockResourceRecord", 'String'>
    readonly stockResourceId: FieldRef<"StockResourceRecord", 'BigInt'>
  }
    

  // Custom InputTypes

  /**
   * StockResourceRecord findUnique
   */
  export type StockResourceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
    /**
     * Filter, which StockResourceRecord to fetch.
     */
    where: StockResourceRecordWhereUniqueInput
  }


  /**
   * StockResourceRecord findUniqueOrThrow
   */
  export type StockResourceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
    /**
     * Filter, which StockResourceRecord to fetch.
     */
    where: StockResourceRecordWhereUniqueInput
  }


  /**
   * StockResourceRecord findFirst
   */
  export type StockResourceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
    /**
     * Filter, which StockResourceRecord to fetch.
     */
    where?: StockResourceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockResourceRecords to fetch.
     */
    orderBy?: StockResourceRecordOrderByWithRelationInput | StockResourceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockResourceRecords.
     */
    cursor?: StockResourceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockResourceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockResourceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockResourceRecords.
     */
    distinct?: StockResourceRecordScalarFieldEnum | StockResourceRecordScalarFieldEnum[]
  }


  /**
   * StockResourceRecord findFirstOrThrow
   */
  export type StockResourceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
    /**
     * Filter, which StockResourceRecord to fetch.
     */
    where?: StockResourceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockResourceRecords to fetch.
     */
    orderBy?: StockResourceRecordOrderByWithRelationInput | StockResourceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockResourceRecords.
     */
    cursor?: StockResourceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockResourceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockResourceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockResourceRecords.
     */
    distinct?: StockResourceRecordScalarFieldEnum | StockResourceRecordScalarFieldEnum[]
  }


  /**
   * StockResourceRecord findMany
   */
  export type StockResourceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
    /**
     * Filter, which StockResourceRecords to fetch.
     */
    where?: StockResourceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockResourceRecords to fetch.
     */
    orderBy?: StockResourceRecordOrderByWithRelationInput | StockResourceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockResourceRecords.
     */
    cursor?: StockResourceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockResourceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockResourceRecords.
     */
    skip?: number
    distinct?: StockResourceRecordScalarFieldEnum | StockResourceRecordScalarFieldEnum[]
  }


  /**
   * StockResourceRecord create
   */
  export type StockResourceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
    /**
     * The data needed to create a StockResourceRecord.
     */
    data: XOR<StockResourceRecordCreateInput, StockResourceRecordUncheckedCreateInput>
  }


  /**
   * StockResourceRecord createMany
   */
  export type StockResourceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockResourceRecords.
     */
    data: StockResourceRecordCreateManyInput | StockResourceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StockResourceRecord update
   */
  export type StockResourceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
    /**
     * The data needed to update a StockResourceRecord.
     */
    data: XOR<StockResourceRecordUpdateInput, StockResourceRecordUncheckedUpdateInput>
    /**
     * Choose, which StockResourceRecord to update.
     */
    where: StockResourceRecordWhereUniqueInput
  }


  /**
   * StockResourceRecord updateMany
   */
  export type StockResourceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockResourceRecords.
     */
    data: XOR<StockResourceRecordUpdateManyMutationInput, StockResourceRecordUncheckedUpdateManyInput>
    /**
     * Filter which StockResourceRecords to update
     */
    where?: StockResourceRecordWhereInput
  }


  /**
   * StockResourceRecord upsert
   */
  export type StockResourceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
    /**
     * The filter to search for the StockResourceRecord to update in case it exists.
     */
    where: StockResourceRecordWhereUniqueInput
    /**
     * In case the StockResourceRecord found by the `where` argument doesn't exist, create a new StockResourceRecord with this data.
     */
    create: XOR<StockResourceRecordCreateInput, StockResourceRecordUncheckedCreateInput>
    /**
     * In case the StockResourceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockResourceRecordUpdateInput, StockResourceRecordUncheckedUpdateInput>
  }


  /**
   * StockResourceRecord delete
   */
  export type StockResourceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
    /**
     * Filter which StockResourceRecord to delete.
     */
    where: StockResourceRecordWhereUniqueInput
  }


  /**
   * StockResourceRecord deleteMany
   */
  export type StockResourceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockResourceRecords to delete
     */
    where?: StockResourceRecordWhereInput
  }


  /**
   * StockResourceRecord without action
   */
  export type StockResourceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockResourceRecord
     */
    select?: StockResourceRecordSelect<ExtArgs> | null
  }



  /**
   * Model Article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    id: number | null
  }

  export type ArticleSumAggregateOutputType = {
    id: bigint | null
  }

  export type ArticleMinAggregateOutputType = {
    id: bigint | null
    thumb: string | null
    title: string | null
    market: string | null
    crawlerThumb: string | null
    source: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: bigint | null
    thumb: string | null
    title: string | null
    market: string | null
    crawlerThumb: string | null
    source: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    thumb: number
    title: number
    market: number
    crawlerThumb: number
    source: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    id?: true
  }

  export type ArticleSumAggregateInputType = {
    id?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    thumb?: true
    title?: true
    market?: true
    crawlerThumb?: true
    source?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    thumb?: true
    title?: true
    market?: true
    crawlerThumb?: true
    source?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    thumb?: true
    title?: true
    market?: true
    crawlerThumb?: true
    source?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithAggregationInput | ArticleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    id: bigint
    thumb: string
    title: string
    market: string | null
    crawlerThumb: string | null
    source: string | null
    content: string
    createdAt: Date
    updatedAt: Date | null
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thumb?: boolean
    title?: boolean
    market?: boolean
    crawlerThumb?: boolean
    source?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectScalar = {
    id?: boolean
    thumb?: boolean
    title?: boolean
    market?: boolean
    crawlerThumb?: boolean
    source?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Article"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      thumb: string
      title: string
      market: string | null
      crawlerThumb: string | null
      source: string | null
      content: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["article"]>
    composites: {}
  }


  type ArticleGetPayload<S extends boolean | null | undefined | ArticleDefaultArgs> = $Result.GetResult<Prisma.$ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article'], meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Article that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
    **/
    create<T extends ArticleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Articles.
     *     @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     *     @example
     *     // Create many Articles
     *     const article = await prisma.article.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
    **/
    delete<T extends ArticleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Article model
   */
  readonly fields: ArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Article model
   */ 
  interface ArticleFieldRefs {
    readonly id: FieldRef<"Article", 'BigInt'>
    readonly thumb: FieldRef<"Article", 'String'>
    readonly title: FieldRef<"Article", 'String'>
    readonly market: FieldRef<"Article", 'String'>
    readonly crawlerThumb: FieldRef<"Article", 'String'>
    readonly source: FieldRef<"Article", 'String'>
    readonly content: FieldRef<"Article", 'String'>
    readonly createdAt: FieldRef<"Article", 'DateTime'>
    readonly updatedAt: FieldRef<"Article", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Article findUnique
   */
  export type ArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article findFirst
   */
  export type ArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }


  /**
   * Article create
   */
  export type ArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }


  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Article update
   */
  export type ArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
  }


  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }


  /**
   * Article delete
   */
  export type ArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
  }


  /**
   * Article without action
   */
  export type ArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
  }



  /**
   * Model Recharge
   */

  export type AggregateRecharge = {
    _count: RechargeCountAggregateOutputType | null
    _avg: RechargeAvgAggregateOutputType | null
    _sum: RechargeSumAggregateOutputType | null
    _min: RechargeMinAggregateOutputType | null
    _max: RechargeMaxAggregateOutputType | null
  }

  export type RechargeAvgAggregateOutputType = {
    id: number | null
    money: Decimal | null
    status: number | null
    passMoney: Decimal | null
    convertMoney: Decimal | null
    memberId: number | null
  }

  export type RechargeSumAggregateOutputType = {
    id: bigint | null
    money: Decimal | null
    status: number | null
    passMoney: Decimal | null
    convertMoney: Decimal | null
    memberId: bigint | null
  }

  export type RechargeMinAggregateOutputType = {
    id: bigint | null
    market: string | null
    money: Decimal | null
    type: $Enums.RechargeType | null
    account: string | null
    accountNetwork: string | null
    status: number | null
    passMoney: Decimal | null
    convertMoney: Decimal | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RechargeMaxAggregateOutputType = {
    id: bigint | null
    market: string | null
    money: Decimal | null
    type: $Enums.RechargeType | null
    account: string | null
    accountNetwork: string | null
    status: number | null
    passMoney: Decimal | null
    convertMoney: Decimal | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RechargeCountAggregateOutputType = {
    id: number
    market: number
    money: number
    type: number
    account: number
    accountNetwork: number
    screens: number
    status: number
    passMoney: number
    convertMoney: number
    memberId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RechargeAvgAggregateInputType = {
    id?: true
    money?: true
    status?: true
    passMoney?: true
    convertMoney?: true
    memberId?: true
  }

  export type RechargeSumAggregateInputType = {
    id?: true
    money?: true
    status?: true
    passMoney?: true
    convertMoney?: true
    memberId?: true
  }

  export type RechargeMinAggregateInputType = {
    id?: true
    market?: true
    money?: true
    type?: true
    account?: true
    accountNetwork?: true
    status?: true
    passMoney?: true
    convertMoney?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RechargeMaxAggregateInputType = {
    id?: true
    market?: true
    money?: true
    type?: true
    account?: true
    accountNetwork?: true
    status?: true
    passMoney?: true
    convertMoney?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RechargeCountAggregateInputType = {
    id?: true
    market?: true
    money?: true
    type?: true
    account?: true
    accountNetwork?: true
    screens?: true
    status?: true
    passMoney?: true
    convertMoney?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RechargeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recharge to aggregate.
     */
    where?: RechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharges to fetch.
     */
    orderBy?: RechargeOrderByWithRelationInput | RechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recharges
    **/
    _count?: true | RechargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RechargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RechargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RechargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RechargeMaxAggregateInputType
  }

  export type GetRechargeAggregateType<T extends RechargeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecharge[P]>
      : GetScalarType<T[P], AggregateRecharge[P]>
  }




  export type RechargeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RechargeWhereInput
    orderBy?: RechargeOrderByWithAggregationInput | RechargeOrderByWithAggregationInput[]
    by: RechargeScalarFieldEnum[] | RechargeScalarFieldEnum
    having?: RechargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RechargeCountAggregateInputType | true
    _avg?: RechargeAvgAggregateInputType
    _sum?: RechargeSumAggregateInputType
    _min?: RechargeMinAggregateInputType
    _max?: RechargeMaxAggregateInputType
  }

  export type RechargeGroupByOutputType = {
    id: bigint
    market: string
    money: Decimal
    type: $Enums.RechargeType
    account: string
    accountNetwork: string
    screens: JsonValue
    status: number
    passMoney: Decimal
    convertMoney: Decimal
    memberId: bigint
    createdAt: Date
    updatedAt: Date | null
    _count: RechargeCountAggregateOutputType | null
    _avg: RechargeAvgAggregateOutputType | null
    _sum: RechargeSumAggregateOutputType | null
    _min: RechargeMinAggregateOutputType | null
    _max: RechargeMaxAggregateOutputType | null
  }

  type GetRechargeGroupByPayload<T extends RechargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RechargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RechargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RechargeGroupByOutputType[P]>
            : GetScalarType<T[P], RechargeGroupByOutputType[P]>
        }
      >
    >


  export type RechargeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    market?: boolean
    money?: boolean
    type?: boolean
    account?: boolean
    accountNetwork?: boolean
    screens?: boolean
    status?: boolean
    passMoney?: boolean
    convertMoney?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recharge"]>

  export type RechargeSelectScalar = {
    id?: boolean
    market?: boolean
    money?: boolean
    type?: boolean
    account?: boolean
    accountNetwork?: boolean
    screens?: boolean
    status?: boolean
    passMoney?: boolean
    convertMoney?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RechargeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }


  export type $RechargePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recharge"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      market: string
      money: Prisma.Decimal
      type: $Enums.RechargeType
      account: string
      accountNetwork: string
      screens: Prisma.JsonValue
      status: number
      passMoney: Prisma.Decimal
      convertMoney: Prisma.Decimal
      memberId: bigint
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["recharge"]>
    composites: {}
  }


  type RechargeGetPayload<S extends boolean | null | undefined | RechargeDefaultArgs> = $Result.GetResult<Prisma.$RechargePayload, S>

  type RechargeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RechargeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RechargeCountAggregateInputType | true
    }

  export interface RechargeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recharge'], meta: { name: 'Recharge' } }
    /**
     * Find zero or one Recharge that matches the filter.
     * @param {RechargeFindUniqueArgs} args - Arguments to find a Recharge
     * @example
     * // Get one Recharge
     * const recharge = await prisma.recharge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RechargeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeFindUniqueArgs<ExtArgs>>
    ): Prisma__RechargeClient<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Recharge that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RechargeFindUniqueOrThrowArgs} args - Arguments to find a Recharge
     * @example
     * // Get one Recharge
     * const recharge = await prisma.recharge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RechargeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RechargeClient<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Recharge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeFindFirstArgs} args - Arguments to find a Recharge
     * @example
     * // Get one Recharge
     * const recharge = await prisma.recharge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RechargeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeFindFirstArgs<ExtArgs>>
    ): Prisma__RechargeClient<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Recharge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeFindFirstOrThrowArgs} args - Arguments to find a Recharge
     * @example
     * // Get one Recharge
     * const recharge = await prisma.recharge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RechargeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RechargeClient<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Recharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recharges
     * const recharges = await prisma.recharge.findMany()
     * 
     * // Get first 10 Recharges
     * const recharges = await prisma.recharge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rechargeWithIdOnly = await prisma.recharge.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RechargeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Recharge.
     * @param {RechargeCreateArgs} args - Arguments to create a Recharge.
     * @example
     * // Create one Recharge
     * const Recharge = await prisma.recharge.create({
     *   data: {
     *     // ... data to create a Recharge
     *   }
     * })
     * 
    **/
    create<T extends RechargeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeCreateArgs<ExtArgs>>
    ): Prisma__RechargeClient<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Recharges.
     *     @param {RechargeCreateManyArgs} args - Arguments to create many Recharges.
     *     @example
     *     // Create many Recharges
     *     const recharge = await prisma.recharge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RechargeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recharge.
     * @param {RechargeDeleteArgs} args - Arguments to delete one Recharge.
     * @example
     * // Delete one Recharge
     * const Recharge = await prisma.recharge.delete({
     *   where: {
     *     // ... filter to delete one Recharge
     *   }
     * })
     * 
    **/
    delete<T extends RechargeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeDeleteArgs<ExtArgs>>
    ): Prisma__RechargeClient<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Recharge.
     * @param {RechargeUpdateArgs} args - Arguments to update one Recharge.
     * @example
     * // Update one Recharge
     * const recharge = await prisma.recharge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RechargeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeUpdateArgs<ExtArgs>>
    ): Prisma__RechargeClient<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Recharges.
     * @param {RechargeDeleteManyArgs} args - Arguments to filter Recharges to delete.
     * @example
     * // Delete a few Recharges
     * const { count } = await prisma.recharge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RechargeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recharges
     * const recharge = await prisma.recharge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RechargeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recharge.
     * @param {RechargeUpsertArgs} args - Arguments to update or create a Recharge.
     * @example
     * // Update or create a Recharge
     * const recharge = await prisma.recharge.upsert({
     *   create: {
     *     // ... data to create a Recharge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recharge we want to update
     *   }
     * })
    **/
    upsert<T extends RechargeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeUpsertArgs<ExtArgs>>
    ): Prisma__RechargeClient<$Result.GetResult<Prisma.$RechargePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Recharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeCountArgs} args - Arguments to filter Recharges to count.
     * @example
     * // Count the number of Recharges
     * const count = await prisma.recharge.count({
     *   where: {
     *     // ... the filter for the Recharges we want to count
     *   }
     * })
    **/
    count<T extends RechargeCountArgs>(
      args?: Subset<T, RechargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RechargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RechargeAggregateArgs>(args: Subset<T, RechargeAggregateArgs>): Prisma.PrismaPromise<GetRechargeAggregateType<T>>

    /**
     * Group by Recharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RechargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RechargeGroupByArgs['orderBy'] }
        : { orderBy?: RechargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RechargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRechargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recharge model
   */
  readonly fields: RechargeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recharge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RechargeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Recharge model
   */ 
  interface RechargeFieldRefs {
    readonly id: FieldRef<"Recharge", 'BigInt'>
    readonly market: FieldRef<"Recharge", 'String'>
    readonly money: FieldRef<"Recharge", 'Decimal'>
    readonly type: FieldRef<"Recharge", 'RechargeType'>
    readonly account: FieldRef<"Recharge", 'String'>
    readonly accountNetwork: FieldRef<"Recharge", 'String'>
    readonly screens: FieldRef<"Recharge", 'Json'>
    readonly status: FieldRef<"Recharge", 'Int'>
    readonly passMoney: FieldRef<"Recharge", 'Decimal'>
    readonly convertMoney: FieldRef<"Recharge", 'Decimal'>
    readonly memberId: FieldRef<"Recharge", 'BigInt'>
    readonly createdAt: FieldRef<"Recharge", 'DateTime'>
    readonly updatedAt: FieldRef<"Recharge", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Recharge findUnique
   */
  export type RechargeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    /**
     * Filter, which Recharge to fetch.
     */
    where: RechargeWhereUniqueInput
  }


  /**
   * Recharge findUniqueOrThrow
   */
  export type RechargeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    /**
     * Filter, which Recharge to fetch.
     */
    where: RechargeWhereUniqueInput
  }


  /**
   * Recharge findFirst
   */
  export type RechargeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    /**
     * Filter, which Recharge to fetch.
     */
    where?: RechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharges to fetch.
     */
    orderBy?: RechargeOrderByWithRelationInput | RechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recharges.
     */
    cursor?: RechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recharges.
     */
    distinct?: RechargeScalarFieldEnum | RechargeScalarFieldEnum[]
  }


  /**
   * Recharge findFirstOrThrow
   */
  export type RechargeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    /**
     * Filter, which Recharge to fetch.
     */
    where?: RechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharges to fetch.
     */
    orderBy?: RechargeOrderByWithRelationInput | RechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recharges.
     */
    cursor?: RechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recharges.
     */
    distinct?: RechargeScalarFieldEnum | RechargeScalarFieldEnum[]
  }


  /**
   * Recharge findMany
   */
  export type RechargeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    /**
     * Filter, which Recharges to fetch.
     */
    where?: RechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recharges to fetch.
     */
    orderBy?: RechargeOrderByWithRelationInput | RechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recharges.
     */
    cursor?: RechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recharges.
     */
    skip?: number
    distinct?: RechargeScalarFieldEnum | RechargeScalarFieldEnum[]
  }


  /**
   * Recharge create
   */
  export type RechargeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recharge.
     */
    data: XOR<RechargeCreateInput, RechargeUncheckedCreateInput>
  }


  /**
   * Recharge createMany
   */
  export type RechargeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recharges.
     */
    data: RechargeCreateManyInput | RechargeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Recharge update
   */
  export type RechargeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recharge.
     */
    data: XOR<RechargeUpdateInput, RechargeUncheckedUpdateInput>
    /**
     * Choose, which Recharge to update.
     */
    where: RechargeWhereUniqueInput
  }


  /**
   * Recharge updateMany
   */
  export type RechargeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recharges.
     */
    data: XOR<RechargeUpdateManyMutationInput, RechargeUncheckedUpdateManyInput>
    /**
     * Filter which Recharges to update
     */
    where?: RechargeWhereInput
  }


  /**
   * Recharge upsert
   */
  export type RechargeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recharge to update in case it exists.
     */
    where: RechargeWhereUniqueInput
    /**
     * In case the Recharge found by the `where` argument doesn't exist, create a new Recharge with this data.
     */
    create: XOR<RechargeCreateInput, RechargeUncheckedCreateInput>
    /**
     * In case the Recharge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RechargeUpdateInput, RechargeUncheckedUpdateInput>
  }


  /**
   * Recharge delete
   */
  export type RechargeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
    /**
     * Filter which Recharge to delete.
     */
    where: RechargeWhereUniqueInput
  }


  /**
   * Recharge deleteMany
   */
  export type RechargeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recharges to delete
     */
    where?: RechargeWhereInput
  }


  /**
   * Recharge without action
   */
  export type RechargeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recharge
     */
    select?: RechargeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RechargeInclude<ExtArgs> | null
  }



  /**
   * Model Withdraw
   */

  export type AggregateWithdraw = {
    _count: WithdrawCountAggregateOutputType | null
    _avg: WithdrawAvgAggregateOutputType | null
    _sum: WithdrawSumAggregateOutputType | null
    _min: WithdrawMinAggregateOutputType | null
    _max: WithdrawMaxAggregateOutputType | null
  }

  export type WithdrawAvgAggregateOutputType = {
    id: number | null
    money: Decimal | null
    convertMoney: Decimal | null
    status: number | null
    memberId: number | null
  }

  export type WithdrawSumAggregateOutputType = {
    id: bigint | null
    money: Decimal | null
    convertMoney: Decimal | null
    status: number | null
    memberId: bigint | null
  }

  export type WithdrawMinAggregateOutputType = {
    id: bigint | null
    market: string | null
    money: Decimal | null
    type: $Enums.RechargeType | null
    currency: string | null
    cryptoType: string | null
    cryptoNetwork: string | null
    convertMoney: Decimal | null
    status: number | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WithdrawMaxAggregateOutputType = {
    id: bigint | null
    market: string | null
    money: Decimal | null
    type: $Enums.RechargeType | null
    currency: string | null
    cryptoType: string | null
    cryptoNetwork: string | null
    convertMoney: Decimal | null
    status: number | null
    memberId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WithdrawCountAggregateOutputType = {
    id: number
    market: number
    money: number
    type: number
    currency: number
    cryptoType: number
    cryptoNetwork: number
    card: number
    convertMoney: number
    status: number
    memberId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WithdrawAvgAggregateInputType = {
    id?: true
    money?: true
    convertMoney?: true
    status?: true
    memberId?: true
  }

  export type WithdrawSumAggregateInputType = {
    id?: true
    money?: true
    convertMoney?: true
    status?: true
    memberId?: true
  }

  export type WithdrawMinAggregateInputType = {
    id?: true
    market?: true
    money?: true
    type?: true
    currency?: true
    cryptoType?: true
    cryptoNetwork?: true
    convertMoney?: true
    status?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WithdrawMaxAggregateInputType = {
    id?: true
    market?: true
    money?: true
    type?: true
    currency?: true
    cryptoType?: true
    cryptoNetwork?: true
    convertMoney?: true
    status?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WithdrawCountAggregateInputType = {
    id?: true
    market?: true
    money?: true
    type?: true
    currency?: true
    cryptoType?: true
    cryptoNetwork?: true
    card?: true
    convertMoney?: true
    status?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WithdrawAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdraw to aggregate.
     */
    where?: WithdrawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdraws to fetch.
     */
    orderBy?: WithdrawOrderByWithRelationInput | WithdrawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WithdrawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdraws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdraws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Withdraws
    **/
    _count?: true | WithdrawCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawMaxAggregateInputType
  }

  export type GetWithdrawAggregateType<T extends WithdrawAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdraw]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdraw[P]>
      : GetScalarType<T[P], AggregateWithdraw[P]>
  }




  export type WithdrawGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WithdrawWhereInput
    orderBy?: WithdrawOrderByWithAggregationInput | WithdrawOrderByWithAggregationInput[]
    by: WithdrawScalarFieldEnum[] | WithdrawScalarFieldEnum
    having?: WithdrawScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawCountAggregateInputType | true
    _avg?: WithdrawAvgAggregateInputType
    _sum?: WithdrawSumAggregateInputType
    _min?: WithdrawMinAggregateInputType
    _max?: WithdrawMaxAggregateInputType
  }

  export type WithdrawGroupByOutputType = {
    id: bigint
    market: string
    money: Decimal
    type: $Enums.RechargeType
    currency: string
    cryptoType: string | null
    cryptoNetwork: string | null
    card: JsonValue | null
    convertMoney: Decimal
    status: number
    memberId: bigint
    createdAt: Date
    updatedAt: Date | null
    _count: WithdrawCountAggregateOutputType | null
    _avg: WithdrawAvgAggregateOutputType | null
    _sum: WithdrawSumAggregateOutputType | null
    _min: WithdrawMinAggregateOutputType | null
    _max: WithdrawMaxAggregateOutputType | null
  }

  type GetWithdrawGroupByPayload<T extends WithdrawGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawGroupByOutputType[P]>
        }
      >
    >


  export type WithdrawSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    market?: boolean
    money?: boolean
    type?: boolean
    currency?: boolean
    cryptoType?: boolean
    cryptoNetwork?: boolean
    card?: boolean
    convertMoney?: boolean
    status?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdraw"]>

  export type WithdrawSelectScalar = {
    id?: boolean
    market?: boolean
    money?: boolean
    type?: boolean
    currency?: boolean
    cryptoType?: boolean
    cryptoNetwork?: boolean
    card?: boolean
    convertMoney?: boolean
    status?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WithdrawInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | MemberDefaultArgs<ExtArgs>
  }


  export type $WithdrawPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Withdraw"
    objects: {
      member: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      market: string
      money: Prisma.Decimal
      type: $Enums.RechargeType
      currency: string
      cryptoType: string | null
      cryptoNetwork: string | null
      card: Prisma.JsonValue | null
      convertMoney: Prisma.Decimal
      status: number
      memberId: bigint
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["withdraw"]>
    composites: {}
  }


  type WithdrawGetPayload<S extends boolean | null | undefined | WithdrawDefaultArgs> = $Result.GetResult<Prisma.$WithdrawPayload, S>

  type WithdrawCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WithdrawFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WithdrawCountAggregateInputType | true
    }

  export interface WithdrawDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Withdraw'], meta: { name: 'Withdraw' } }
    /**
     * Find zero or one Withdraw that matches the filter.
     * @param {WithdrawFindUniqueArgs} args - Arguments to find a Withdraw
     * @example
     * // Get one Withdraw
     * const withdraw = await prisma.withdraw.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WithdrawFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WithdrawFindUniqueArgs<ExtArgs>>
    ): Prisma__WithdrawClient<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Withdraw that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WithdrawFindUniqueOrThrowArgs} args - Arguments to find a Withdraw
     * @example
     * // Get one Withdraw
     * const withdraw = await prisma.withdraw.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WithdrawFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WithdrawFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WithdrawClient<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Withdraw that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawFindFirstArgs} args - Arguments to find a Withdraw
     * @example
     * // Get one Withdraw
     * const withdraw = await prisma.withdraw.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WithdrawFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WithdrawFindFirstArgs<ExtArgs>>
    ): Prisma__WithdrawClient<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Withdraw that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawFindFirstOrThrowArgs} args - Arguments to find a Withdraw
     * @example
     * // Get one Withdraw
     * const withdraw = await prisma.withdraw.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WithdrawFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WithdrawFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WithdrawClient<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Withdraws that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdraws
     * const withdraws = await prisma.withdraw.findMany()
     * 
     * // Get first 10 Withdraws
     * const withdraws = await prisma.withdraw.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawWithIdOnly = await prisma.withdraw.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WithdrawFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WithdrawFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Withdraw.
     * @param {WithdrawCreateArgs} args - Arguments to create a Withdraw.
     * @example
     * // Create one Withdraw
     * const Withdraw = await prisma.withdraw.create({
     *   data: {
     *     // ... data to create a Withdraw
     *   }
     * })
     * 
    **/
    create<T extends WithdrawCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WithdrawCreateArgs<ExtArgs>>
    ): Prisma__WithdrawClient<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Withdraws.
     *     @param {WithdrawCreateManyArgs} args - Arguments to create many Withdraws.
     *     @example
     *     // Create many Withdraws
     *     const withdraw = await prisma.withdraw.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WithdrawCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WithdrawCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Withdraw.
     * @param {WithdrawDeleteArgs} args - Arguments to delete one Withdraw.
     * @example
     * // Delete one Withdraw
     * const Withdraw = await prisma.withdraw.delete({
     *   where: {
     *     // ... filter to delete one Withdraw
     *   }
     * })
     * 
    **/
    delete<T extends WithdrawDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WithdrawDeleteArgs<ExtArgs>>
    ): Prisma__WithdrawClient<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Withdraw.
     * @param {WithdrawUpdateArgs} args - Arguments to update one Withdraw.
     * @example
     * // Update one Withdraw
     * const withdraw = await prisma.withdraw.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WithdrawUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WithdrawUpdateArgs<ExtArgs>>
    ): Prisma__WithdrawClient<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Withdraws.
     * @param {WithdrawDeleteManyArgs} args - Arguments to filter Withdraws to delete.
     * @example
     * // Delete a few Withdraws
     * const { count } = await prisma.withdraw.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WithdrawDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WithdrawDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdraws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdraws
     * const withdraw = await prisma.withdraw.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WithdrawUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WithdrawUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Withdraw.
     * @param {WithdrawUpsertArgs} args - Arguments to update or create a Withdraw.
     * @example
     * // Update or create a Withdraw
     * const withdraw = await prisma.withdraw.upsert({
     *   create: {
     *     // ... data to create a Withdraw
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdraw we want to update
     *   }
     * })
    **/
    upsert<T extends WithdrawUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WithdrawUpsertArgs<ExtArgs>>
    ): Prisma__WithdrawClient<$Result.GetResult<Prisma.$WithdrawPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Withdraws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawCountArgs} args - Arguments to filter Withdraws to count.
     * @example
     * // Count the number of Withdraws
     * const count = await prisma.withdraw.count({
     *   where: {
     *     // ... the filter for the Withdraws we want to count
     *   }
     * })
    **/
    count<T extends WithdrawCountArgs>(
      args?: Subset<T, WithdrawCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdraw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawAggregateArgs>(args: Subset<T, WithdrawAggregateArgs>): Prisma.PrismaPromise<GetWithdrawAggregateType<T>>

    /**
     * Group by Withdraw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WithdrawGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WithdrawGroupByArgs['orderBy'] }
        : { orderBy?: WithdrawGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WithdrawGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Withdraw model
   */
  readonly fields: WithdrawFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Withdraw.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WithdrawClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    member<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Withdraw model
   */ 
  interface WithdrawFieldRefs {
    readonly id: FieldRef<"Withdraw", 'BigInt'>
    readonly market: FieldRef<"Withdraw", 'String'>
    readonly money: FieldRef<"Withdraw", 'Decimal'>
    readonly type: FieldRef<"Withdraw", 'RechargeType'>
    readonly currency: FieldRef<"Withdraw", 'String'>
    readonly cryptoType: FieldRef<"Withdraw", 'String'>
    readonly cryptoNetwork: FieldRef<"Withdraw", 'String'>
    readonly card: FieldRef<"Withdraw", 'Json'>
    readonly convertMoney: FieldRef<"Withdraw", 'Decimal'>
    readonly status: FieldRef<"Withdraw", 'Int'>
    readonly memberId: FieldRef<"Withdraw", 'BigInt'>
    readonly createdAt: FieldRef<"Withdraw", 'DateTime'>
    readonly updatedAt: FieldRef<"Withdraw", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Withdraw findUnique
   */
  export type WithdrawFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    /**
     * Filter, which Withdraw to fetch.
     */
    where: WithdrawWhereUniqueInput
  }


  /**
   * Withdraw findUniqueOrThrow
   */
  export type WithdrawFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    /**
     * Filter, which Withdraw to fetch.
     */
    where: WithdrawWhereUniqueInput
  }


  /**
   * Withdraw findFirst
   */
  export type WithdrawFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    /**
     * Filter, which Withdraw to fetch.
     */
    where?: WithdrawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdraws to fetch.
     */
    orderBy?: WithdrawOrderByWithRelationInput | WithdrawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdraws.
     */
    cursor?: WithdrawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdraws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdraws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdraws.
     */
    distinct?: WithdrawScalarFieldEnum | WithdrawScalarFieldEnum[]
  }


  /**
   * Withdraw findFirstOrThrow
   */
  export type WithdrawFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    /**
     * Filter, which Withdraw to fetch.
     */
    where?: WithdrawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdraws to fetch.
     */
    orderBy?: WithdrawOrderByWithRelationInput | WithdrawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Withdraws.
     */
    cursor?: WithdrawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdraws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdraws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Withdraws.
     */
    distinct?: WithdrawScalarFieldEnum | WithdrawScalarFieldEnum[]
  }


  /**
   * Withdraw findMany
   */
  export type WithdrawFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    /**
     * Filter, which Withdraws to fetch.
     */
    where?: WithdrawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Withdraws to fetch.
     */
    orderBy?: WithdrawOrderByWithRelationInput | WithdrawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Withdraws.
     */
    cursor?: WithdrawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Withdraws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Withdraws.
     */
    skip?: number
    distinct?: WithdrawScalarFieldEnum | WithdrawScalarFieldEnum[]
  }


  /**
   * Withdraw create
   */
  export type WithdrawCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    /**
     * The data needed to create a Withdraw.
     */
    data: XOR<WithdrawCreateInput, WithdrawUncheckedCreateInput>
  }


  /**
   * Withdraw createMany
   */
  export type WithdrawCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Withdraws.
     */
    data: WithdrawCreateManyInput | WithdrawCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Withdraw update
   */
  export type WithdrawUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    /**
     * The data needed to update a Withdraw.
     */
    data: XOR<WithdrawUpdateInput, WithdrawUncheckedUpdateInput>
    /**
     * Choose, which Withdraw to update.
     */
    where: WithdrawWhereUniqueInput
  }


  /**
   * Withdraw updateMany
   */
  export type WithdrawUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Withdraws.
     */
    data: XOR<WithdrawUpdateManyMutationInput, WithdrawUncheckedUpdateManyInput>
    /**
     * Filter which Withdraws to update
     */
    where?: WithdrawWhereInput
  }


  /**
   * Withdraw upsert
   */
  export type WithdrawUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    /**
     * The filter to search for the Withdraw to update in case it exists.
     */
    where: WithdrawWhereUniqueInput
    /**
     * In case the Withdraw found by the `where` argument doesn't exist, create a new Withdraw with this data.
     */
    create: XOR<WithdrawCreateInput, WithdrawUncheckedCreateInput>
    /**
     * In case the Withdraw was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WithdrawUpdateInput, WithdrawUncheckedUpdateInput>
  }


  /**
   * Withdraw delete
   */
  export type WithdrawDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
    /**
     * Filter which Withdraw to delete.
     */
    where: WithdrawWhereUniqueInput
  }


  /**
   * Withdraw deleteMany
   */
  export type WithdrawDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Withdraws to delete
     */
    where?: WithdrawWhereInput
  }


  /**
   * Withdraw without action
   */
  export type WithdrawDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Withdraw
     */
    select?: WithdrawSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WithdrawInclude<ExtArgs> | null
  }



  /**
   * Model RechargeAccount
   */

  export type AggregateRechargeAccount = {
    _count: RechargeAccountCountAggregateOutputType | null
    _avg: RechargeAccountAvgAggregateOutputType | null
    _sum: RechargeAccountSumAggregateOutputType | null
    _min: RechargeAccountMinAggregateOutputType | null
    _max: RechargeAccountMaxAggregateOutputType | null
  }

  export type RechargeAccountAvgAggregateOutputType = {
    id: number | null
    max: Decimal | null
    min: Decimal | null
    status: number | null
  }

  export type RechargeAccountSumAggregateOutputType = {
    id: bigint | null
    max: Decimal | null
    min: Decimal | null
    status: number | null
  }

  export type RechargeAccountMinAggregateOutputType = {
    id: bigint | null
    account: string | null
    accountAddress: string | null
    currency: string | null
    max: Decimal | null
    min: Decimal | null
    status: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RechargeAccountMaxAggregateOutputType = {
    id: bigint | null
    account: string | null
    accountAddress: string | null
    currency: string | null
    max: Decimal | null
    min: Decimal | null
    status: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RechargeAccountCountAggregateOutputType = {
    id: number
    account: number
    accountAddress: number
    currency: number
    max: number
    min: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RechargeAccountAvgAggregateInputType = {
    id?: true
    max?: true
    min?: true
    status?: true
  }

  export type RechargeAccountSumAggregateInputType = {
    id?: true
    max?: true
    min?: true
    status?: true
  }

  export type RechargeAccountMinAggregateInputType = {
    id?: true
    account?: true
    accountAddress?: true
    currency?: true
    max?: true
    min?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RechargeAccountMaxAggregateInputType = {
    id?: true
    account?: true
    accountAddress?: true
    currency?: true
    max?: true
    min?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RechargeAccountCountAggregateInputType = {
    id?: true
    account?: true
    accountAddress?: true
    currency?: true
    max?: true
    min?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RechargeAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RechargeAccount to aggregate.
     */
    where?: RechargeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargeAccounts to fetch.
     */
    orderBy?: RechargeAccountOrderByWithRelationInput | RechargeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RechargeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargeAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RechargeAccounts
    **/
    _count?: true | RechargeAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RechargeAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RechargeAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RechargeAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RechargeAccountMaxAggregateInputType
  }

  export type GetRechargeAccountAggregateType<T extends RechargeAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateRechargeAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRechargeAccount[P]>
      : GetScalarType<T[P], AggregateRechargeAccount[P]>
  }




  export type RechargeAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RechargeAccountWhereInput
    orderBy?: RechargeAccountOrderByWithAggregationInput | RechargeAccountOrderByWithAggregationInput[]
    by: RechargeAccountScalarFieldEnum[] | RechargeAccountScalarFieldEnum
    having?: RechargeAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RechargeAccountCountAggregateInputType | true
    _avg?: RechargeAccountAvgAggregateInputType
    _sum?: RechargeAccountSumAggregateInputType
    _min?: RechargeAccountMinAggregateInputType
    _max?: RechargeAccountMaxAggregateInputType
  }

  export type RechargeAccountGroupByOutputType = {
    id: bigint
    account: string
    accountAddress: string
    currency: string
    max: Decimal
    min: Decimal
    status: number
    createdAt: Date
    updatedAt: Date | null
    _count: RechargeAccountCountAggregateOutputType | null
    _avg: RechargeAccountAvgAggregateOutputType | null
    _sum: RechargeAccountSumAggregateOutputType | null
    _min: RechargeAccountMinAggregateOutputType | null
    _max: RechargeAccountMaxAggregateOutputType | null
  }

  type GetRechargeAccountGroupByPayload<T extends RechargeAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RechargeAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RechargeAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RechargeAccountGroupByOutputType[P]>
            : GetScalarType<T[P], RechargeAccountGroupByOutputType[P]>
        }
      >
    >


  export type RechargeAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account?: boolean
    accountAddress?: boolean
    currency?: boolean
    max?: boolean
    min?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rechargeAccount"]>

  export type RechargeAccountSelectScalar = {
    id?: boolean
    account?: boolean
    accountAddress?: boolean
    currency?: boolean
    max?: boolean
    min?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $RechargeAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RechargeAccount"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      account: string
      accountAddress: string
      currency: string
      max: Prisma.Decimal
      min: Prisma.Decimal
      status: number
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["rechargeAccount"]>
    composites: {}
  }


  type RechargeAccountGetPayload<S extends boolean | null | undefined | RechargeAccountDefaultArgs> = $Result.GetResult<Prisma.$RechargeAccountPayload, S>

  type RechargeAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RechargeAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RechargeAccountCountAggregateInputType | true
    }

  export interface RechargeAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RechargeAccount'], meta: { name: 'RechargeAccount' } }
    /**
     * Find zero or one RechargeAccount that matches the filter.
     * @param {RechargeAccountFindUniqueArgs} args - Arguments to find a RechargeAccount
     * @example
     * // Get one RechargeAccount
     * const rechargeAccount = await prisma.rechargeAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RechargeAccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeAccountFindUniqueArgs<ExtArgs>>
    ): Prisma__RechargeAccountClient<$Result.GetResult<Prisma.$RechargeAccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RechargeAccount that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RechargeAccountFindUniqueOrThrowArgs} args - Arguments to find a RechargeAccount
     * @example
     * // Get one RechargeAccount
     * const rechargeAccount = await prisma.rechargeAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RechargeAccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeAccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RechargeAccountClient<$Result.GetResult<Prisma.$RechargeAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RechargeAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeAccountFindFirstArgs} args - Arguments to find a RechargeAccount
     * @example
     * // Get one RechargeAccount
     * const rechargeAccount = await prisma.rechargeAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RechargeAccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeAccountFindFirstArgs<ExtArgs>>
    ): Prisma__RechargeAccountClient<$Result.GetResult<Prisma.$RechargeAccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RechargeAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeAccountFindFirstOrThrowArgs} args - Arguments to find a RechargeAccount
     * @example
     * // Get one RechargeAccount
     * const rechargeAccount = await prisma.rechargeAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RechargeAccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeAccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RechargeAccountClient<$Result.GetResult<Prisma.$RechargeAccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RechargeAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RechargeAccounts
     * const rechargeAccounts = await prisma.rechargeAccount.findMany()
     * 
     * // Get first 10 RechargeAccounts
     * const rechargeAccounts = await prisma.rechargeAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rechargeAccountWithIdOnly = await prisma.rechargeAccount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RechargeAccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeAccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RechargeAccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RechargeAccount.
     * @param {RechargeAccountCreateArgs} args - Arguments to create a RechargeAccount.
     * @example
     * // Create one RechargeAccount
     * const RechargeAccount = await prisma.rechargeAccount.create({
     *   data: {
     *     // ... data to create a RechargeAccount
     *   }
     * })
     * 
    **/
    create<T extends RechargeAccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeAccountCreateArgs<ExtArgs>>
    ): Prisma__RechargeAccountClient<$Result.GetResult<Prisma.$RechargeAccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RechargeAccounts.
     *     @param {RechargeAccountCreateManyArgs} args - Arguments to create many RechargeAccounts.
     *     @example
     *     // Create many RechargeAccounts
     *     const rechargeAccount = await prisma.rechargeAccount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RechargeAccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeAccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RechargeAccount.
     * @param {RechargeAccountDeleteArgs} args - Arguments to delete one RechargeAccount.
     * @example
     * // Delete one RechargeAccount
     * const RechargeAccount = await prisma.rechargeAccount.delete({
     *   where: {
     *     // ... filter to delete one RechargeAccount
     *   }
     * })
     * 
    **/
    delete<T extends RechargeAccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeAccountDeleteArgs<ExtArgs>>
    ): Prisma__RechargeAccountClient<$Result.GetResult<Prisma.$RechargeAccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RechargeAccount.
     * @param {RechargeAccountUpdateArgs} args - Arguments to update one RechargeAccount.
     * @example
     * // Update one RechargeAccount
     * const rechargeAccount = await prisma.rechargeAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RechargeAccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeAccountUpdateArgs<ExtArgs>>
    ): Prisma__RechargeAccountClient<$Result.GetResult<Prisma.$RechargeAccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RechargeAccounts.
     * @param {RechargeAccountDeleteManyArgs} args - Arguments to filter RechargeAccounts to delete.
     * @example
     * // Delete a few RechargeAccounts
     * const { count } = await prisma.rechargeAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RechargeAccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RechargeAccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RechargeAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RechargeAccounts
     * const rechargeAccount = await prisma.rechargeAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RechargeAccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeAccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RechargeAccount.
     * @param {RechargeAccountUpsertArgs} args - Arguments to update or create a RechargeAccount.
     * @example
     * // Update or create a RechargeAccount
     * const rechargeAccount = await prisma.rechargeAccount.upsert({
     *   create: {
     *     // ... data to create a RechargeAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RechargeAccount we want to update
     *   }
     * })
    **/
    upsert<T extends RechargeAccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RechargeAccountUpsertArgs<ExtArgs>>
    ): Prisma__RechargeAccountClient<$Result.GetResult<Prisma.$RechargeAccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RechargeAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeAccountCountArgs} args - Arguments to filter RechargeAccounts to count.
     * @example
     * // Count the number of RechargeAccounts
     * const count = await prisma.rechargeAccount.count({
     *   where: {
     *     // ... the filter for the RechargeAccounts we want to count
     *   }
     * })
    **/
    count<T extends RechargeAccountCountArgs>(
      args?: Subset<T, RechargeAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RechargeAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RechargeAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RechargeAccountAggregateArgs>(args: Subset<T, RechargeAccountAggregateArgs>): Prisma.PrismaPromise<GetRechargeAccountAggregateType<T>>

    /**
     * Group by RechargeAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargeAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RechargeAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RechargeAccountGroupByArgs['orderBy'] }
        : { orderBy?: RechargeAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RechargeAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRechargeAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RechargeAccount model
   */
  readonly fields: RechargeAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RechargeAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RechargeAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RechargeAccount model
   */ 
  interface RechargeAccountFieldRefs {
    readonly id: FieldRef<"RechargeAccount", 'BigInt'>
    readonly account: FieldRef<"RechargeAccount", 'String'>
    readonly accountAddress: FieldRef<"RechargeAccount", 'String'>
    readonly currency: FieldRef<"RechargeAccount", 'String'>
    readonly max: FieldRef<"RechargeAccount", 'Decimal'>
    readonly min: FieldRef<"RechargeAccount", 'Decimal'>
    readonly status: FieldRef<"RechargeAccount", 'Int'>
    readonly createdAt: FieldRef<"RechargeAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"RechargeAccount", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * RechargeAccount findUnique
   */
  export type RechargeAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
    /**
     * Filter, which RechargeAccount to fetch.
     */
    where: RechargeAccountWhereUniqueInput
  }


  /**
   * RechargeAccount findUniqueOrThrow
   */
  export type RechargeAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
    /**
     * Filter, which RechargeAccount to fetch.
     */
    where: RechargeAccountWhereUniqueInput
  }


  /**
   * RechargeAccount findFirst
   */
  export type RechargeAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
    /**
     * Filter, which RechargeAccount to fetch.
     */
    where?: RechargeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargeAccounts to fetch.
     */
    orderBy?: RechargeAccountOrderByWithRelationInput | RechargeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RechargeAccounts.
     */
    cursor?: RechargeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargeAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RechargeAccounts.
     */
    distinct?: RechargeAccountScalarFieldEnum | RechargeAccountScalarFieldEnum[]
  }


  /**
   * RechargeAccount findFirstOrThrow
   */
  export type RechargeAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
    /**
     * Filter, which RechargeAccount to fetch.
     */
    where?: RechargeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargeAccounts to fetch.
     */
    orderBy?: RechargeAccountOrderByWithRelationInput | RechargeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RechargeAccounts.
     */
    cursor?: RechargeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargeAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RechargeAccounts.
     */
    distinct?: RechargeAccountScalarFieldEnum | RechargeAccountScalarFieldEnum[]
  }


  /**
   * RechargeAccount findMany
   */
  export type RechargeAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
    /**
     * Filter, which RechargeAccounts to fetch.
     */
    where?: RechargeAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RechargeAccounts to fetch.
     */
    orderBy?: RechargeAccountOrderByWithRelationInput | RechargeAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RechargeAccounts.
     */
    cursor?: RechargeAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RechargeAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RechargeAccounts.
     */
    skip?: number
    distinct?: RechargeAccountScalarFieldEnum | RechargeAccountScalarFieldEnum[]
  }


  /**
   * RechargeAccount create
   */
  export type RechargeAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
    /**
     * The data needed to create a RechargeAccount.
     */
    data: XOR<RechargeAccountCreateInput, RechargeAccountUncheckedCreateInput>
  }


  /**
   * RechargeAccount createMany
   */
  export type RechargeAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RechargeAccounts.
     */
    data: RechargeAccountCreateManyInput | RechargeAccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RechargeAccount update
   */
  export type RechargeAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
    /**
     * The data needed to update a RechargeAccount.
     */
    data: XOR<RechargeAccountUpdateInput, RechargeAccountUncheckedUpdateInput>
    /**
     * Choose, which RechargeAccount to update.
     */
    where: RechargeAccountWhereUniqueInput
  }


  /**
   * RechargeAccount updateMany
   */
  export type RechargeAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RechargeAccounts.
     */
    data: XOR<RechargeAccountUpdateManyMutationInput, RechargeAccountUncheckedUpdateManyInput>
    /**
     * Filter which RechargeAccounts to update
     */
    where?: RechargeAccountWhereInput
  }


  /**
   * RechargeAccount upsert
   */
  export type RechargeAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
    /**
     * The filter to search for the RechargeAccount to update in case it exists.
     */
    where: RechargeAccountWhereUniqueInput
    /**
     * In case the RechargeAccount found by the `where` argument doesn't exist, create a new RechargeAccount with this data.
     */
    create: XOR<RechargeAccountCreateInput, RechargeAccountUncheckedCreateInput>
    /**
     * In case the RechargeAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RechargeAccountUpdateInput, RechargeAccountUncheckedUpdateInput>
  }


  /**
   * RechargeAccount delete
   */
  export type RechargeAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
    /**
     * Filter which RechargeAccount to delete.
     */
    where: RechargeAccountWhereUniqueInput
  }


  /**
   * RechargeAccount deleteMany
   */
  export type RechargeAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RechargeAccounts to delete
     */
    where?: RechargeAccountWhereInput
  }


  /**
   * RechargeAccount without action
   */
  export type RechargeAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RechargeAccount
     */
    select?: RechargeAccountSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    password: 'password',
    gender: 'gender',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    password: 'password',
    gender: 'gender',
    address: 'address',
    accountBalance: 'accountBalance',
    status: 'status',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    balance: 'balance',
    unBalance: 'unBalance',
    lockBalance: 'lockBalance',
    lastLoginTime: 'lastLoginTime'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const MemberRechargeScalarFieldEnum: {
    id: 'id',
    money: 'money',
    rechargeMoney: 'rechargeMoney',
    screen: 'screen',
    market: 'market',
    status: 'status',
    memberId: 'memberId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberRechargeScalarFieldEnum = (typeof MemberRechargeScalarFieldEnum)[keyof typeof MemberRechargeScalarFieldEnum]


  export const MemberWithdrawScalarFieldEnum: {
    id: 'id',
    money: 'money',
    remark: 'remark',
    status: 'status',
    address: 'address',
    market: 'market',
    memberId: 'memberId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberWithdrawScalarFieldEnum = (typeof MemberWithdrawScalarFieldEnum)[keyof typeof MemberWithdrawScalarFieldEnum]


  export const StockSymbolScalarFieldEnum: {
    id: 'id',
    code: 'code',
    cat: 'cat',
    market: 'market',
    online: 'online',
    symbol: 'symbol',
    showName: 'showName',
    name: 'name',
    symbolShowName: 'symbolShowName',
    trade: 'trade',
    type: 'type',
    newPrice: 'newPrice',
    open: 'open',
    close: 'close',
    high: 'high',
    low: 'low',
    amount: 'amount',
    volume: 'volume',
    change: 'change',
    changePercent: 'changePercent',
    date: 'date',
    sync: 'sync',
    syncMarket: 'syncMarket',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockSymbolScalarFieldEnum = (typeof StockSymbolScalarFieldEnum)[keyof typeof StockSymbolScalarFieldEnum]


  export const StockScalarFieldEnum: {
    id: 'id',
    code: 'code',
    symbol: 'symbol',
    name: 'name',
    cname: 'cname',
    type: 'type',
    logo: 'logo',
    sok: 'sok',
    optional: 'optional',
    newPrice: 'newPrice',
    open: 'open',
    close: 'close',
    high: 'high',
    low: 'low',
    amount: 'amount',
    volume: 'volume',
    status: 'status',
    change: 'change',
    changePercent: 'changePercent',
    date: 'date',
    extra: 'extra',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const StockRecordScalarFieldEnum: {
    id: 'id',
    newPrice: 'newPrice',
    open: 'open',
    close: 'close',
    high: 'high',
    low: 'low',
    amount: 'amount',
    volume: 'volume',
    date: 'date',
    extra: 'extra',
    createdAt: 'createdAt',
    stockId: 'stockId'
  };

  export type StockRecordScalarFieldEnum = (typeof StockRecordScalarFieldEnum)[keyof typeof StockRecordScalarFieldEnum]


  export const StockMarketScalarFieldEnum: {
    id: 'id',
    code: 'code',
    currency: 'currency',
    showName: 'showName',
    maxWithdrawal: 'maxWithdrawal',
    minWithdrawal: 'minWithdrawal',
    feeRate: 'feeRate',
    minFee: 'minFee',
    lever: 'lever',
    mmr: 'mmr',
    allocationRate: 'allocationRate',
    frequency: 'frequency',
    bindingHours: 'bindingHours',
    headSymbols: 'headSymbols',
    sort: 'sort',
    online: 'online',
    conline: 'conline',
    openTime: 'openTime',
    timezone: 'timezone',
    beforeTime: 'beforeTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockMarketScalarFieldEnum = (typeof StockMarketScalarFieldEnum)[keyof typeof StockMarketScalarFieldEnum]


  export const StockFavoriteScalarFieldEnum: {
    id: 'id',
    newPrice: 'newPrice',
    open: 'open',
    close: 'close',
    high: 'high',
    low: 'low',
    amount: 'amount',
    volume: 'volume',
    date: 'date',
    extra: 'extra',
    memberId: 'memberId',
    stockSymbolId: 'stockSymbolId',
    createdAt: 'createdAt'
  };

  export type StockFavoriteScalarFieldEnum = (typeof StockFavoriteScalarFieldEnum)[keyof typeof StockFavoriteScalarFieldEnum]


  export const StockSubscribeScalarFieldEnum: {
    id: 'id',
    market: 'market',
    name: 'name',
    code: 'code',
    startAt: 'startAt',
    endAt: 'endAt',
    upAt: 'upAt',
    circulation: 'circulation',
    remainCirculation: 'remainCirculation',
    ipoPrice: 'ipoPrice',
    issuePrice: 'issuePrice',
    resultAt: 'resultAt',
    subAmount: 'subAmount',
    status: 'status',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockSubscribeScalarFieldEnum = (typeof StockSubscribeScalarFieldEnum)[keyof typeof StockSubscribeScalarFieldEnum]


  export const MemberSubscribeScalarFieldEnum: {
    id: 'id',
    market: 'market',
    code: 'code',
    name: 'name',
    amount: 'amount',
    money: 'money',
    no: 'no',
    winningAmount: 'winningAmount',
    winningPrice: 'winningPrice',
    totalWinningPrice: 'totalWinningPrice',
    actualAmount: 'actualAmount',
    status: 'status',
    type: 'type',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    stockSubscribeId: 'stockSubscribeId',
    memberId: 'memberId'
  };

  export type MemberSubscribeScalarFieldEnum = (typeof MemberSubscribeScalarFieldEnum)[keyof typeof MemberSubscribeScalarFieldEnum]


  export const StockPositionScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    blast: 'blast',
    price: 'price',
    mode: 'mode',
    status: 'status',
    bond: 'bond',
    identifier: 'identifier',
    lever: 'lever',
    stopLoss: 'stopLoss',
    takeProfit: 'takeProfit',
    market: 'market',
    type: 'type',
    pl: 'pl',
    rate: 'rate',
    isBefore: 'isBefore',
    currentPrice: 'currentPrice',
    memberId: 'memberId',
    stockSymbolId: 'stockSymbolId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockPositionScalarFieldEnum = (typeof StockPositionScalarFieldEnum)[keyof typeof StockPositionScalarFieldEnum]


  export const MemberDetailScalarFieldEnum: {
    id: 'id',
    after: 'after',
    amount: 'amount',
    before: 'before',
    market: 'market',
    type: 'type',
    remark: 'remark',
    memberId: 'memberId'
  };

  export type MemberDetailScalarFieldEnum = (typeof MemberDetailScalarFieldEnum)[keyof typeof MemberDetailScalarFieldEnum]


  export const MemberCardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    detail: 'detail',
    memberId: 'memberId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberCardScalarFieldEnum = (typeof MemberCardScalarFieldEnum)[keyof typeof MemberCardScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    en: 'en',
    tel: 'tel',
    py: 'py',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const StockResourceScalarFieldEnum: {
    id: 'id',
    amountScope: 'amountScope',
    frequencyScope: 'frequencyScope',
    market: 'market',
    spreadScope: 'spreadScope',
    endAt: 'endAt',
    startAt: 'startAt',
    symbol: 'symbol',
    type: 'type',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockResourceScalarFieldEnum = (typeof StockResourceScalarFieldEnum)[keyof typeof StockResourceScalarFieldEnum]


  export const StockResourceRecordScalarFieldEnum: {
    id: 'id',
    open: 'open',
    high: 'high',
    close: 'close',
    low: 'low',
    time: 'time',
    stockResourceId: 'stockResourceId'
  };

  export type StockResourceRecordScalarFieldEnum = (typeof StockResourceRecordScalarFieldEnum)[keyof typeof StockResourceRecordScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    thumb: 'thumb',
    title: 'title',
    market: 'market',
    crawlerThumb: 'crawlerThumb',
    source: 'source',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const RechargeScalarFieldEnum: {
    id: 'id',
    market: 'market',
    money: 'money',
    type: 'type',
    account: 'account',
    accountNetwork: 'accountNetwork',
    screens: 'screens',
    status: 'status',
    passMoney: 'passMoney',
    convertMoney: 'convertMoney',
    memberId: 'memberId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RechargeScalarFieldEnum = (typeof RechargeScalarFieldEnum)[keyof typeof RechargeScalarFieldEnum]


  export const WithdrawScalarFieldEnum: {
    id: 'id',
    market: 'market',
    money: 'money',
    type: 'type',
    currency: 'currency',
    cryptoType: 'cryptoType',
    cryptoNetwork: 'cryptoNetwork',
    card: 'card',
    convertMoney: 'convertMoney',
    status: 'status',
    memberId: 'memberId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WithdrawScalarFieldEnum = (typeof WithdrawScalarFieldEnum)[keyof typeof WithdrawScalarFieldEnum]


  export const RechargeAccountScalarFieldEnum: {
    id: 'id',
    account: 'account',
    accountAddress: 'accountAddress',
    currency: 'currency',
    max: 'max',
    min: 'min',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RechargeAccountScalarFieldEnum = (typeof RechargeAccountScalarFieldEnum)[keyof typeof RechargeAccountScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'GENDER'
   */
  export type EnumGENDERFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GENDER'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'STOCK_STATUS'
   */
  export type EnumSTOCK_STATUSFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'STOCK_STATUS'>
    


  /**
   * Reference to a field of type 'RechargeType'
   */
  export type EnumRechargeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RechargeType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: BigIntFilter<"User"> | bigint | number
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    gender?: EnumGENDERFilter<"User"> | $Enums.GENDER
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    password?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    gender?: EnumGENDERFilter<"User"> | $Enums.GENDER
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    password?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"User"> | bigint | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    gender?: EnumGENDERWithAggregatesFilter<"User"> | $Enums.GENDER
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: BigIntFilter<"Member"> | bigint | number
    email?: StringFilter<"Member"> | string
    name?: StringNullableFilter<"Member"> | string | null
    avatar?: StringNullableFilter<"Member"> | string | null
    password?: StringFilter<"Member"> | string
    gender?: EnumGENDERFilter<"Member"> | $Enums.GENDER
    address?: StringNullableFilter<"Member"> | string | null
    accountBalance?: JsonNullableFilter<"Member">
    status?: IntFilter<"Member"> | number
    type?: IntFilter<"Member"> | number
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    balance?: DecimalFilter<"Member"> | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFilter<"Member"> | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFilter<"Member"> | Decimal | DecimalJsLike | number | string
    lastLoginTime?: DateTimeNullableFilter<"Member"> | Date | string | null
    stockPostion?: StockPositionListRelationFilter
    memberDetail?: MemberDetailListRelationFilter
    memberSubscribe?: MemberSubscribeListRelationFilter
    memberRecharges?: MemberRechargeListRelationFilter
    memberWithdraws?: MemberWithdrawListRelationFilter
    memberCards?: MemberCardListRelationFilter
    recharges?: RechargeListRelationFilter
    withdraws?: WithdrawListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    password?: SortOrder
    gender?: SortOrder
    address?: SortOrderInput | SortOrder
    accountBalance?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    balance?: SortOrder
    unBalance?: SortOrder
    lockBalance?: SortOrder
    lastLoginTime?: SortOrderInput | SortOrder
    stockPostion?: StockPositionOrderByRelationAggregateInput
    memberDetail?: MemberDetailOrderByRelationAggregateInput
    memberSubscribe?: MemberSubscribeOrderByRelationAggregateInput
    memberRecharges?: MemberRechargeOrderByRelationAggregateInput
    memberWithdraws?: MemberWithdrawOrderByRelationAggregateInput
    memberCards?: MemberCardOrderByRelationAggregateInput
    recharges?: RechargeOrderByRelationAggregateInput
    withdraws?: WithdrawOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    name?: StringNullableFilter<"Member"> | string | null
    avatar?: StringNullableFilter<"Member"> | string | null
    password?: StringFilter<"Member"> | string
    gender?: EnumGENDERFilter<"Member"> | $Enums.GENDER
    address?: StringNullableFilter<"Member"> | string | null
    accountBalance?: JsonNullableFilter<"Member">
    status?: IntFilter<"Member"> | number
    type?: IntFilter<"Member"> | number
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Member"> | Date | string | null
    balance?: DecimalFilter<"Member"> | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFilter<"Member"> | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFilter<"Member"> | Decimal | DecimalJsLike | number | string
    lastLoginTime?: DateTimeNullableFilter<"Member"> | Date | string | null
    stockPostion?: StockPositionListRelationFilter
    memberDetail?: MemberDetailListRelationFilter
    memberSubscribe?: MemberSubscribeListRelationFilter
    memberRecharges?: MemberRechargeListRelationFilter
    memberWithdraws?: MemberWithdrawListRelationFilter
    memberCards?: MemberCardListRelationFilter
    recharges?: RechargeListRelationFilter
    withdraws?: WithdrawListRelationFilter
  }, "id" | "email">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    password?: SortOrder
    gender?: SortOrder
    address?: SortOrderInput | SortOrder
    accountBalance?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    balance?: SortOrder
    unBalance?: SortOrder
    lockBalance?: SortOrder
    lastLoginTime?: SortOrderInput | SortOrder
    _count?: MemberCountOrderByAggregateInput
    _avg?: MemberAvgOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
    _sum?: MemberSumOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Member"> | bigint | number
    email?: StringWithAggregatesFilter<"Member"> | string
    name?: StringNullableWithAggregatesFilter<"Member"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Member"> | string | null
    password?: StringWithAggregatesFilter<"Member"> | string
    gender?: EnumGENDERWithAggregatesFilter<"Member"> | $Enums.GENDER
    address?: StringNullableWithAggregatesFilter<"Member"> | string | null
    accountBalance?: JsonNullableWithAggregatesFilter<"Member">
    status?: IntWithAggregatesFilter<"Member"> | number
    type?: IntWithAggregatesFilter<"Member"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
    balance?: DecimalWithAggregatesFilter<"Member"> | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalWithAggregatesFilter<"Member"> | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalWithAggregatesFilter<"Member"> | Decimal | DecimalJsLike | number | string
    lastLoginTime?: DateTimeNullableWithAggregatesFilter<"Member"> | Date | string | null
  }

  export type MemberRechargeWhereInput = {
    AND?: MemberRechargeWhereInput | MemberRechargeWhereInput[]
    OR?: MemberRechargeWhereInput[]
    NOT?: MemberRechargeWhereInput | MemberRechargeWhereInput[]
    id?: BigIntFilter<"MemberRecharge"> | bigint | number
    money?: DecimalFilter<"MemberRecharge"> | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFilter<"MemberRecharge"> | Decimal | DecimalJsLike | number | string
    screen?: JsonFilter<"MemberRecharge">
    market?: StringFilter<"MemberRecharge"> | string
    status?: IntFilter<"MemberRecharge"> | number
    memberId?: BigIntFilter<"MemberRecharge"> | bigint | number
    createdAt?: DateTimeFilter<"MemberRecharge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberRecharge"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }

  export type MemberRechargeOrderByWithRelationInput = {
    id?: SortOrder
    money?: SortOrder
    rechargeMoney?: SortOrder
    screen?: SortOrder
    market?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type MemberRechargeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MemberRechargeWhereInput | MemberRechargeWhereInput[]
    OR?: MemberRechargeWhereInput[]
    NOT?: MemberRechargeWhereInput | MemberRechargeWhereInput[]
    money?: DecimalFilter<"MemberRecharge"> | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFilter<"MemberRecharge"> | Decimal | DecimalJsLike | number | string
    screen?: JsonFilter<"MemberRecharge">
    market?: StringFilter<"MemberRecharge"> | string
    status?: IntFilter<"MemberRecharge"> | number
    memberId?: BigIntFilter<"MemberRecharge"> | bigint | number
    createdAt?: DateTimeFilter<"MemberRecharge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberRecharge"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }, "id">

  export type MemberRechargeOrderByWithAggregationInput = {
    id?: SortOrder
    money?: SortOrder
    rechargeMoney?: SortOrder
    screen?: SortOrder
    market?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberRechargeCountOrderByAggregateInput
    _avg?: MemberRechargeAvgOrderByAggregateInput
    _max?: MemberRechargeMaxOrderByAggregateInput
    _min?: MemberRechargeMinOrderByAggregateInput
    _sum?: MemberRechargeSumOrderByAggregateInput
  }

  export type MemberRechargeScalarWhereWithAggregatesInput = {
    AND?: MemberRechargeScalarWhereWithAggregatesInput | MemberRechargeScalarWhereWithAggregatesInput[]
    OR?: MemberRechargeScalarWhereWithAggregatesInput[]
    NOT?: MemberRechargeScalarWhereWithAggregatesInput | MemberRechargeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"MemberRecharge"> | bigint | number
    money?: DecimalWithAggregatesFilter<"MemberRecharge"> | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalWithAggregatesFilter<"MemberRecharge"> | Decimal | DecimalJsLike | number | string
    screen?: JsonWithAggregatesFilter<"MemberRecharge">
    market?: StringWithAggregatesFilter<"MemberRecharge"> | string
    status?: IntWithAggregatesFilter<"MemberRecharge"> | number
    memberId?: BigIntWithAggregatesFilter<"MemberRecharge"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"MemberRecharge"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberRecharge"> | Date | string | null
  }

  export type MemberWithdrawWhereInput = {
    AND?: MemberWithdrawWhereInput | MemberWithdrawWhereInput[]
    OR?: MemberWithdrawWhereInput[]
    NOT?: MemberWithdrawWhereInput | MemberWithdrawWhereInput[]
    id?: BigIntFilter<"MemberWithdraw"> | bigint | number
    money?: DecimalFilter<"MemberWithdraw"> | Decimal | DecimalJsLike | number | string
    remark?: StringNullableFilter<"MemberWithdraw"> | string | null
    status?: IntFilter<"MemberWithdraw"> | number
    address?: StringNullableFilter<"MemberWithdraw"> | string | null
    market?: StringFilter<"MemberWithdraw"> | string
    memberId?: BigIntFilter<"MemberWithdraw"> | bigint | number
    createdAt?: DateTimeFilter<"MemberWithdraw"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberWithdraw"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }

  export type MemberWithdrawOrderByWithRelationInput = {
    id?: SortOrder
    money?: SortOrder
    remark?: SortOrderInput | SortOrder
    status?: SortOrder
    address?: SortOrderInput | SortOrder
    market?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type MemberWithdrawWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MemberWithdrawWhereInput | MemberWithdrawWhereInput[]
    OR?: MemberWithdrawWhereInput[]
    NOT?: MemberWithdrawWhereInput | MemberWithdrawWhereInput[]
    money?: DecimalFilter<"MemberWithdraw"> | Decimal | DecimalJsLike | number | string
    remark?: StringNullableFilter<"MemberWithdraw"> | string | null
    status?: IntFilter<"MemberWithdraw"> | number
    address?: StringNullableFilter<"MemberWithdraw"> | string | null
    market?: StringFilter<"MemberWithdraw"> | string
    memberId?: BigIntFilter<"MemberWithdraw"> | bigint | number
    createdAt?: DateTimeFilter<"MemberWithdraw"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberWithdraw"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }, "id">

  export type MemberWithdrawOrderByWithAggregationInput = {
    id?: SortOrder
    money?: SortOrder
    remark?: SortOrderInput | SortOrder
    status?: SortOrder
    address?: SortOrderInput | SortOrder
    market?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberWithdrawCountOrderByAggregateInput
    _avg?: MemberWithdrawAvgOrderByAggregateInput
    _max?: MemberWithdrawMaxOrderByAggregateInput
    _min?: MemberWithdrawMinOrderByAggregateInput
    _sum?: MemberWithdrawSumOrderByAggregateInput
  }

  export type MemberWithdrawScalarWhereWithAggregatesInput = {
    AND?: MemberWithdrawScalarWhereWithAggregatesInput | MemberWithdrawScalarWhereWithAggregatesInput[]
    OR?: MemberWithdrawScalarWhereWithAggregatesInput[]
    NOT?: MemberWithdrawScalarWhereWithAggregatesInput | MemberWithdrawScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"MemberWithdraw"> | bigint | number
    money?: DecimalWithAggregatesFilter<"MemberWithdraw"> | Decimal | DecimalJsLike | number | string
    remark?: StringNullableWithAggregatesFilter<"MemberWithdraw"> | string | null
    status?: IntWithAggregatesFilter<"MemberWithdraw"> | number
    address?: StringNullableWithAggregatesFilter<"MemberWithdraw"> | string | null
    market?: StringWithAggregatesFilter<"MemberWithdraw"> | string
    memberId?: BigIntWithAggregatesFilter<"MemberWithdraw"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"MemberWithdraw"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberWithdraw"> | Date | string | null
  }

  export type StockSymbolWhereInput = {
    AND?: StockSymbolWhereInput | StockSymbolWhereInput[]
    OR?: StockSymbolWhereInput[]
    NOT?: StockSymbolWhereInput | StockSymbolWhereInput[]
    id?: BigIntFilter<"StockSymbol"> | bigint | number
    code?: StringFilter<"StockSymbol"> | string
    cat?: StringNullableFilter<"StockSymbol"> | string | null
    market?: StringFilter<"StockSymbol"> | string
    online?: IntFilter<"StockSymbol"> | number
    symbol?: StringFilter<"StockSymbol"> | string
    showName?: StringFilter<"StockSymbol"> | string
    name?: StringNullableFilter<"StockSymbol"> | string | null
    symbolShowName?: StringNullableFilter<"StockSymbol"> | string | null
    trade?: IntFilter<"StockSymbol"> | number
    type?: IntFilter<"StockSymbol"> | number
    newPrice?: StringNullableFilter<"StockSymbol"> | string | null
    open?: StringNullableFilter<"StockSymbol"> | string | null
    close?: StringNullableFilter<"StockSymbol"> | string | null
    high?: StringNullableFilter<"StockSymbol"> | string | null
    low?: StringNullableFilter<"StockSymbol"> | string | null
    amount?: StringNullableFilter<"StockSymbol"> | string | null
    volume?: StringNullableFilter<"StockSymbol"> | string | null
    change?: StringNullableFilter<"StockSymbol"> | string | null
    changePercent?: StringNullableFilter<"StockSymbol"> | string | null
    date?: StringNullableFilter<"StockSymbol"> | string | null
    sync?: JsonNullableFilter<"StockSymbol">
    syncMarket?: StringFilter<"StockSymbol"> | string
    createdAt?: DateTimeFilter<"StockSymbol"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockSymbol"> | Date | string | null
    stockPostion?: StockPositionListRelationFilter
  }

  export type StockSymbolOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    cat?: SortOrderInput | SortOrder
    market?: SortOrder
    online?: SortOrder
    symbol?: SortOrder
    showName?: SortOrder
    name?: SortOrderInput | SortOrder
    symbolShowName?: SortOrderInput | SortOrder
    trade?: SortOrder
    type?: SortOrder
    newPrice?: SortOrderInput | SortOrder
    open?: SortOrderInput | SortOrder
    close?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    change?: SortOrderInput | SortOrder
    changePercent?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    sync?: SortOrderInput | SortOrder
    syncMarket?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    stockPostion?: StockPositionOrderByRelationAggregateInput
  }

  export type StockSymbolWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    symbol_market?: StockSymbolSymbolMarketCompoundUniqueInput
    AND?: StockSymbolWhereInput | StockSymbolWhereInput[]
    OR?: StockSymbolWhereInput[]
    NOT?: StockSymbolWhereInput | StockSymbolWhereInput[]
    code?: StringFilter<"StockSymbol"> | string
    cat?: StringNullableFilter<"StockSymbol"> | string | null
    market?: StringFilter<"StockSymbol"> | string
    online?: IntFilter<"StockSymbol"> | number
    symbol?: StringFilter<"StockSymbol"> | string
    showName?: StringFilter<"StockSymbol"> | string
    name?: StringNullableFilter<"StockSymbol"> | string | null
    symbolShowName?: StringNullableFilter<"StockSymbol"> | string | null
    trade?: IntFilter<"StockSymbol"> | number
    type?: IntFilter<"StockSymbol"> | number
    newPrice?: StringNullableFilter<"StockSymbol"> | string | null
    open?: StringNullableFilter<"StockSymbol"> | string | null
    close?: StringNullableFilter<"StockSymbol"> | string | null
    high?: StringNullableFilter<"StockSymbol"> | string | null
    low?: StringNullableFilter<"StockSymbol"> | string | null
    amount?: StringNullableFilter<"StockSymbol"> | string | null
    volume?: StringNullableFilter<"StockSymbol"> | string | null
    change?: StringNullableFilter<"StockSymbol"> | string | null
    changePercent?: StringNullableFilter<"StockSymbol"> | string | null
    date?: StringNullableFilter<"StockSymbol"> | string | null
    sync?: JsonNullableFilter<"StockSymbol">
    syncMarket?: StringFilter<"StockSymbol"> | string
    createdAt?: DateTimeFilter<"StockSymbol"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockSymbol"> | Date | string | null
    stockPostion?: StockPositionListRelationFilter
  }, "id" | "symbol_market">

  export type StockSymbolOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    cat?: SortOrderInput | SortOrder
    market?: SortOrder
    online?: SortOrder
    symbol?: SortOrder
    showName?: SortOrder
    name?: SortOrderInput | SortOrder
    symbolShowName?: SortOrderInput | SortOrder
    trade?: SortOrder
    type?: SortOrder
    newPrice?: SortOrderInput | SortOrder
    open?: SortOrderInput | SortOrder
    close?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    change?: SortOrderInput | SortOrder
    changePercent?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    sync?: SortOrderInput | SortOrder
    syncMarket?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StockSymbolCountOrderByAggregateInput
    _avg?: StockSymbolAvgOrderByAggregateInput
    _max?: StockSymbolMaxOrderByAggregateInput
    _min?: StockSymbolMinOrderByAggregateInput
    _sum?: StockSymbolSumOrderByAggregateInput
  }

  export type StockSymbolScalarWhereWithAggregatesInput = {
    AND?: StockSymbolScalarWhereWithAggregatesInput | StockSymbolScalarWhereWithAggregatesInput[]
    OR?: StockSymbolScalarWhereWithAggregatesInput[]
    NOT?: StockSymbolScalarWhereWithAggregatesInput | StockSymbolScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"StockSymbol"> | bigint | number
    code?: StringWithAggregatesFilter<"StockSymbol"> | string
    cat?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    market?: StringWithAggregatesFilter<"StockSymbol"> | string
    online?: IntWithAggregatesFilter<"StockSymbol"> | number
    symbol?: StringWithAggregatesFilter<"StockSymbol"> | string
    showName?: StringWithAggregatesFilter<"StockSymbol"> | string
    name?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    symbolShowName?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    trade?: IntWithAggregatesFilter<"StockSymbol"> | number
    type?: IntWithAggregatesFilter<"StockSymbol"> | number
    newPrice?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    open?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    close?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    high?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    low?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    amount?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    volume?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    change?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    changePercent?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    date?: StringNullableWithAggregatesFilter<"StockSymbol"> | string | null
    sync?: JsonNullableWithAggregatesFilter<"StockSymbol">
    syncMarket?: StringWithAggregatesFilter<"StockSymbol"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StockSymbol"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"StockSymbol"> | Date | string | null
  }

  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    id?: BigIntFilter<"Stock"> | bigint | number
    code?: StringFilter<"Stock"> | string
    symbol?: StringFilter<"Stock"> | string
    name?: StringFilter<"Stock"> | string
    cname?: StringNullableFilter<"Stock"> | string | null
    type?: StringFilter<"Stock"> | string
    logo?: StringNullableFilter<"Stock"> | string | null
    sok?: StringNullableFilter<"Stock"> | string | null
    optional?: BoolFilter<"Stock"> | boolean
    newPrice?: StringNullableFilter<"Stock"> | string | null
    open?: StringNullableFilter<"Stock"> | string | null
    close?: StringNullableFilter<"Stock"> | string | null
    high?: StringNullableFilter<"Stock"> | string | null
    low?: StringNullableFilter<"Stock"> | string | null
    amount?: StringNullableFilter<"Stock"> | string | null
    volume?: StringNullableFilter<"Stock"> | string | null
    status?: EnumSTOCK_STATUSFilter<"Stock"> | $Enums.STOCK_STATUS
    change?: StringNullableFilter<"Stock"> | string | null
    changePercent?: StringNullableFilter<"Stock"> | string | null
    date?: StringNullableFilter<"Stock"> | string | null
    extra?: JsonNullableFilter<"Stock">
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Stock"> | Date | string | null
    stockRecord?: StockRecordListRelationFilter
  }

  export type StockOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    cname?: SortOrderInput | SortOrder
    type?: SortOrder
    logo?: SortOrderInput | SortOrder
    sok?: SortOrderInput | SortOrder
    optional?: SortOrder
    newPrice?: SortOrderInput | SortOrder
    open?: SortOrderInput | SortOrder
    close?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    status?: SortOrder
    change?: SortOrderInput | SortOrder
    changePercent?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    stockRecord?: StockRecordOrderByRelationAggregateInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    code_symbol_type?: StockCodeSymbolTypeCompoundUniqueInput
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    code?: StringFilter<"Stock"> | string
    symbol?: StringFilter<"Stock"> | string
    name?: StringFilter<"Stock"> | string
    cname?: StringNullableFilter<"Stock"> | string | null
    type?: StringFilter<"Stock"> | string
    logo?: StringNullableFilter<"Stock"> | string | null
    sok?: StringNullableFilter<"Stock"> | string | null
    optional?: BoolFilter<"Stock"> | boolean
    newPrice?: StringNullableFilter<"Stock"> | string | null
    open?: StringNullableFilter<"Stock"> | string | null
    close?: StringNullableFilter<"Stock"> | string | null
    high?: StringNullableFilter<"Stock"> | string | null
    low?: StringNullableFilter<"Stock"> | string | null
    amount?: StringNullableFilter<"Stock"> | string | null
    volume?: StringNullableFilter<"Stock"> | string | null
    status?: EnumSTOCK_STATUSFilter<"Stock"> | $Enums.STOCK_STATUS
    change?: StringNullableFilter<"Stock"> | string | null
    changePercent?: StringNullableFilter<"Stock"> | string | null
    date?: StringNullableFilter<"Stock"> | string | null
    extra?: JsonNullableFilter<"Stock">
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Stock"> | Date | string | null
    stockRecord?: StockRecordListRelationFilter
  }, "id" | "code_symbol_type">

  export type StockOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    cname?: SortOrderInput | SortOrder
    type?: SortOrder
    logo?: SortOrderInput | SortOrder
    sok?: SortOrderInput | SortOrder
    optional?: SortOrder
    newPrice?: SortOrderInput | SortOrder
    open?: SortOrderInput | SortOrder
    close?: SortOrderInput | SortOrder
    high?: SortOrderInput | SortOrder
    low?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    status?: SortOrder
    change?: SortOrderInput | SortOrder
    changePercent?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Stock"> | bigint | number
    code?: StringWithAggregatesFilter<"Stock"> | string
    symbol?: StringWithAggregatesFilter<"Stock"> | string
    name?: StringWithAggregatesFilter<"Stock"> | string
    cname?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    type?: StringWithAggregatesFilter<"Stock"> | string
    logo?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    sok?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    optional?: BoolWithAggregatesFilter<"Stock"> | boolean
    newPrice?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    open?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    close?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    high?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    low?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    amount?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    volume?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    status?: EnumSTOCK_STATUSWithAggregatesFilter<"Stock"> | $Enums.STOCK_STATUS
    change?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    changePercent?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    date?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"Stock">
    createdAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Stock"> | Date | string | null
  }

  export type StockRecordWhereInput = {
    AND?: StockRecordWhereInput | StockRecordWhereInput[]
    OR?: StockRecordWhereInput[]
    NOT?: StockRecordWhereInput | StockRecordWhereInput[]
    id?: BigIntFilter<"StockRecord"> | bigint | number
    newPrice?: StringFilter<"StockRecord"> | string
    open?: StringFilter<"StockRecord"> | string
    close?: StringFilter<"StockRecord"> | string
    high?: StringFilter<"StockRecord"> | string
    low?: StringFilter<"StockRecord"> | string
    amount?: StringFilter<"StockRecord"> | string
    volume?: StringFilter<"StockRecord"> | string
    date?: StringFilter<"StockRecord"> | string
    extra?: JsonFilter<"StockRecord">
    createdAt?: DateTimeFilter<"StockRecord"> | Date | string
    stockId?: BigIntFilter<"StockRecord"> | bigint | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
  }

  export type StockRecordOrderByWithRelationInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    stockId?: SortOrder
    stock?: StockOrderByWithRelationInput
  }

  export type StockRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: StockRecordWhereInput | StockRecordWhereInput[]
    OR?: StockRecordWhereInput[]
    NOT?: StockRecordWhereInput | StockRecordWhereInput[]
    newPrice?: StringFilter<"StockRecord"> | string
    open?: StringFilter<"StockRecord"> | string
    close?: StringFilter<"StockRecord"> | string
    high?: StringFilter<"StockRecord"> | string
    low?: StringFilter<"StockRecord"> | string
    amount?: StringFilter<"StockRecord"> | string
    volume?: StringFilter<"StockRecord"> | string
    date?: StringFilter<"StockRecord"> | string
    extra?: JsonFilter<"StockRecord">
    createdAt?: DateTimeFilter<"StockRecord"> | Date | string
    stockId?: BigIntFilter<"StockRecord"> | bigint | number
    stock?: XOR<StockRelationFilter, StockWhereInput>
  }, "id">

  export type StockRecordOrderByWithAggregationInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    stockId?: SortOrder
    _count?: StockRecordCountOrderByAggregateInput
    _avg?: StockRecordAvgOrderByAggregateInput
    _max?: StockRecordMaxOrderByAggregateInput
    _min?: StockRecordMinOrderByAggregateInput
    _sum?: StockRecordSumOrderByAggregateInput
  }

  export type StockRecordScalarWhereWithAggregatesInput = {
    AND?: StockRecordScalarWhereWithAggregatesInput | StockRecordScalarWhereWithAggregatesInput[]
    OR?: StockRecordScalarWhereWithAggregatesInput[]
    NOT?: StockRecordScalarWhereWithAggregatesInput | StockRecordScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"StockRecord"> | bigint | number
    newPrice?: StringWithAggregatesFilter<"StockRecord"> | string
    open?: StringWithAggregatesFilter<"StockRecord"> | string
    close?: StringWithAggregatesFilter<"StockRecord"> | string
    high?: StringWithAggregatesFilter<"StockRecord"> | string
    low?: StringWithAggregatesFilter<"StockRecord"> | string
    amount?: StringWithAggregatesFilter<"StockRecord"> | string
    volume?: StringWithAggregatesFilter<"StockRecord"> | string
    date?: StringWithAggregatesFilter<"StockRecord"> | string
    extra?: JsonWithAggregatesFilter<"StockRecord">
    createdAt?: DateTimeWithAggregatesFilter<"StockRecord"> | Date | string
    stockId?: BigIntWithAggregatesFilter<"StockRecord"> | bigint | number
  }

  export type StockMarketWhereInput = {
    AND?: StockMarketWhereInput | StockMarketWhereInput[]
    OR?: StockMarketWhereInput[]
    NOT?: StockMarketWhereInput | StockMarketWhereInput[]
    id?: BigIntFilter<"StockMarket"> | bigint | number
    code?: StringNullableFilter<"StockMarket"> | string | null
    currency?: StringNullableFilter<"StockMarket"> | string | null
    showName?: StringNullableFilter<"StockMarket"> | string | null
    maxWithdrawal?: StringNullableFilter<"StockMarket"> | string | null
    minWithdrawal?: StringNullableFilter<"StockMarket"> | string | null
    feeRate?: StringNullableFilter<"StockMarket"> | string | null
    minFee?: StringNullableFilter<"StockMarket"> | string | null
    lever?: StringNullableFilter<"StockMarket"> | string | null
    mmr?: StringNullableFilter<"StockMarket"> | string | null
    allocationRate?: StringNullableFilter<"StockMarket"> | string | null
    frequency?: IntNullableFilter<"StockMarket"> | number | null
    bindingHours?: IntNullableFilter<"StockMarket"> | number | null
    headSymbols?: StringNullableFilter<"StockMarket"> | string | null
    sort?: IntNullableFilter<"StockMarket"> | number | null
    online?: IntNullableFilter<"StockMarket"> | number | null
    conline?: IntNullableFilter<"StockMarket"> | number | null
    openTime?: StringNullableFilter<"StockMarket"> | string | null
    timezone?: StringNullableFilter<"StockMarket"> | string | null
    beforeTime?: StringNullableFilter<"StockMarket"> | string | null
    createdAt?: DateTimeFilter<"StockMarket"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockMarket"> | Date | string | null
  }

  export type StockMarketOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    showName?: SortOrderInput | SortOrder
    maxWithdrawal?: SortOrderInput | SortOrder
    minWithdrawal?: SortOrderInput | SortOrder
    feeRate?: SortOrderInput | SortOrder
    minFee?: SortOrderInput | SortOrder
    lever?: SortOrderInput | SortOrder
    mmr?: SortOrderInput | SortOrder
    allocationRate?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    bindingHours?: SortOrderInput | SortOrder
    headSymbols?: SortOrderInput | SortOrder
    sort?: SortOrderInput | SortOrder
    online?: SortOrderInput | SortOrder
    conline?: SortOrderInput | SortOrder
    openTime?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    beforeTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type StockMarketWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: StockMarketWhereInput | StockMarketWhereInput[]
    OR?: StockMarketWhereInput[]
    NOT?: StockMarketWhereInput | StockMarketWhereInput[]
    code?: StringNullableFilter<"StockMarket"> | string | null
    currency?: StringNullableFilter<"StockMarket"> | string | null
    showName?: StringNullableFilter<"StockMarket"> | string | null
    maxWithdrawal?: StringNullableFilter<"StockMarket"> | string | null
    minWithdrawal?: StringNullableFilter<"StockMarket"> | string | null
    feeRate?: StringNullableFilter<"StockMarket"> | string | null
    minFee?: StringNullableFilter<"StockMarket"> | string | null
    lever?: StringNullableFilter<"StockMarket"> | string | null
    mmr?: StringNullableFilter<"StockMarket"> | string | null
    allocationRate?: StringNullableFilter<"StockMarket"> | string | null
    frequency?: IntNullableFilter<"StockMarket"> | number | null
    bindingHours?: IntNullableFilter<"StockMarket"> | number | null
    headSymbols?: StringNullableFilter<"StockMarket"> | string | null
    sort?: IntNullableFilter<"StockMarket"> | number | null
    online?: IntNullableFilter<"StockMarket"> | number | null
    conline?: IntNullableFilter<"StockMarket"> | number | null
    openTime?: StringNullableFilter<"StockMarket"> | string | null
    timezone?: StringNullableFilter<"StockMarket"> | string | null
    beforeTime?: StringNullableFilter<"StockMarket"> | string | null
    createdAt?: DateTimeFilter<"StockMarket"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockMarket"> | Date | string | null
  }, "id">

  export type StockMarketOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    showName?: SortOrderInput | SortOrder
    maxWithdrawal?: SortOrderInput | SortOrder
    minWithdrawal?: SortOrderInput | SortOrder
    feeRate?: SortOrderInput | SortOrder
    minFee?: SortOrderInput | SortOrder
    lever?: SortOrderInput | SortOrder
    mmr?: SortOrderInput | SortOrder
    allocationRate?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    bindingHours?: SortOrderInput | SortOrder
    headSymbols?: SortOrderInput | SortOrder
    sort?: SortOrderInput | SortOrder
    online?: SortOrderInput | SortOrder
    conline?: SortOrderInput | SortOrder
    openTime?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    beforeTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StockMarketCountOrderByAggregateInput
    _avg?: StockMarketAvgOrderByAggregateInput
    _max?: StockMarketMaxOrderByAggregateInput
    _min?: StockMarketMinOrderByAggregateInput
    _sum?: StockMarketSumOrderByAggregateInput
  }

  export type StockMarketScalarWhereWithAggregatesInput = {
    AND?: StockMarketScalarWhereWithAggregatesInput | StockMarketScalarWhereWithAggregatesInput[]
    OR?: StockMarketScalarWhereWithAggregatesInput[]
    NOT?: StockMarketScalarWhereWithAggregatesInput | StockMarketScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"StockMarket"> | bigint | number
    code?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    currency?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    showName?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    maxWithdrawal?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    minWithdrawal?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    feeRate?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    minFee?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    lever?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    mmr?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    allocationRate?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    frequency?: IntNullableWithAggregatesFilter<"StockMarket"> | number | null
    bindingHours?: IntNullableWithAggregatesFilter<"StockMarket"> | number | null
    headSymbols?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    sort?: IntNullableWithAggregatesFilter<"StockMarket"> | number | null
    online?: IntNullableWithAggregatesFilter<"StockMarket"> | number | null
    conline?: IntNullableWithAggregatesFilter<"StockMarket"> | number | null
    openTime?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    beforeTime?: StringNullableWithAggregatesFilter<"StockMarket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockMarket"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"StockMarket"> | Date | string | null
  }

  export type StockFavoriteWhereInput = {
    AND?: StockFavoriteWhereInput | StockFavoriteWhereInput[]
    OR?: StockFavoriteWhereInput[]
    NOT?: StockFavoriteWhereInput | StockFavoriteWhereInput[]
    id?: BigIntFilter<"StockFavorite"> | bigint | number
    newPrice?: StringFilter<"StockFavorite"> | string
    open?: StringFilter<"StockFavorite"> | string
    close?: StringFilter<"StockFavorite"> | string
    high?: StringFilter<"StockFavorite"> | string
    low?: StringFilter<"StockFavorite"> | string
    amount?: StringFilter<"StockFavorite"> | string
    volume?: StringFilter<"StockFavorite"> | string
    date?: StringNullableFilter<"StockFavorite"> | string | null
    extra?: JsonNullableFilter<"StockFavorite">
    memberId?: BigIntFilter<"StockFavorite"> | bigint | number
    stockSymbolId?: BigIntFilter<"StockFavorite"> | bigint | number
    createdAt?: DateTimeFilter<"StockFavorite"> | Date | string
  }

  export type StockFavoriteOrderByWithRelationInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockFavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: StockFavoriteWhereInput | StockFavoriteWhereInput[]
    OR?: StockFavoriteWhereInput[]
    NOT?: StockFavoriteWhereInput | StockFavoriteWhereInput[]
    newPrice?: StringFilter<"StockFavorite"> | string
    open?: StringFilter<"StockFavorite"> | string
    close?: StringFilter<"StockFavorite"> | string
    high?: StringFilter<"StockFavorite"> | string
    low?: StringFilter<"StockFavorite"> | string
    amount?: StringFilter<"StockFavorite"> | string
    volume?: StringFilter<"StockFavorite"> | string
    date?: StringNullableFilter<"StockFavorite"> | string | null
    extra?: JsonNullableFilter<"StockFavorite">
    memberId?: BigIntFilter<"StockFavorite"> | bigint | number
    stockSymbolId?: BigIntFilter<"StockFavorite"> | bigint | number
    createdAt?: DateTimeFilter<"StockFavorite"> | Date | string
  }, "id">

  export type StockFavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
    _count?: StockFavoriteCountOrderByAggregateInput
    _avg?: StockFavoriteAvgOrderByAggregateInput
    _max?: StockFavoriteMaxOrderByAggregateInput
    _min?: StockFavoriteMinOrderByAggregateInput
    _sum?: StockFavoriteSumOrderByAggregateInput
  }

  export type StockFavoriteScalarWhereWithAggregatesInput = {
    AND?: StockFavoriteScalarWhereWithAggregatesInput | StockFavoriteScalarWhereWithAggregatesInput[]
    OR?: StockFavoriteScalarWhereWithAggregatesInput[]
    NOT?: StockFavoriteScalarWhereWithAggregatesInput | StockFavoriteScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"StockFavorite"> | bigint | number
    newPrice?: StringWithAggregatesFilter<"StockFavorite"> | string
    open?: StringWithAggregatesFilter<"StockFavorite"> | string
    close?: StringWithAggregatesFilter<"StockFavorite"> | string
    high?: StringWithAggregatesFilter<"StockFavorite"> | string
    low?: StringWithAggregatesFilter<"StockFavorite"> | string
    amount?: StringWithAggregatesFilter<"StockFavorite"> | string
    volume?: StringWithAggregatesFilter<"StockFavorite"> | string
    date?: StringNullableWithAggregatesFilter<"StockFavorite"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"StockFavorite">
    memberId?: BigIntWithAggregatesFilter<"StockFavorite"> | bigint | number
    stockSymbolId?: BigIntWithAggregatesFilter<"StockFavorite"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"StockFavorite"> | Date | string
  }

  export type StockSubscribeWhereInput = {
    AND?: StockSubscribeWhereInput | StockSubscribeWhereInput[]
    OR?: StockSubscribeWhereInput[]
    NOT?: StockSubscribeWhereInput | StockSubscribeWhereInput[]
    id?: BigIntFilter<"StockSubscribe"> | bigint | number
    market?: StringFilter<"StockSubscribe"> | string
    name?: StringFilter<"StockSubscribe"> | string
    code?: StringFilter<"StockSubscribe"> | string
    startAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
    endAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
    upAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
    circulation?: IntNullableFilter<"StockSubscribe"> | number | null
    remainCirculation?: IntNullableFilter<"StockSubscribe"> | number | null
    ipoPrice?: DecimalFilter<"StockSubscribe"> | Decimal | DecimalJsLike | number | string
    issuePrice?: DecimalFilter<"StockSubscribe"> | Decimal | DecimalJsLike | number | string
    resultAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
    subAmount?: JsonNullableFilter<"StockSubscribe">
    status?: IntFilter<"StockSubscribe"> | number
    type?: IntFilter<"StockSubscribe"> | number
    createdAt?: DateTimeFilter<"StockSubscribe"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
  }

  export type StockSubscribeOrderByWithRelationInput = {
    id?: SortOrder
    market?: SortOrder
    name?: SortOrder
    code?: SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    upAt?: SortOrderInput | SortOrder
    circulation?: SortOrderInput | SortOrder
    remainCirculation?: SortOrderInput | SortOrder
    ipoPrice?: SortOrder
    issuePrice?: SortOrder
    resultAt?: SortOrderInput | SortOrder
    subAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type StockSubscribeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: StockSubscribeWhereInput | StockSubscribeWhereInput[]
    OR?: StockSubscribeWhereInput[]
    NOT?: StockSubscribeWhereInput | StockSubscribeWhereInput[]
    market?: StringFilter<"StockSubscribe"> | string
    name?: StringFilter<"StockSubscribe"> | string
    code?: StringFilter<"StockSubscribe"> | string
    startAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
    endAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
    upAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
    circulation?: IntNullableFilter<"StockSubscribe"> | number | null
    remainCirculation?: IntNullableFilter<"StockSubscribe"> | number | null
    ipoPrice?: DecimalFilter<"StockSubscribe"> | Decimal | DecimalJsLike | number | string
    issuePrice?: DecimalFilter<"StockSubscribe"> | Decimal | DecimalJsLike | number | string
    resultAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
    subAmount?: JsonNullableFilter<"StockSubscribe">
    status?: IntFilter<"StockSubscribe"> | number
    type?: IntFilter<"StockSubscribe"> | number
    createdAt?: DateTimeFilter<"StockSubscribe"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockSubscribe"> | Date | string | null
  }, "id">

  export type StockSubscribeOrderByWithAggregationInput = {
    id?: SortOrder
    market?: SortOrder
    name?: SortOrder
    code?: SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    upAt?: SortOrderInput | SortOrder
    circulation?: SortOrderInput | SortOrder
    remainCirculation?: SortOrderInput | SortOrder
    ipoPrice?: SortOrder
    issuePrice?: SortOrder
    resultAt?: SortOrderInput | SortOrder
    subAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StockSubscribeCountOrderByAggregateInput
    _avg?: StockSubscribeAvgOrderByAggregateInput
    _max?: StockSubscribeMaxOrderByAggregateInput
    _min?: StockSubscribeMinOrderByAggregateInput
    _sum?: StockSubscribeSumOrderByAggregateInput
  }

  export type StockSubscribeScalarWhereWithAggregatesInput = {
    AND?: StockSubscribeScalarWhereWithAggregatesInput | StockSubscribeScalarWhereWithAggregatesInput[]
    OR?: StockSubscribeScalarWhereWithAggregatesInput[]
    NOT?: StockSubscribeScalarWhereWithAggregatesInput | StockSubscribeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"StockSubscribe"> | bigint | number
    market?: StringWithAggregatesFilter<"StockSubscribe"> | string
    name?: StringWithAggregatesFilter<"StockSubscribe"> | string
    code?: StringWithAggregatesFilter<"StockSubscribe"> | string
    startAt?: DateTimeNullableWithAggregatesFilter<"StockSubscribe"> | Date | string | null
    endAt?: DateTimeNullableWithAggregatesFilter<"StockSubscribe"> | Date | string | null
    upAt?: DateTimeNullableWithAggregatesFilter<"StockSubscribe"> | Date | string | null
    circulation?: IntNullableWithAggregatesFilter<"StockSubscribe"> | number | null
    remainCirculation?: IntNullableWithAggregatesFilter<"StockSubscribe"> | number | null
    ipoPrice?: DecimalWithAggregatesFilter<"StockSubscribe"> | Decimal | DecimalJsLike | number | string
    issuePrice?: DecimalWithAggregatesFilter<"StockSubscribe"> | Decimal | DecimalJsLike | number | string
    resultAt?: DateTimeNullableWithAggregatesFilter<"StockSubscribe"> | Date | string | null
    subAmount?: JsonNullableWithAggregatesFilter<"StockSubscribe">
    status?: IntWithAggregatesFilter<"StockSubscribe"> | number
    type?: IntWithAggregatesFilter<"StockSubscribe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StockSubscribe"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"StockSubscribe"> | Date | string | null
  }

  export type MemberSubscribeWhereInput = {
    AND?: MemberSubscribeWhereInput | MemberSubscribeWhereInput[]
    OR?: MemberSubscribeWhereInput[]
    NOT?: MemberSubscribeWhereInput | MemberSubscribeWhereInput[]
    id?: BigIntFilter<"MemberSubscribe"> | bigint | number
    market?: StringFilter<"MemberSubscribe"> | string
    code?: StringFilter<"MemberSubscribe"> | string
    name?: StringFilter<"MemberSubscribe"> | string
    amount?: IntFilter<"MemberSubscribe"> | number
    money?: DecimalFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string
    no?: StringFilter<"MemberSubscribe"> | string
    winningAmount?: IntNullableFilter<"MemberSubscribe"> | number | null
    winningPrice?: DecimalNullableFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: DecimalNullableFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    actualAmount?: DecimalNullableFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    status?: IntFilter<"MemberSubscribe"> | number
    type?: IntFilter<"MemberSubscribe"> | number
    position?: IntFilter<"MemberSubscribe"> | number
    createdAt?: DateTimeFilter<"MemberSubscribe"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberSubscribe"> | Date | string | null
    stockSubscribeId?: BigIntFilter<"MemberSubscribe"> | bigint | number
    memberId?: BigIntFilter<"MemberSubscribe"> | bigint | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }

  export type MemberSubscribeOrderByWithRelationInput = {
    id?: SortOrder
    market?: SortOrder
    code?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    money?: SortOrder
    no?: SortOrder
    winningAmount?: SortOrderInput | SortOrder
    winningPrice?: SortOrderInput | SortOrder
    totalWinningPrice?: SortOrderInput | SortOrder
    actualAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    stockSubscribeId?: SortOrder
    memberId?: SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type MemberSubscribeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MemberSubscribeWhereInput | MemberSubscribeWhereInput[]
    OR?: MemberSubscribeWhereInput[]
    NOT?: MemberSubscribeWhereInput | MemberSubscribeWhereInput[]
    market?: StringFilter<"MemberSubscribe"> | string
    code?: StringFilter<"MemberSubscribe"> | string
    name?: StringFilter<"MemberSubscribe"> | string
    amount?: IntFilter<"MemberSubscribe"> | number
    money?: DecimalFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string
    no?: StringFilter<"MemberSubscribe"> | string
    winningAmount?: IntNullableFilter<"MemberSubscribe"> | number | null
    winningPrice?: DecimalNullableFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: DecimalNullableFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    actualAmount?: DecimalNullableFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    status?: IntFilter<"MemberSubscribe"> | number
    type?: IntFilter<"MemberSubscribe"> | number
    position?: IntFilter<"MemberSubscribe"> | number
    createdAt?: DateTimeFilter<"MemberSubscribe"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberSubscribe"> | Date | string | null
    stockSubscribeId?: BigIntFilter<"MemberSubscribe"> | bigint | number
    memberId?: BigIntFilter<"MemberSubscribe"> | bigint | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }, "id">

  export type MemberSubscribeOrderByWithAggregationInput = {
    id?: SortOrder
    market?: SortOrder
    code?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    money?: SortOrder
    no?: SortOrder
    winningAmount?: SortOrderInput | SortOrder
    winningPrice?: SortOrderInput | SortOrder
    totalWinningPrice?: SortOrderInput | SortOrder
    actualAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    stockSubscribeId?: SortOrder
    memberId?: SortOrder
    _count?: MemberSubscribeCountOrderByAggregateInput
    _avg?: MemberSubscribeAvgOrderByAggregateInput
    _max?: MemberSubscribeMaxOrderByAggregateInput
    _min?: MemberSubscribeMinOrderByAggregateInput
    _sum?: MemberSubscribeSumOrderByAggregateInput
  }

  export type MemberSubscribeScalarWhereWithAggregatesInput = {
    AND?: MemberSubscribeScalarWhereWithAggregatesInput | MemberSubscribeScalarWhereWithAggregatesInput[]
    OR?: MemberSubscribeScalarWhereWithAggregatesInput[]
    NOT?: MemberSubscribeScalarWhereWithAggregatesInput | MemberSubscribeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"MemberSubscribe"> | bigint | number
    market?: StringWithAggregatesFilter<"MemberSubscribe"> | string
    code?: StringWithAggregatesFilter<"MemberSubscribe"> | string
    name?: StringWithAggregatesFilter<"MemberSubscribe"> | string
    amount?: IntWithAggregatesFilter<"MemberSubscribe"> | number
    money?: DecimalWithAggregatesFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string
    no?: StringWithAggregatesFilter<"MemberSubscribe"> | string
    winningAmount?: IntNullableWithAggregatesFilter<"MemberSubscribe"> | number | null
    winningPrice?: DecimalNullableWithAggregatesFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: DecimalNullableWithAggregatesFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    actualAmount?: DecimalNullableWithAggregatesFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    status?: IntWithAggregatesFilter<"MemberSubscribe"> | number
    type?: IntWithAggregatesFilter<"MemberSubscribe"> | number
    position?: IntWithAggregatesFilter<"MemberSubscribe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MemberSubscribe"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberSubscribe"> | Date | string | null
    stockSubscribeId?: BigIntWithAggregatesFilter<"MemberSubscribe"> | bigint | number
    memberId?: BigIntWithAggregatesFilter<"MemberSubscribe"> | bigint | number
  }

  export type StockPositionWhereInput = {
    AND?: StockPositionWhereInput | StockPositionWhereInput[]
    OR?: StockPositionWhereInput[]
    NOT?: StockPositionWhereInput | StockPositionWhereInput[]
    id?: BigIntFilter<"StockPosition"> | bigint | number
    amount?: IntFilter<"StockPosition"> | number
    blast?: StringFilter<"StockPosition"> | string
    price?: StringFilter<"StockPosition"> | string
    mode?: IntFilter<"StockPosition"> | number
    status?: IntFilter<"StockPosition"> | number
    bond?: StringNullableFilter<"StockPosition"> | string | null
    identifier?: StringNullableFilter<"StockPosition"> | string | null
    lever?: StringNullableFilter<"StockPosition"> | string | null
    stopLoss?: StringNullableFilter<"StockPosition"> | string | null
    takeProfit?: StringNullableFilter<"StockPosition"> | string | null
    market?: StringNullableFilter<"StockPosition"> | string | null
    type?: IntFilter<"StockPosition"> | number
    pl?: StringNullableFilter<"StockPosition"> | string | null
    rate?: StringNullableFilter<"StockPosition"> | string | null
    isBefore?: BoolFilter<"StockPosition"> | boolean
    currentPrice?: StringNullableFilter<"StockPosition"> | string | null
    memberId?: BigIntFilter<"StockPosition"> | bigint | number
    stockSymbolId?: BigIntFilter<"StockPosition"> | bigint | number
    createdAt?: DateTimeFilter<"StockPosition"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockPosition"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    stockSymbol?: XOR<StockSymbolRelationFilter, StockSymbolWhereInput>
  }

  export type StockPositionOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    blast?: SortOrder
    price?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    bond?: SortOrderInput | SortOrder
    identifier?: SortOrderInput | SortOrder
    lever?: SortOrderInput | SortOrder
    stopLoss?: SortOrderInput | SortOrder
    takeProfit?: SortOrderInput | SortOrder
    market?: SortOrderInput | SortOrder
    type?: SortOrder
    pl?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    isBefore?: SortOrder
    currentPrice?: SortOrderInput | SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
    stockSymbol?: StockSymbolOrderByWithRelationInput
  }

  export type StockPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: StockPositionWhereInput | StockPositionWhereInput[]
    OR?: StockPositionWhereInput[]
    NOT?: StockPositionWhereInput | StockPositionWhereInput[]
    amount?: IntFilter<"StockPosition"> | number
    blast?: StringFilter<"StockPosition"> | string
    price?: StringFilter<"StockPosition"> | string
    mode?: IntFilter<"StockPosition"> | number
    status?: IntFilter<"StockPosition"> | number
    bond?: StringNullableFilter<"StockPosition"> | string | null
    identifier?: StringNullableFilter<"StockPosition"> | string | null
    lever?: StringNullableFilter<"StockPosition"> | string | null
    stopLoss?: StringNullableFilter<"StockPosition"> | string | null
    takeProfit?: StringNullableFilter<"StockPosition"> | string | null
    market?: StringNullableFilter<"StockPosition"> | string | null
    type?: IntFilter<"StockPosition"> | number
    pl?: StringNullableFilter<"StockPosition"> | string | null
    rate?: StringNullableFilter<"StockPosition"> | string | null
    isBefore?: BoolFilter<"StockPosition"> | boolean
    currentPrice?: StringNullableFilter<"StockPosition"> | string | null
    memberId?: BigIntFilter<"StockPosition"> | bigint | number
    stockSymbolId?: BigIntFilter<"StockPosition"> | bigint | number
    createdAt?: DateTimeFilter<"StockPosition"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockPosition"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
    stockSymbol?: XOR<StockSymbolRelationFilter, StockSymbolWhereInput>
  }, "id">

  export type StockPositionOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    blast?: SortOrder
    price?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    bond?: SortOrderInput | SortOrder
    identifier?: SortOrderInput | SortOrder
    lever?: SortOrderInput | SortOrder
    stopLoss?: SortOrderInput | SortOrder
    takeProfit?: SortOrderInput | SortOrder
    market?: SortOrderInput | SortOrder
    type?: SortOrder
    pl?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    isBefore?: SortOrder
    currentPrice?: SortOrderInput | SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StockPositionCountOrderByAggregateInput
    _avg?: StockPositionAvgOrderByAggregateInput
    _max?: StockPositionMaxOrderByAggregateInput
    _min?: StockPositionMinOrderByAggregateInput
    _sum?: StockPositionSumOrderByAggregateInput
  }

  export type StockPositionScalarWhereWithAggregatesInput = {
    AND?: StockPositionScalarWhereWithAggregatesInput | StockPositionScalarWhereWithAggregatesInput[]
    OR?: StockPositionScalarWhereWithAggregatesInput[]
    NOT?: StockPositionScalarWhereWithAggregatesInput | StockPositionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"StockPosition"> | bigint | number
    amount?: IntWithAggregatesFilter<"StockPosition"> | number
    blast?: StringWithAggregatesFilter<"StockPosition"> | string
    price?: StringWithAggregatesFilter<"StockPosition"> | string
    mode?: IntWithAggregatesFilter<"StockPosition"> | number
    status?: IntWithAggregatesFilter<"StockPosition"> | number
    bond?: StringNullableWithAggregatesFilter<"StockPosition"> | string | null
    identifier?: StringNullableWithAggregatesFilter<"StockPosition"> | string | null
    lever?: StringNullableWithAggregatesFilter<"StockPosition"> | string | null
    stopLoss?: StringNullableWithAggregatesFilter<"StockPosition"> | string | null
    takeProfit?: StringNullableWithAggregatesFilter<"StockPosition"> | string | null
    market?: StringNullableWithAggregatesFilter<"StockPosition"> | string | null
    type?: IntWithAggregatesFilter<"StockPosition"> | number
    pl?: StringNullableWithAggregatesFilter<"StockPosition"> | string | null
    rate?: StringNullableWithAggregatesFilter<"StockPosition"> | string | null
    isBefore?: BoolWithAggregatesFilter<"StockPosition"> | boolean
    currentPrice?: StringNullableWithAggregatesFilter<"StockPosition"> | string | null
    memberId?: BigIntWithAggregatesFilter<"StockPosition"> | bigint | number
    stockSymbolId?: BigIntWithAggregatesFilter<"StockPosition"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"StockPosition"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"StockPosition"> | Date | string | null
  }

  export type MemberDetailWhereInput = {
    AND?: MemberDetailWhereInput | MemberDetailWhereInput[]
    OR?: MemberDetailWhereInput[]
    NOT?: MemberDetailWhereInput | MemberDetailWhereInput[]
    id?: BigIntFilter<"MemberDetail"> | bigint | number
    after?: StringNullableFilter<"MemberDetail"> | string | null
    amount?: StringNullableFilter<"MemberDetail"> | string | null
    before?: StringNullableFilter<"MemberDetail"> | string | null
    market?: StringNullableFilter<"MemberDetail"> | string | null
    type?: IntFilter<"MemberDetail"> | number
    remark?: StringNullableFilter<"MemberDetail"> | string | null
    memberId?: BigIntFilter<"MemberDetail"> | bigint | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }

  export type MemberDetailOrderByWithRelationInput = {
    id?: SortOrder
    after?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    before?: SortOrderInput | SortOrder
    market?: SortOrderInput | SortOrder
    type?: SortOrder
    remark?: SortOrderInput | SortOrder
    memberId?: SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type MemberDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MemberDetailWhereInput | MemberDetailWhereInput[]
    OR?: MemberDetailWhereInput[]
    NOT?: MemberDetailWhereInput | MemberDetailWhereInput[]
    after?: StringNullableFilter<"MemberDetail"> | string | null
    amount?: StringNullableFilter<"MemberDetail"> | string | null
    before?: StringNullableFilter<"MemberDetail"> | string | null
    market?: StringNullableFilter<"MemberDetail"> | string | null
    type?: IntFilter<"MemberDetail"> | number
    remark?: StringNullableFilter<"MemberDetail"> | string | null
    memberId?: BigIntFilter<"MemberDetail"> | bigint | number
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }, "id">

  export type MemberDetailOrderByWithAggregationInput = {
    id?: SortOrder
    after?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    before?: SortOrderInput | SortOrder
    market?: SortOrderInput | SortOrder
    type?: SortOrder
    remark?: SortOrderInput | SortOrder
    memberId?: SortOrder
    _count?: MemberDetailCountOrderByAggregateInput
    _avg?: MemberDetailAvgOrderByAggregateInput
    _max?: MemberDetailMaxOrderByAggregateInput
    _min?: MemberDetailMinOrderByAggregateInput
    _sum?: MemberDetailSumOrderByAggregateInput
  }

  export type MemberDetailScalarWhereWithAggregatesInput = {
    AND?: MemberDetailScalarWhereWithAggregatesInput | MemberDetailScalarWhereWithAggregatesInput[]
    OR?: MemberDetailScalarWhereWithAggregatesInput[]
    NOT?: MemberDetailScalarWhereWithAggregatesInput | MemberDetailScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"MemberDetail"> | bigint | number
    after?: StringNullableWithAggregatesFilter<"MemberDetail"> | string | null
    amount?: StringNullableWithAggregatesFilter<"MemberDetail"> | string | null
    before?: StringNullableWithAggregatesFilter<"MemberDetail"> | string | null
    market?: StringNullableWithAggregatesFilter<"MemberDetail"> | string | null
    type?: IntWithAggregatesFilter<"MemberDetail"> | number
    remark?: StringNullableWithAggregatesFilter<"MemberDetail"> | string | null
    memberId?: BigIntWithAggregatesFilter<"MemberDetail"> | bigint | number
  }

  export type MemberCardWhereInput = {
    AND?: MemberCardWhereInput | MemberCardWhereInput[]
    OR?: MemberCardWhereInput[]
    NOT?: MemberCardWhereInput | MemberCardWhereInput[]
    id?: BigIntFilter<"MemberCard"> | bigint | number
    name?: StringNullableFilter<"MemberCard"> | string | null
    type?: EnumRechargeTypeFilter<"MemberCard"> | $Enums.RechargeType
    detail?: JsonFilter<"MemberCard">
    memberId?: BigIntFilter<"MemberCard"> | bigint | number
    createdAt?: DateTimeFilter<"MemberCard"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberCard"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }

  export type MemberCardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    detail?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type MemberCardWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MemberCardWhereInput | MemberCardWhereInput[]
    OR?: MemberCardWhereInput[]
    NOT?: MemberCardWhereInput | MemberCardWhereInput[]
    name?: StringNullableFilter<"MemberCard"> | string | null
    type?: EnumRechargeTypeFilter<"MemberCard"> | $Enums.RechargeType
    detail?: JsonFilter<"MemberCard">
    memberId?: BigIntFilter<"MemberCard"> | bigint | number
    createdAt?: DateTimeFilter<"MemberCard"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberCard"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }, "id">

  export type MemberCardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    detail?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MemberCardCountOrderByAggregateInput
    _avg?: MemberCardAvgOrderByAggregateInput
    _max?: MemberCardMaxOrderByAggregateInput
    _min?: MemberCardMinOrderByAggregateInput
    _sum?: MemberCardSumOrderByAggregateInput
  }

  export type MemberCardScalarWhereWithAggregatesInput = {
    AND?: MemberCardScalarWhereWithAggregatesInput | MemberCardScalarWhereWithAggregatesInput[]
    OR?: MemberCardScalarWhereWithAggregatesInput[]
    NOT?: MemberCardScalarWhereWithAggregatesInput | MemberCardScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"MemberCard"> | bigint | number
    name?: StringNullableWithAggregatesFilter<"MemberCard"> | string | null
    type?: EnumRechargeTypeWithAggregatesFilter<"MemberCard"> | $Enums.RechargeType
    detail?: JsonWithAggregatesFilter<"MemberCard">
    memberId?: BigIntWithAggregatesFilter<"MemberCard"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"MemberCard"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MemberCard"> | Date | string | null
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: BigIntFilter<"Country"> | bigint | number
    code?: StringNullableFilter<"Country"> | string | null
    name?: StringFilter<"Country"> | string
    en?: StringFilter<"Country"> | string
    tel?: StringFilter<"Country"> | string
    py?: StringFilter<"Country"> | string
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Country"> | Date | string | null
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    en?: SortOrder
    tel?: SortOrder
    py?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    py_tel_name?: CountryPyTelNameCompoundUniqueInput
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    code?: StringNullableFilter<"Country"> | string | null
    name?: StringFilter<"Country"> | string
    en?: StringFilter<"Country"> | string
    tel?: StringFilter<"Country"> | string
    py?: StringFilter<"Country"> | string
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Country"> | Date | string | null
  }, "id" | "py_tel_name">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    en?: SortOrder
    tel?: SortOrder
    py?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Country"> | bigint | number
    code?: StringNullableWithAggregatesFilter<"Country"> | string | null
    name?: StringWithAggregatesFilter<"Country"> | string
    en?: StringWithAggregatesFilter<"Country"> | string
    tel?: StringWithAggregatesFilter<"Country"> | string
    py?: StringWithAggregatesFilter<"Country"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Country"> | Date | string | null
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: BigIntFilter<"Setting"> | bigint | number
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Setting"> | Date | string | null
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Setting"> | Date | string | null
  }, "id">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SettingCountOrderByAggregateInput
    _avg?: SettingAvgOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
    _sum?: SettingSumOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Setting"> | bigint | number
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Setting"> | Date | string | null
  }

  export type StockResourceWhereInput = {
    AND?: StockResourceWhereInput | StockResourceWhereInput[]
    OR?: StockResourceWhereInput[]
    NOT?: StockResourceWhereInput | StockResourceWhereInput[]
    id?: BigIntFilter<"StockResource"> | bigint | number
    amountScope?: StringFilter<"StockResource"> | string
    frequencyScope?: StringFilter<"StockResource"> | string
    market?: StringFilter<"StockResource"> | string
    spreadScope?: StringFilter<"StockResource"> | string
    endAt?: StringFilter<"StockResource"> | string
    startAt?: StringFilter<"StockResource"> | string
    symbol?: StringFilter<"StockResource"> | string
    type?: IntFilter<"StockResource"> | number
    status?: IntFilter<"StockResource"> | number
    createdAt?: DateTimeFilter<"StockResource"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockResource"> | Date | string | null
  }

  export type StockResourceOrderByWithRelationInput = {
    id?: SortOrder
    amountScope?: SortOrder
    frequencyScope?: SortOrder
    market?: SortOrder
    spreadScope?: SortOrder
    endAt?: SortOrder
    startAt?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type StockResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: StockResourceWhereInput | StockResourceWhereInput[]
    OR?: StockResourceWhereInput[]
    NOT?: StockResourceWhereInput | StockResourceWhereInput[]
    amountScope?: StringFilter<"StockResource"> | string
    frequencyScope?: StringFilter<"StockResource"> | string
    market?: StringFilter<"StockResource"> | string
    spreadScope?: StringFilter<"StockResource"> | string
    endAt?: StringFilter<"StockResource"> | string
    startAt?: StringFilter<"StockResource"> | string
    symbol?: StringFilter<"StockResource"> | string
    type?: IntFilter<"StockResource"> | number
    status?: IntFilter<"StockResource"> | number
    createdAt?: DateTimeFilter<"StockResource"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockResource"> | Date | string | null
  }, "id">

  export type StockResourceOrderByWithAggregationInput = {
    id?: SortOrder
    amountScope?: SortOrder
    frequencyScope?: SortOrder
    market?: SortOrder
    spreadScope?: SortOrder
    endAt?: SortOrder
    startAt?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: StockResourceCountOrderByAggregateInput
    _avg?: StockResourceAvgOrderByAggregateInput
    _max?: StockResourceMaxOrderByAggregateInput
    _min?: StockResourceMinOrderByAggregateInput
    _sum?: StockResourceSumOrderByAggregateInput
  }

  export type StockResourceScalarWhereWithAggregatesInput = {
    AND?: StockResourceScalarWhereWithAggregatesInput | StockResourceScalarWhereWithAggregatesInput[]
    OR?: StockResourceScalarWhereWithAggregatesInput[]
    NOT?: StockResourceScalarWhereWithAggregatesInput | StockResourceScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"StockResource"> | bigint | number
    amountScope?: StringWithAggregatesFilter<"StockResource"> | string
    frequencyScope?: StringWithAggregatesFilter<"StockResource"> | string
    market?: StringWithAggregatesFilter<"StockResource"> | string
    spreadScope?: StringWithAggregatesFilter<"StockResource"> | string
    endAt?: StringWithAggregatesFilter<"StockResource"> | string
    startAt?: StringWithAggregatesFilter<"StockResource"> | string
    symbol?: StringWithAggregatesFilter<"StockResource"> | string
    type?: IntWithAggregatesFilter<"StockResource"> | number
    status?: IntWithAggregatesFilter<"StockResource"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StockResource"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"StockResource"> | Date | string | null
  }

  export type StockResourceRecordWhereInput = {
    AND?: StockResourceRecordWhereInput | StockResourceRecordWhereInput[]
    OR?: StockResourceRecordWhereInput[]
    NOT?: StockResourceRecordWhereInput | StockResourceRecordWhereInput[]
    id?: BigIntFilter<"StockResourceRecord"> | bigint | number
    open?: StringFilter<"StockResourceRecord"> | string
    high?: StringFilter<"StockResourceRecord"> | string
    close?: StringFilter<"StockResourceRecord"> | string
    low?: StringFilter<"StockResourceRecord"> | string
    time?: StringFilter<"StockResourceRecord"> | string
    stockResourceId?: BigIntFilter<"StockResourceRecord"> | bigint | number
  }

  export type StockResourceRecordOrderByWithRelationInput = {
    id?: SortOrder
    open?: SortOrder
    high?: SortOrder
    close?: SortOrder
    low?: SortOrder
    time?: SortOrder
    stockResourceId?: SortOrder
  }

  export type StockResourceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: StockResourceRecordWhereInput | StockResourceRecordWhereInput[]
    OR?: StockResourceRecordWhereInput[]
    NOT?: StockResourceRecordWhereInput | StockResourceRecordWhereInput[]
    open?: StringFilter<"StockResourceRecord"> | string
    high?: StringFilter<"StockResourceRecord"> | string
    close?: StringFilter<"StockResourceRecord"> | string
    low?: StringFilter<"StockResourceRecord"> | string
    time?: StringFilter<"StockResourceRecord"> | string
    stockResourceId?: BigIntFilter<"StockResourceRecord"> | bigint | number
  }, "id">

  export type StockResourceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    open?: SortOrder
    high?: SortOrder
    close?: SortOrder
    low?: SortOrder
    time?: SortOrder
    stockResourceId?: SortOrder
    _count?: StockResourceRecordCountOrderByAggregateInput
    _avg?: StockResourceRecordAvgOrderByAggregateInput
    _max?: StockResourceRecordMaxOrderByAggregateInput
    _min?: StockResourceRecordMinOrderByAggregateInput
    _sum?: StockResourceRecordSumOrderByAggregateInput
  }

  export type StockResourceRecordScalarWhereWithAggregatesInput = {
    AND?: StockResourceRecordScalarWhereWithAggregatesInput | StockResourceRecordScalarWhereWithAggregatesInput[]
    OR?: StockResourceRecordScalarWhereWithAggregatesInput[]
    NOT?: StockResourceRecordScalarWhereWithAggregatesInput | StockResourceRecordScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"StockResourceRecord"> | bigint | number
    open?: StringWithAggregatesFilter<"StockResourceRecord"> | string
    high?: StringWithAggregatesFilter<"StockResourceRecord"> | string
    close?: StringWithAggregatesFilter<"StockResourceRecord"> | string
    low?: StringWithAggregatesFilter<"StockResourceRecord"> | string
    time?: StringWithAggregatesFilter<"StockResourceRecord"> | string
    stockResourceId?: BigIntWithAggregatesFilter<"StockResourceRecord"> | bigint | number
  }

  export type ArticleWhereInput = {
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    id?: BigIntFilter<"Article"> | bigint | number
    thumb?: StringFilter<"Article"> | string
    title?: StringFilter<"Article"> | string
    market?: StringNullableFilter<"Article"> | string | null
    crawlerThumb?: StringNullableFilter<"Article"> | string | null
    source?: StringNullableFilter<"Article"> | string | null
    content?: StringFilter<"Article"> | string
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Article"> | Date | string | null
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    thumb?: SortOrder
    title?: SortOrder
    market?: SortOrderInput | SortOrder
    crawlerThumb?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type ArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    thumb?: StringFilter<"Article"> | string
    title?: StringFilter<"Article"> | string
    market?: StringNullableFilter<"Article"> | string | null
    crawlerThumb?: StringNullableFilter<"Article"> | string | null
    source?: StringNullableFilter<"Article"> | string | null
    content?: StringFilter<"Article"> | string
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Article"> | Date | string | null
  }, "id">

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    thumb?: SortOrder
    title?: SortOrder
    market?: SortOrderInput | SortOrder
    crawlerThumb?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    OR?: ArticleScalarWhereWithAggregatesInput[]
    NOT?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Article"> | bigint | number
    thumb?: StringWithAggregatesFilter<"Article"> | string
    title?: StringWithAggregatesFilter<"Article"> | string
    market?: StringNullableWithAggregatesFilter<"Article"> | string | null
    crawlerThumb?: StringNullableWithAggregatesFilter<"Article"> | string | null
    source?: StringNullableWithAggregatesFilter<"Article"> | string | null
    content?: StringWithAggregatesFilter<"Article"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Article"> | Date | string | null
  }

  export type RechargeWhereInput = {
    AND?: RechargeWhereInput | RechargeWhereInput[]
    OR?: RechargeWhereInput[]
    NOT?: RechargeWhereInput | RechargeWhereInput[]
    id?: BigIntFilter<"Recharge"> | bigint | number
    market?: StringFilter<"Recharge"> | string
    money?: DecimalFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFilter<"Recharge"> | $Enums.RechargeType
    account?: StringFilter<"Recharge"> | string
    accountNetwork?: StringFilter<"Recharge"> | string
    screens?: JsonFilter<"Recharge">
    status?: IntFilter<"Recharge"> | number
    passMoney?: DecimalFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    memberId?: BigIntFilter<"Recharge"> | bigint | number
    createdAt?: DateTimeFilter<"Recharge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Recharge"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }

  export type RechargeOrderByWithRelationInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    account?: SortOrder
    accountNetwork?: SortOrder
    screens?: SortOrder
    status?: SortOrder
    passMoney?: SortOrder
    convertMoney?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type RechargeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: RechargeWhereInput | RechargeWhereInput[]
    OR?: RechargeWhereInput[]
    NOT?: RechargeWhereInput | RechargeWhereInput[]
    market?: StringFilter<"Recharge"> | string
    money?: DecimalFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFilter<"Recharge"> | $Enums.RechargeType
    account?: StringFilter<"Recharge"> | string
    accountNetwork?: StringFilter<"Recharge"> | string
    screens?: JsonFilter<"Recharge">
    status?: IntFilter<"Recharge"> | number
    passMoney?: DecimalFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    memberId?: BigIntFilter<"Recharge"> | bigint | number
    createdAt?: DateTimeFilter<"Recharge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Recharge"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }, "id">

  export type RechargeOrderByWithAggregationInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    account?: SortOrder
    accountNetwork?: SortOrder
    screens?: SortOrder
    status?: SortOrder
    passMoney?: SortOrder
    convertMoney?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RechargeCountOrderByAggregateInput
    _avg?: RechargeAvgOrderByAggregateInput
    _max?: RechargeMaxOrderByAggregateInput
    _min?: RechargeMinOrderByAggregateInput
    _sum?: RechargeSumOrderByAggregateInput
  }

  export type RechargeScalarWhereWithAggregatesInput = {
    AND?: RechargeScalarWhereWithAggregatesInput | RechargeScalarWhereWithAggregatesInput[]
    OR?: RechargeScalarWhereWithAggregatesInput[]
    NOT?: RechargeScalarWhereWithAggregatesInput | RechargeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Recharge"> | bigint | number
    market?: StringWithAggregatesFilter<"Recharge"> | string
    money?: DecimalWithAggregatesFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeWithAggregatesFilter<"Recharge"> | $Enums.RechargeType
    account?: StringWithAggregatesFilter<"Recharge"> | string
    accountNetwork?: StringWithAggregatesFilter<"Recharge"> | string
    screens?: JsonWithAggregatesFilter<"Recharge">
    status?: IntWithAggregatesFilter<"Recharge"> | number
    passMoney?: DecimalWithAggregatesFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalWithAggregatesFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    memberId?: BigIntWithAggregatesFilter<"Recharge"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Recharge"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Recharge"> | Date | string | null
  }

  export type WithdrawWhereInput = {
    AND?: WithdrawWhereInput | WithdrawWhereInput[]
    OR?: WithdrawWhereInput[]
    NOT?: WithdrawWhereInput | WithdrawWhereInput[]
    id?: BigIntFilter<"Withdraw"> | bigint | number
    market?: StringFilter<"Withdraw"> | string
    money?: DecimalFilter<"Withdraw"> | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFilter<"Withdraw"> | $Enums.RechargeType
    currency?: StringFilter<"Withdraw"> | string
    cryptoType?: StringNullableFilter<"Withdraw"> | string | null
    cryptoNetwork?: StringNullableFilter<"Withdraw"> | string | null
    card?: JsonNullableFilter<"Withdraw">
    convertMoney?: DecimalFilter<"Withdraw"> | Decimal | DecimalJsLike | number | string
    status?: IntFilter<"Withdraw"> | number
    memberId?: BigIntFilter<"Withdraw"> | bigint | number
    createdAt?: DateTimeFilter<"Withdraw"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Withdraw"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }

  export type WithdrawOrderByWithRelationInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    cryptoType?: SortOrderInput | SortOrder
    cryptoNetwork?: SortOrderInput | SortOrder
    card?: SortOrderInput | SortOrder
    convertMoney?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    member?: MemberOrderByWithRelationInput
  }

  export type WithdrawWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: WithdrawWhereInput | WithdrawWhereInput[]
    OR?: WithdrawWhereInput[]
    NOT?: WithdrawWhereInput | WithdrawWhereInput[]
    market?: StringFilter<"Withdraw"> | string
    money?: DecimalFilter<"Withdraw"> | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFilter<"Withdraw"> | $Enums.RechargeType
    currency?: StringFilter<"Withdraw"> | string
    cryptoType?: StringNullableFilter<"Withdraw"> | string | null
    cryptoNetwork?: StringNullableFilter<"Withdraw"> | string | null
    card?: JsonNullableFilter<"Withdraw">
    convertMoney?: DecimalFilter<"Withdraw"> | Decimal | DecimalJsLike | number | string
    status?: IntFilter<"Withdraw"> | number
    memberId?: BigIntFilter<"Withdraw"> | bigint | number
    createdAt?: DateTimeFilter<"Withdraw"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Withdraw"> | Date | string | null
    member?: XOR<MemberRelationFilter, MemberWhereInput>
  }, "id">

  export type WithdrawOrderByWithAggregationInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    cryptoType?: SortOrderInput | SortOrder
    cryptoNetwork?: SortOrderInput | SortOrder
    card?: SortOrderInput | SortOrder
    convertMoney?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: WithdrawCountOrderByAggregateInput
    _avg?: WithdrawAvgOrderByAggregateInput
    _max?: WithdrawMaxOrderByAggregateInput
    _min?: WithdrawMinOrderByAggregateInput
    _sum?: WithdrawSumOrderByAggregateInput
  }

  export type WithdrawScalarWhereWithAggregatesInput = {
    AND?: WithdrawScalarWhereWithAggregatesInput | WithdrawScalarWhereWithAggregatesInput[]
    OR?: WithdrawScalarWhereWithAggregatesInput[]
    NOT?: WithdrawScalarWhereWithAggregatesInput | WithdrawScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Withdraw"> | bigint | number
    market?: StringWithAggregatesFilter<"Withdraw"> | string
    money?: DecimalWithAggregatesFilter<"Withdraw"> | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeWithAggregatesFilter<"Withdraw"> | $Enums.RechargeType
    currency?: StringWithAggregatesFilter<"Withdraw"> | string
    cryptoType?: StringNullableWithAggregatesFilter<"Withdraw"> | string | null
    cryptoNetwork?: StringNullableWithAggregatesFilter<"Withdraw"> | string | null
    card?: JsonNullableWithAggregatesFilter<"Withdraw">
    convertMoney?: DecimalWithAggregatesFilter<"Withdraw"> | Decimal | DecimalJsLike | number | string
    status?: IntWithAggregatesFilter<"Withdraw"> | number
    memberId?: BigIntWithAggregatesFilter<"Withdraw"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Withdraw"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Withdraw"> | Date | string | null
  }

  export type RechargeAccountWhereInput = {
    AND?: RechargeAccountWhereInput | RechargeAccountWhereInput[]
    OR?: RechargeAccountWhereInput[]
    NOT?: RechargeAccountWhereInput | RechargeAccountWhereInput[]
    id?: BigIntFilter<"RechargeAccount"> | bigint | number
    account?: StringFilter<"RechargeAccount"> | string
    accountAddress?: StringFilter<"RechargeAccount"> | string
    currency?: StringFilter<"RechargeAccount"> | string
    max?: DecimalFilter<"RechargeAccount"> | Decimal | DecimalJsLike | number | string
    min?: DecimalFilter<"RechargeAccount"> | Decimal | DecimalJsLike | number | string
    status?: IntFilter<"RechargeAccount"> | number
    createdAt?: DateTimeFilter<"RechargeAccount"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RechargeAccount"> | Date | string | null
  }

  export type RechargeAccountOrderByWithRelationInput = {
    id?: SortOrder
    account?: SortOrder
    accountAddress?: SortOrder
    currency?: SortOrder
    max?: SortOrder
    min?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type RechargeAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: RechargeAccountWhereInput | RechargeAccountWhereInput[]
    OR?: RechargeAccountWhereInput[]
    NOT?: RechargeAccountWhereInput | RechargeAccountWhereInput[]
    account?: StringFilter<"RechargeAccount"> | string
    accountAddress?: StringFilter<"RechargeAccount"> | string
    currency?: StringFilter<"RechargeAccount"> | string
    max?: DecimalFilter<"RechargeAccount"> | Decimal | DecimalJsLike | number | string
    min?: DecimalFilter<"RechargeAccount"> | Decimal | DecimalJsLike | number | string
    status?: IntFilter<"RechargeAccount"> | number
    createdAt?: DateTimeFilter<"RechargeAccount"> | Date | string
    updatedAt?: DateTimeNullableFilter<"RechargeAccount"> | Date | string | null
  }, "id">

  export type RechargeAccountOrderByWithAggregationInput = {
    id?: SortOrder
    account?: SortOrder
    accountAddress?: SortOrder
    currency?: SortOrder
    max?: SortOrder
    min?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: RechargeAccountCountOrderByAggregateInput
    _avg?: RechargeAccountAvgOrderByAggregateInput
    _max?: RechargeAccountMaxOrderByAggregateInput
    _min?: RechargeAccountMinOrderByAggregateInput
    _sum?: RechargeAccountSumOrderByAggregateInput
  }

  export type RechargeAccountScalarWhereWithAggregatesInput = {
    AND?: RechargeAccountScalarWhereWithAggregatesInput | RechargeAccountScalarWhereWithAggregatesInput[]
    OR?: RechargeAccountScalarWhereWithAggregatesInput[]
    NOT?: RechargeAccountScalarWhereWithAggregatesInput | RechargeAccountScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"RechargeAccount"> | bigint | number
    account?: StringWithAggregatesFilter<"RechargeAccount"> | string
    accountAddress?: StringWithAggregatesFilter<"RechargeAccount"> | string
    currency?: StringWithAggregatesFilter<"RechargeAccount"> | string
    max?: DecimalWithAggregatesFilter<"RechargeAccount"> | Decimal | DecimalJsLike | number | string
    min?: DecimalWithAggregatesFilter<"RechargeAccount"> | Decimal | DecimalJsLike | number | string
    status?: IntWithAggregatesFilter<"RechargeAccount"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RechargeAccount"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RechargeAccount"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserUncheckedCreateInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCreateInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardCreateNestedManyWithoutMemberInput
    recharges?: RechargeCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionUncheckedCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailUncheckedCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeUncheckedCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeUncheckedCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawUncheckedCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardUncheckedCreateNestedManyWithoutMemberInput
    recharges?: RechargeUncheckedCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUncheckedUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUncheckedUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUncheckedUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUncheckedUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUncheckedUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUncheckedUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUncheckedUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateManyInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
  }

  export type MemberUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberRechargeCreateInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    rechargeMoney?: Decimal | DecimalJsLike | number | string
    screen: JsonNullValueInput | InputJsonValue
    market: string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    member: MemberCreateNestedOneWithoutMemberRechargesInput
  }

  export type MemberRechargeUncheckedCreateInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    rechargeMoney?: Decimal | DecimalJsLike | number | string
    screen: JsonNullValueInput | InputJsonValue
    market: string
    status?: number
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberRechargeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    screen?: JsonNullValueInput | InputJsonValue
    market?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutMemberRechargesNestedInput
  }

  export type MemberRechargeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    screen?: JsonNullValueInput | InputJsonValue
    market?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberRechargeCreateManyInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    rechargeMoney?: Decimal | DecimalJsLike | number | string
    screen: JsonNullValueInput | InputJsonValue
    market: string
    status?: number
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberRechargeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    screen?: JsonNullValueInput | InputJsonValue
    market?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberRechargeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    screen?: JsonNullValueInput | InputJsonValue
    market?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberWithdrawCreateInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    remark?: string | null
    status?: number
    address?: string | null
    market: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    member: MemberCreateNestedOneWithoutMemberWithdrawsInput
  }

  export type MemberWithdrawUncheckedCreateInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    remark?: string | null
    status?: number
    address?: string | null
    market: string
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberWithdrawUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutMemberWithdrawsNestedInput
  }

  export type MemberWithdrawUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberWithdrawCreateManyInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    remark?: string | null
    status?: number
    address?: string | null
    market: string
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberWithdrawUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberWithdrawUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockSymbolCreateInput = {
    id?: bigint | number
    code: string
    cat?: string | null
    market: string
    online?: number
    symbol: string
    showName: string
    name?: string | null
    symbolShowName?: string | null
    trade?: number
    type?: number
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    change?: string | null
    changePercent?: string | null
    date?: string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockPostion?: StockPositionCreateNestedManyWithoutStockSymbolInput
  }

  export type StockSymbolUncheckedCreateInput = {
    id?: bigint | number
    code: string
    cat?: string | null
    market: string
    online?: number
    symbol: string
    showName: string
    name?: string | null
    symbolShowName?: string | null
    trade?: number
    type?: number
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    change?: string | null
    changePercent?: string | null
    date?: string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockPostion?: StockPositionUncheckedCreateNestedManyWithoutStockSymbolInput
  }

  export type StockSymbolUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    cat?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    online?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    showName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbolShowName?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUpdateManyWithoutStockSymbolNestedInput
  }

  export type StockSymbolUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    cat?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    online?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    showName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbolShowName?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUncheckedUpdateManyWithoutStockSymbolNestedInput
  }

  export type StockSymbolCreateManyInput = {
    id?: bigint | number
    code: string
    cat?: string | null
    market: string
    online?: number
    symbol: string
    showName: string
    name?: string | null
    symbolShowName?: string | null
    trade?: number
    type?: number
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    change?: string | null
    changePercent?: string | null
    date?: string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockSymbolUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    cat?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    online?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    showName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbolShowName?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockSymbolUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    cat?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    online?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    showName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbolShowName?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockCreateInput = {
    id?: bigint | number
    code: string
    symbol: string
    name: string
    cname?: string | null
    type: string
    logo?: string | null
    sok?: string | null
    optional?: boolean
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    status?: $Enums.STOCK_STATUS
    change?: string | null
    changePercent?: string | null
    date?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockRecord?: StockRecordCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateInput = {
    id?: bigint | number
    code: string
    symbol: string
    name: string
    cname?: string | null
    type: string
    logo?: string | null
    sok?: string | null
    optional?: boolean
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    status?: $Enums.STOCK_STATUS
    change?: string | null
    changePercent?: string | null
    date?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockRecord?: StockRecordUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cname?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    sok?: NullableStringFieldUpdateOperationsInput | string | null
    optional?: BoolFieldUpdateOperationsInput | boolean
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTOCK_STATUSFieldUpdateOperationsInput | $Enums.STOCK_STATUS
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockRecord?: StockRecordUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cname?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    sok?: NullableStringFieldUpdateOperationsInput | string | null
    optional?: BoolFieldUpdateOperationsInput | boolean
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTOCK_STATUSFieldUpdateOperationsInput | $Enums.STOCK_STATUS
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockRecord?: StockRecordUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockCreateManyInput = {
    id?: bigint | number
    code: string
    symbol: string
    name: string
    cname?: string | null
    type: string
    logo?: string | null
    sok?: string | null
    optional?: boolean
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    status?: $Enums.STOCK_STATUS
    change?: string | null
    changePercent?: string | null
    date?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cname?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    sok?: NullableStringFieldUpdateOperationsInput | string | null
    optional?: BoolFieldUpdateOperationsInput | boolean
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTOCK_STATUSFieldUpdateOperationsInput | $Enums.STOCK_STATUS
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cname?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    sok?: NullableStringFieldUpdateOperationsInput | string | null
    optional?: BoolFieldUpdateOperationsInput | boolean
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTOCK_STATUSFieldUpdateOperationsInput | $Enums.STOCK_STATUS
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockRecordCreateInput = {
    id?: bigint | number
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date: string
    extra: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    stock: StockCreateNestedOneWithoutStockRecordInput
  }

  export type StockRecordUncheckedCreateInput = {
    id?: bigint | number
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date: string
    extra: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    stockId: bigint | number
  }

  export type StockRecordUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    extra?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutStockRecordNestedInput
  }

  export type StockRecordUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    extra?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StockRecordCreateManyInput = {
    id?: bigint | number
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date: string
    extra: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    stockId: bigint | number
  }

  export type StockRecordUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    extra?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockRecordUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    extra?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StockMarketCreateInput = {
    id?: bigint | number
    code?: string | null
    currency?: string | null
    showName?: string | null
    maxWithdrawal?: string | null
    minWithdrawal?: string | null
    feeRate?: string | null
    minFee?: string | null
    lever?: string | null
    mmr?: string | null
    allocationRate?: string | null
    frequency?: number | null
    bindingHours?: number | null
    headSymbols?: string | null
    sort?: number | null
    online?: number | null
    conline?: number | null
    openTime?: string | null
    timezone?: string | null
    beforeTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockMarketUncheckedCreateInput = {
    id?: bigint | number
    code?: string | null
    currency?: string | null
    showName?: string | null
    maxWithdrawal?: string | null
    minWithdrawal?: string | null
    feeRate?: string | null
    minFee?: string | null
    lever?: string | null
    mmr?: string | null
    allocationRate?: string | null
    frequency?: number | null
    bindingHours?: number | null
    headSymbols?: string | null
    sort?: number | null
    online?: number | null
    conline?: number | null
    openTime?: string | null
    timezone?: string | null
    beforeTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockMarketUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    showName?: NullableStringFieldUpdateOperationsInput | string | null
    maxWithdrawal?: NullableStringFieldUpdateOperationsInput | string | null
    minWithdrawal?: NullableStringFieldUpdateOperationsInput | string | null
    feeRate?: NullableStringFieldUpdateOperationsInput | string | null
    minFee?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    mmr?: NullableStringFieldUpdateOperationsInput | string | null
    allocationRate?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    bindingHours?: NullableIntFieldUpdateOperationsInput | number | null
    headSymbols?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    online?: NullableIntFieldUpdateOperationsInput | number | null
    conline?: NullableIntFieldUpdateOperationsInput | number | null
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    beforeTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockMarketUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    showName?: NullableStringFieldUpdateOperationsInput | string | null
    maxWithdrawal?: NullableStringFieldUpdateOperationsInput | string | null
    minWithdrawal?: NullableStringFieldUpdateOperationsInput | string | null
    feeRate?: NullableStringFieldUpdateOperationsInput | string | null
    minFee?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    mmr?: NullableStringFieldUpdateOperationsInput | string | null
    allocationRate?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    bindingHours?: NullableIntFieldUpdateOperationsInput | number | null
    headSymbols?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    online?: NullableIntFieldUpdateOperationsInput | number | null
    conline?: NullableIntFieldUpdateOperationsInput | number | null
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    beforeTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockMarketCreateManyInput = {
    id?: bigint | number
    code?: string | null
    currency?: string | null
    showName?: string | null
    maxWithdrawal?: string | null
    minWithdrawal?: string | null
    feeRate?: string | null
    minFee?: string | null
    lever?: string | null
    mmr?: string | null
    allocationRate?: string | null
    frequency?: number | null
    bindingHours?: number | null
    headSymbols?: string | null
    sort?: number | null
    online?: number | null
    conline?: number | null
    openTime?: string | null
    timezone?: string | null
    beforeTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockMarketUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    showName?: NullableStringFieldUpdateOperationsInput | string | null
    maxWithdrawal?: NullableStringFieldUpdateOperationsInput | string | null
    minWithdrawal?: NullableStringFieldUpdateOperationsInput | string | null
    feeRate?: NullableStringFieldUpdateOperationsInput | string | null
    minFee?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    mmr?: NullableStringFieldUpdateOperationsInput | string | null
    allocationRate?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    bindingHours?: NullableIntFieldUpdateOperationsInput | number | null
    headSymbols?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    online?: NullableIntFieldUpdateOperationsInput | number | null
    conline?: NullableIntFieldUpdateOperationsInput | number | null
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    beforeTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockMarketUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    showName?: NullableStringFieldUpdateOperationsInput | string | null
    maxWithdrawal?: NullableStringFieldUpdateOperationsInput | string | null
    minWithdrawal?: NullableStringFieldUpdateOperationsInput | string | null
    feeRate?: NullableStringFieldUpdateOperationsInput | string | null
    minFee?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    mmr?: NullableStringFieldUpdateOperationsInput | string | null
    allocationRate?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableIntFieldUpdateOperationsInput | number | null
    bindingHours?: NullableIntFieldUpdateOperationsInput | number | null
    headSymbols?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: NullableIntFieldUpdateOperationsInput | number | null
    online?: NullableIntFieldUpdateOperationsInput | number | null
    conline?: NullableIntFieldUpdateOperationsInput | number | null
    openTime?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    beforeTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockFavoriteCreateInput = {
    id?: bigint | number
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    memberId: bigint | number
    stockSymbolId: bigint | number
    createdAt?: Date | string
  }

  export type StockFavoriteUncheckedCreateInput = {
    id?: bigint | number
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    memberId: bigint | number
    stockSymbolId: bigint | number
    createdAt?: Date | string
  }

  export type StockFavoriteUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    stockSymbolId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockFavoriteUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    stockSymbolId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockFavoriteCreateManyInput = {
    id?: bigint | number
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    memberId: bigint | number
    stockSymbolId: bigint | number
    createdAt?: Date | string
  }

  export type StockFavoriteUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    stockSymbolId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockFavoriteUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    stockSymbolId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockSubscribeCreateInput = {
    id?: bigint | number
    market: string
    name: string
    code: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    upAt?: Date | string | null
    circulation?: number | null
    remainCirculation?: number | null
    ipoPrice: Decimal | DecimalJsLike | number | string
    issuePrice: Decimal | DecimalJsLike | number | string
    resultAt?: Date | string | null
    subAmount?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockSubscribeUncheckedCreateInput = {
    id?: bigint | number
    market: string
    name: string
    code: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    upAt?: Date | string | null
    circulation?: number | null
    remainCirculation?: number | null
    ipoPrice: Decimal | DecimalJsLike | number | string
    issuePrice: Decimal | DecimalJsLike | number | string
    resultAt?: Date | string | null
    subAmount?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockSubscribeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    circulation?: NullableIntFieldUpdateOperationsInput | number | null
    remainCirculation?: NullableIntFieldUpdateOperationsInput | number | null
    ipoPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    issuePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subAmount?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockSubscribeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    circulation?: NullableIntFieldUpdateOperationsInput | number | null
    remainCirculation?: NullableIntFieldUpdateOperationsInput | number | null
    ipoPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    issuePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subAmount?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockSubscribeCreateManyInput = {
    id?: bigint | number
    market: string
    name: string
    code: string
    startAt?: Date | string | null
    endAt?: Date | string | null
    upAt?: Date | string | null
    circulation?: number | null
    remainCirculation?: number | null
    ipoPrice: Decimal | DecimalJsLike | number | string
    issuePrice: Decimal | DecimalJsLike | number | string
    resultAt?: Date | string | null
    subAmount?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockSubscribeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    circulation?: NullableIntFieldUpdateOperationsInput | number | null
    remainCirculation?: NullableIntFieldUpdateOperationsInput | number | null
    ipoPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    issuePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subAmount?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockSubscribeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    circulation?: NullableIntFieldUpdateOperationsInput | number | null
    remainCirculation?: NullableIntFieldUpdateOperationsInput | number | null
    ipoPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    issuePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resultAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subAmount?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberSubscribeCreateInput = {
    id?: bigint | number
    market: string
    code: string
    name: string
    amount: number
    money: Decimal | DecimalJsLike | number | string
    no: string
    winningAmount?: number | null
    winningPrice?: Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: Decimal | DecimalJsLike | number | string | null
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    status?: number
    type?: number
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockSubscribeId: bigint | number
    member: MemberCreateNestedOneWithoutMemberSubscribeInput
  }

  export type MemberSubscribeUncheckedCreateInput = {
    id?: bigint | number
    market: string
    code: string
    name: string
    amount: number
    money: Decimal | DecimalJsLike | number | string
    no: string
    winningAmount?: number | null
    winningPrice?: Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: Decimal | DecimalJsLike | number | string | null
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    status?: number
    type?: number
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockSubscribeId: bigint | number
    memberId: bigint | number
  }

  export type MemberSubscribeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    no?: StringFieldUpdateOperationsInput | string
    winningAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockSubscribeId?: BigIntFieldUpdateOperationsInput | bigint | number
    member?: MemberUpdateOneRequiredWithoutMemberSubscribeNestedInput
  }

  export type MemberSubscribeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    no?: StringFieldUpdateOperationsInput | string
    winningAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockSubscribeId?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MemberSubscribeCreateManyInput = {
    id?: bigint | number
    market: string
    code: string
    name: string
    amount: number
    money: Decimal | DecimalJsLike | number | string
    no: string
    winningAmount?: number | null
    winningPrice?: Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: Decimal | DecimalJsLike | number | string | null
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    status?: number
    type?: number
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockSubscribeId: bigint | number
    memberId: bigint | number
  }

  export type MemberSubscribeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    no?: StringFieldUpdateOperationsInput | string
    winningAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockSubscribeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MemberSubscribeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    no?: StringFieldUpdateOperationsInput | string
    winningAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockSubscribeId?: BigIntFieldUpdateOperationsInput | bigint | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StockPositionCreateInput = {
    id?: bigint | number
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond?: string | null
    identifier?: string | null
    lever?: string | null
    stopLoss?: string | null
    takeProfit?: string | null
    market?: string | null
    type: number
    pl?: string | null
    rate?: string | null
    isBefore?: boolean
    currentPrice?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    member: MemberCreateNestedOneWithoutStockPostionInput
    stockSymbol: StockSymbolCreateNestedOneWithoutStockPostionInput
  }

  export type StockPositionUncheckedCreateInput = {
    id?: bigint | number
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond?: string | null
    identifier?: string | null
    lever?: string | null
    stopLoss?: string | null
    takeProfit?: string | null
    market?: string | null
    type: number
    pl?: string | null
    rate?: string | null
    isBefore?: boolean
    currentPrice?: string | null
    memberId: bigint | number
    stockSymbolId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockPositionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutStockPostionNestedInput
    stockSymbol?: StockSymbolUpdateOneRequiredWithoutStockPostionNestedInput
  }

  export type StockPositionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    stockSymbolId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockPositionCreateManyInput = {
    id?: bigint | number
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond?: string | null
    identifier?: string | null
    lever?: string | null
    stopLoss?: string | null
    takeProfit?: string | null
    market?: string | null
    type: number
    pl?: string | null
    rate?: string | null
    isBefore?: boolean
    currentPrice?: string | null
    memberId: bigint | number
    stockSymbolId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockPositionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockPositionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    stockSymbolId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberDetailCreateInput = {
    id?: bigint | number
    after?: string | null
    amount?: string | null
    before?: string | null
    market?: string | null
    type: number
    remark?: string | null
    member: MemberCreateNestedOneWithoutMemberDetailInput
  }

  export type MemberDetailUncheckedCreateInput = {
    id?: bigint | number
    after?: string | null
    amount?: string | null
    before?: string | null
    market?: string | null
    type: number
    remark?: string | null
    memberId: bigint | number
  }

  export type MemberDetailUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    after?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    member?: MemberUpdateOneRequiredWithoutMemberDetailNestedInput
  }

  export type MemberDetailUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    after?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MemberDetailCreateManyInput = {
    id?: bigint | number
    after?: string | null
    amount?: string | null
    before?: string | null
    market?: string | null
    type: number
    remark?: string | null
    memberId: bigint | number
  }

  export type MemberDetailUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    after?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberDetailUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    after?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MemberCardCreateInput = {
    id?: bigint | number
    name?: string | null
    type: $Enums.RechargeType
    detail: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
    member: MemberCreateNestedOneWithoutMemberCardsInput
  }

  export type MemberCardUncheckedCreateInput = {
    id?: bigint | number
    name?: string | null
    type: $Enums.RechargeType
    detail: JsonNullValueInput | InputJsonValue
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberCardUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    detail?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutMemberCardsNestedInput
  }

  export type MemberCardUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    detail?: JsonNullValueInput | InputJsonValue
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCardCreateManyInput = {
    id?: bigint | number
    name?: string | null
    type: $Enums.RechargeType
    detail: JsonNullValueInput | InputJsonValue
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberCardUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    detail?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCardUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    detail?: JsonNullValueInput | InputJsonValue
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCreateInput = {
    id?: bigint | number
    code?: string | null
    name: string
    en: string
    tel: string
    py: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CountryUncheckedCreateInput = {
    id?: bigint | number
    code?: string | null
    name: string
    en: string
    tel: string
    py: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CountryUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    en?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    py?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    en?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    py?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCreateManyInput = {
    id?: bigint | number
    code?: string | null
    name: string
    en: string
    tel: string
    py: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type CountryUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    en?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    py?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    en?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    py?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SettingCreateInput = {
    id?: bigint | number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SettingUncheckedCreateInput = {
    id?: bigint | number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SettingUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SettingUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SettingCreateManyInput = {
    id?: bigint | number
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SettingUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockResourceCreateInput = {
    id?: bigint | number
    amountScope: string
    frequencyScope: string
    market: string
    spreadScope: string
    endAt: string
    startAt: string
    symbol: string
    type?: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockResourceUncheckedCreateInput = {
    id?: bigint | number
    amountScope: string
    frequencyScope: string
    market: string
    spreadScope: string
    endAt: string
    startAt: string
    symbol: string
    type?: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockResourceUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amountScope?: StringFieldUpdateOperationsInput | string
    frequencyScope?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    spreadScope?: StringFieldUpdateOperationsInput | string
    endAt?: StringFieldUpdateOperationsInput | string
    startAt?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockResourceUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amountScope?: StringFieldUpdateOperationsInput | string
    frequencyScope?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    spreadScope?: StringFieldUpdateOperationsInput | string
    endAt?: StringFieldUpdateOperationsInput | string
    startAt?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockResourceCreateManyInput = {
    id?: bigint | number
    amountScope: string
    frequencyScope: string
    market: string
    spreadScope: string
    endAt: string
    startAt: string
    symbol: string
    type?: number
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockResourceUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amountScope?: StringFieldUpdateOperationsInput | string
    frequencyScope?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    spreadScope?: StringFieldUpdateOperationsInput | string
    endAt?: StringFieldUpdateOperationsInput | string
    startAt?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockResourceUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amountScope?: StringFieldUpdateOperationsInput | string
    frequencyScope?: StringFieldUpdateOperationsInput | string
    market?: StringFieldUpdateOperationsInput | string
    spreadScope?: StringFieldUpdateOperationsInput | string
    endAt?: StringFieldUpdateOperationsInput | string
    startAt?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockResourceRecordCreateInput = {
    id?: bigint | number
    open: string
    high: string
    close: string
    low: string
    time: string
    stockResourceId: bigint | number
  }

  export type StockResourceRecordUncheckedCreateInput = {
    id?: bigint | number
    open: string
    high: string
    close: string
    low: string
    time: string
    stockResourceId: bigint | number
  }

  export type StockResourceRecordUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    open?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    stockResourceId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StockResourceRecordUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    open?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    stockResourceId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StockResourceRecordCreateManyInput = {
    id?: bigint | number
    open: string
    high: string
    close: string
    low: string
    time: string
    stockResourceId: bigint | number
  }

  export type StockResourceRecordUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    open?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    stockResourceId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StockResourceRecordUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    open?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    stockResourceId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ArticleCreateInput = {
    id?: bigint | number
    thumb: string
    title: string
    market?: string | null
    crawlerThumb?: string | null
    source?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ArticleUncheckedCreateInput = {
    id?: bigint | number
    thumb: string
    title: string
    market?: string | null
    crawlerThumb?: string | null
    source?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ArticleUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    thumb?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    market?: NullableStringFieldUpdateOperationsInput | string | null
    crawlerThumb?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    thumb?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    market?: NullableStringFieldUpdateOperationsInput | string | null
    crawlerThumb?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleCreateManyInput = {
    id?: bigint | number
    thumb: string
    title: string
    market?: string | null
    crawlerThumb?: string | null
    source?: string | null
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type ArticleUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    thumb?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    market?: NullableStringFieldUpdateOperationsInput | string | null
    crawlerThumb?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    thumb?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    market?: NullableStringFieldUpdateOperationsInput | string | null
    crawlerThumb?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeCreateInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    account: string
    accountNetwork: string
    screens: JsonNullValueInput | InputJsonValue
    status?: number
    passMoney?: Decimal | DecimalJsLike | number | string
    convertMoney?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    member: MemberCreateNestedOneWithoutRechargesInput
  }

  export type RechargeUncheckedCreateInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    account: string
    accountNetwork: string
    screens: JsonNullValueInput | InputJsonValue
    status?: number
    passMoney?: Decimal | DecimalJsLike | number | string
    convertMoney?: Decimal | DecimalJsLike | number | string
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RechargeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    account?: StringFieldUpdateOperationsInput | string
    accountNetwork?: StringFieldUpdateOperationsInput | string
    screens?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    passMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutRechargesNestedInput
  }

  export type RechargeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    account?: StringFieldUpdateOperationsInput | string
    accountNetwork?: StringFieldUpdateOperationsInput | string
    screens?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    passMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeCreateManyInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    account: string
    accountNetwork: string
    screens: JsonNullValueInput | InputJsonValue
    status?: number
    passMoney?: Decimal | DecimalJsLike | number | string
    convertMoney?: Decimal | DecimalJsLike | number | string
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RechargeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    account?: StringFieldUpdateOperationsInput | string
    accountNetwork?: StringFieldUpdateOperationsInput | string
    screens?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    passMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    account?: StringFieldUpdateOperationsInput | string
    accountNetwork?: StringFieldUpdateOperationsInput | string
    screens?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    passMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawCreateInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    currency: string
    cryptoType?: string | null
    cryptoNetwork?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: Decimal | DecimalJsLike | number | string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    member: MemberCreateNestedOneWithoutWithdrawsInput
  }

  export type WithdrawUncheckedCreateInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    currency: string
    cryptoType?: string | null
    cryptoNetwork?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: Decimal | DecimalJsLike | number | string
    status?: number
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    currency?: StringFieldUpdateOperationsInput | string
    cryptoType?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoNetwork?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutWithdrawsNestedInput
  }

  export type WithdrawUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    currency?: StringFieldUpdateOperationsInput | string
    cryptoType?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoNetwork?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawCreateManyInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    currency: string
    cryptoType?: string | null
    cryptoNetwork?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: Decimal | DecimalJsLike | number | string
    status?: number
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    currency?: StringFieldUpdateOperationsInput | string
    cryptoType?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoNetwork?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    currency?: StringFieldUpdateOperationsInput | string
    cryptoType?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoNetwork?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeAccountCreateInput = {
    id?: bigint | number
    account: string
    accountAddress: string
    currency: string
    max?: Decimal | DecimalJsLike | number | string
    min?: Decimal | DecimalJsLike | number | string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RechargeAccountUncheckedCreateInput = {
    id?: bigint | number
    account: string
    accountAddress: string
    currency: string
    max?: Decimal | DecimalJsLike | number | string
    min?: Decimal | DecimalJsLike | number | string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RechargeAccountUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    account?: StringFieldUpdateOperationsInput | string
    accountAddress?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    max?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeAccountUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    account?: StringFieldUpdateOperationsInput | string
    accountAddress?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    max?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeAccountCreateManyInput = {
    id?: bigint | number
    account: string
    accountAddress: string
    currency: string
    max?: Decimal | DecimalJsLike | number | string
    min?: Decimal | DecimalJsLike | number | string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RechargeAccountUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    account?: StringFieldUpdateOperationsInput | string
    accountAddress?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    max?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeAccountUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    account?: StringFieldUpdateOperationsInput | string
    accountAddress?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    max?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGENDERFilter<$PrismaModel = never> = {
    equals?: $Enums.GENDER | EnumGENDERFieldRefInput<$PrismaModel>
    in?: $Enums.GENDER[]
    notIn?: $Enums.GENDER[]
    not?: NestedEnumGENDERFilter<$PrismaModel> | $Enums.GENDER
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGENDERWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GENDER | EnumGENDERFieldRefInput<$PrismaModel>
    in?: $Enums.GENDER[]
    notIn?: $Enums.GENDER[]
    not?: NestedEnumGENDERWithAggregatesFilter<$PrismaModel> | $Enums.GENDER
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGENDERFilter<$PrismaModel>
    _max?: NestedEnumGENDERFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StockPositionListRelationFilter = {
    every?: StockPositionWhereInput
    some?: StockPositionWhereInput
    none?: StockPositionWhereInput
  }

  export type MemberDetailListRelationFilter = {
    every?: MemberDetailWhereInput
    some?: MemberDetailWhereInput
    none?: MemberDetailWhereInput
  }

  export type MemberSubscribeListRelationFilter = {
    every?: MemberSubscribeWhereInput
    some?: MemberSubscribeWhereInput
    none?: MemberSubscribeWhereInput
  }

  export type MemberRechargeListRelationFilter = {
    every?: MemberRechargeWhereInput
    some?: MemberRechargeWhereInput
    none?: MemberRechargeWhereInput
  }

  export type MemberWithdrawListRelationFilter = {
    every?: MemberWithdrawWhereInput
    some?: MemberWithdrawWhereInput
    none?: MemberWithdrawWhereInput
  }

  export type MemberCardListRelationFilter = {
    every?: MemberCardWhereInput
    some?: MemberCardWhereInput
    none?: MemberCardWhereInput
  }

  export type RechargeListRelationFilter = {
    every?: RechargeWhereInput
    some?: RechargeWhereInput
    none?: RechargeWhereInput
  }

  export type WithdrawListRelationFilter = {
    every?: WithdrawWhereInput
    some?: WithdrawWhereInput
    none?: WithdrawWhereInput
  }

  export type StockPositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberSubscribeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberRechargeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberWithdrawOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RechargeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WithdrawOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    accountBalance?: SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    balance?: SortOrder
    unBalance?: SortOrder
    lockBalance?: SortOrder
    lastLoginTime?: SortOrder
  }

  export type MemberAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    unBalance?: SortOrder
    lockBalance?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    balance?: SortOrder
    unBalance?: SortOrder
    lockBalance?: SortOrder
    lastLoginTime?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    password?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    balance?: SortOrder
    unBalance?: SortOrder
    lockBalance?: SortOrder
    lastLoginTime?: SortOrder
  }

  export type MemberSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    balance?: SortOrder
    unBalance?: SortOrder
    lockBalance?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MemberRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type MemberRechargeCountOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    rechargeMoney?: SortOrder
    screen?: SortOrder
    market?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberRechargeAvgOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    rechargeMoney?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
  }

  export type MemberRechargeMaxOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    rechargeMoney?: SortOrder
    market?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberRechargeMinOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    rechargeMoney?: SortOrder
    market?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberRechargeSumOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    rechargeMoney?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type MemberWithdrawCountOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    remark?: SortOrder
    status?: SortOrder
    address?: SortOrder
    market?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberWithdrawAvgOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
  }

  export type MemberWithdrawMaxOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    remark?: SortOrder
    status?: SortOrder
    address?: SortOrder
    market?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberWithdrawMinOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    remark?: SortOrder
    status?: SortOrder
    address?: SortOrder
    market?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberWithdrawSumOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
  }

  export type StockSymbolSymbolMarketCompoundUniqueInput = {
    symbol: string
    market: string
  }

  export type StockSymbolCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    cat?: SortOrder
    market?: SortOrder
    online?: SortOrder
    symbol?: SortOrder
    showName?: SortOrder
    name?: SortOrder
    symbolShowName?: SortOrder
    trade?: SortOrder
    type?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    change?: SortOrder
    changePercent?: SortOrder
    date?: SortOrder
    sync?: SortOrder
    syncMarket?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSymbolAvgOrderByAggregateInput = {
    id?: SortOrder
    online?: SortOrder
    trade?: SortOrder
    type?: SortOrder
  }

  export type StockSymbolMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    cat?: SortOrder
    market?: SortOrder
    online?: SortOrder
    symbol?: SortOrder
    showName?: SortOrder
    name?: SortOrder
    symbolShowName?: SortOrder
    trade?: SortOrder
    type?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    change?: SortOrder
    changePercent?: SortOrder
    date?: SortOrder
    syncMarket?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSymbolMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    cat?: SortOrder
    market?: SortOrder
    online?: SortOrder
    symbol?: SortOrder
    showName?: SortOrder
    name?: SortOrder
    symbolShowName?: SortOrder
    trade?: SortOrder
    type?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    change?: SortOrder
    changePercent?: SortOrder
    date?: SortOrder
    syncMarket?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSymbolSumOrderByAggregateInput = {
    id?: SortOrder
    online?: SortOrder
    trade?: SortOrder
    type?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumSTOCK_STATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.STOCK_STATUS | EnumSTOCK_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.STOCK_STATUS[]
    notIn?: $Enums.STOCK_STATUS[]
    not?: NestedEnumSTOCK_STATUSFilter<$PrismaModel> | $Enums.STOCK_STATUS
  }

  export type StockRecordListRelationFilter = {
    every?: StockRecordWhereInput
    some?: StockRecordWhereInput
    none?: StockRecordWhereInput
  }

  export type StockRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockCodeSymbolTypeCompoundUniqueInput = {
    code: string
    symbol: string
    type: string
  }

  export type StockCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    cname?: SortOrder
    type?: SortOrder
    logo?: SortOrder
    sok?: SortOrder
    optional?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    status?: SortOrder
    change?: SortOrder
    changePercent?: SortOrder
    date?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    cname?: SortOrder
    type?: SortOrder
    logo?: SortOrder
    sok?: SortOrder
    optional?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    status?: SortOrder
    change?: SortOrder
    changePercent?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    name?: SortOrder
    cname?: SortOrder
    type?: SortOrder
    logo?: SortOrder
    sok?: SortOrder
    optional?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    status?: SortOrder
    change?: SortOrder
    changePercent?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumSTOCK_STATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.STOCK_STATUS | EnumSTOCK_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.STOCK_STATUS[]
    notIn?: $Enums.STOCK_STATUS[]
    not?: NestedEnumSTOCK_STATUSWithAggregatesFilter<$PrismaModel> | $Enums.STOCK_STATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSTOCK_STATUSFilter<$PrismaModel>
    _max?: NestedEnumSTOCK_STATUSFilter<$PrismaModel>
  }

  export type StockRelationFilter = {
    is?: StockWhereInput
    isNot?: StockWhereInput
  }

  export type StockRecordCountOrderByAggregateInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrder
    extra?: SortOrder
    createdAt?: SortOrder
    stockId?: SortOrder
  }

  export type StockRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    stockId?: SortOrder
  }

  export type StockRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    stockId?: SortOrder
  }

  export type StockRecordMinOrderByAggregateInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    stockId?: SortOrder
  }

  export type StockRecordSumOrderByAggregateInput = {
    id?: SortOrder
    stockId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StockMarketCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    currency?: SortOrder
    showName?: SortOrder
    maxWithdrawal?: SortOrder
    minWithdrawal?: SortOrder
    feeRate?: SortOrder
    minFee?: SortOrder
    lever?: SortOrder
    mmr?: SortOrder
    allocationRate?: SortOrder
    frequency?: SortOrder
    bindingHours?: SortOrder
    headSymbols?: SortOrder
    sort?: SortOrder
    online?: SortOrder
    conline?: SortOrder
    openTime?: SortOrder
    timezone?: SortOrder
    beforeTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockMarketAvgOrderByAggregateInput = {
    id?: SortOrder
    frequency?: SortOrder
    bindingHours?: SortOrder
    sort?: SortOrder
    online?: SortOrder
    conline?: SortOrder
  }

  export type StockMarketMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    currency?: SortOrder
    showName?: SortOrder
    maxWithdrawal?: SortOrder
    minWithdrawal?: SortOrder
    feeRate?: SortOrder
    minFee?: SortOrder
    lever?: SortOrder
    mmr?: SortOrder
    allocationRate?: SortOrder
    frequency?: SortOrder
    bindingHours?: SortOrder
    headSymbols?: SortOrder
    sort?: SortOrder
    online?: SortOrder
    conline?: SortOrder
    openTime?: SortOrder
    timezone?: SortOrder
    beforeTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockMarketMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    currency?: SortOrder
    showName?: SortOrder
    maxWithdrawal?: SortOrder
    minWithdrawal?: SortOrder
    feeRate?: SortOrder
    minFee?: SortOrder
    lever?: SortOrder
    mmr?: SortOrder
    allocationRate?: SortOrder
    frequency?: SortOrder
    bindingHours?: SortOrder
    headSymbols?: SortOrder
    sort?: SortOrder
    online?: SortOrder
    conline?: SortOrder
    openTime?: SortOrder
    timezone?: SortOrder
    beforeTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockMarketSumOrderByAggregateInput = {
    id?: SortOrder
    frequency?: SortOrder
    bindingHours?: SortOrder
    sort?: SortOrder
    online?: SortOrder
    conline?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StockFavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrder
    extra?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockFavoriteAvgOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
  }

  export type StockFavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockFavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    newPrice?: SortOrder
    open?: SortOrder
    close?: SortOrder
    high?: SortOrder
    low?: SortOrder
    amount?: SortOrder
    volume?: SortOrder
    date?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
  }

  export type StockFavoriteSumOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
  }

  export type StockSubscribeCountOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    name?: SortOrder
    code?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    upAt?: SortOrder
    circulation?: SortOrder
    remainCirculation?: SortOrder
    ipoPrice?: SortOrder
    issuePrice?: SortOrder
    resultAt?: SortOrder
    subAmount?: SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSubscribeAvgOrderByAggregateInput = {
    id?: SortOrder
    circulation?: SortOrder
    remainCirculation?: SortOrder
    ipoPrice?: SortOrder
    issuePrice?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type StockSubscribeMaxOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    name?: SortOrder
    code?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    upAt?: SortOrder
    circulation?: SortOrder
    remainCirculation?: SortOrder
    ipoPrice?: SortOrder
    issuePrice?: SortOrder
    resultAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSubscribeMinOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    name?: SortOrder
    code?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    upAt?: SortOrder
    circulation?: SortOrder
    remainCirculation?: SortOrder
    ipoPrice?: SortOrder
    issuePrice?: SortOrder
    resultAt?: SortOrder
    status?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSubscribeSumOrderByAggregateInput = {
    id?: SortOrder
    circulation?: SortOrder
    remainCirculation?: SortOrder
    ipoPrice?: SortOrder
    issuePrice?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type MemberSubscribeCountOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    code?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    money?: SortOrder
    no?: SortOrder
    winningAmount?: SortOrder
    winningPrice?: SortOrder
    totalWinningPrice?: SortOrder
    actualAmount?: SortOrder
    status?: SortOrder
    type?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockSubscribeId?: SortOrder
    memberId?: SortOrder
  }

  export type MemberSubscribeAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    money?: SortOrder
    winningAmount?: SortOrder
    winningPrice?: SortOrder
    totalWinningPrice?: SortOrder
    actualAmount?: SortOrder
    status?: SortOrder
    type?: SortOrder
    position?: SortOrder
    stockSubscribeId?: SortOrder
    memberId?: SortOrder
  }

  export type MemberSubscribeMaxOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    code?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    money?: SortOrder
    no?: SortOrder
    winningAmount?: SortOrder
    winningPrice?: SortOrder
    totalWinningPrice?: SortOrder
    actualAmount?: SortOrder
    status?: SortOrder
    type?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockSubscribeId?: SortOrder
    memberId?: SortOrder
  }

  export type MemberSubscribeMinOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    code?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    money?: SortOrder
    no?: SortOrder
    winningAmount?: SortOrder
    winningPrice?: SortOrder
    totalWinningPrice?: SortOrder
    actualAmount?: SortOrder
    status?: SortOrder
    type?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockSubscribeId?: SortOrder
    memberId?: SortOrder
  }

  export type MemberSubscribeSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    money?: SortOrder
    winningAmount?: SortOrder
    winningPrice?: SortOrder
    totalWinningPrice?: SortOrder
    actualAmount?: SortOrder
    status?: SortOrder
    type?: SortOrder
    position?: SortOrder
    stockSubscribeId?: SortOrder
    memberId?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type StockSymbolRelationFilter = {
    is?: StockSymbolWhereInput
    isNot?: StockSymbolWhereInput
  }

  export type StockPositionCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    blast?: SortOrder
    price?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    bond?: SortOrder
    identifier?: SortOrder
    lever?: SortOrder
    stopLoss?: SortOrder
    takeProfit?: SortOrder
    market?: SortOrder
    type?: SortOrder
    pl?: SortOrder
    rate?: SortOrder
    isBefore?: SortOrder
    currentPrice?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockPositionAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    type?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
  }

  export type StockPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    blast?: SortOrder
    price?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    bond?: SortOrder
    identifier?: SortOrder
    lever?: SortOrder
    stopLoss?: SortOrder
    takeProfit?: SortOrder
    market?: SortOrder
    type?: SortOrder
    pl?: SortOrder
    rate?: SortOrder
    isBefore?: SortOrder
    currentPrice?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockPositionMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    blast?: SortOrder
    price?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    bond?: SortOrder
    identifier?: SortOrder
    lever?: SortOrder
    stopLoss?: SortOrder
    takeProfit?: SortOrder
    market?: SortOrder
    type?: SortOrder
    pl?: SortOrder
    rate?: SortOrder
    isBefore?: SortOrder
    currentPrice?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockPositionSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    mode?: SortOrder
    status?: SortOrder
    type?: SortOrder
    memberId?: SortOrder
    stockSymbolId?: SortOrder
  }

  export type MemberDetailCountOrderByAggregateInput = {
    id?: SortOrder
    after?: SortOrder
    amount?: SortOrder
    before?: SortOrder
    market?: SortOrder
    type?: SortOrder
    remark?: SortOrder
    memberId?: SortOrder
  }

  export type MemberDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    memberId?: SortOrder
  }

  export type MemberDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    after?: SortOrder
    amount?: SortOrder
    before?: SortOrder
    market?: SortOrder
    type?: SortOrder
    remark?: SortOrder
    memberId?: SortOrder
  }

  export type MemberDetailMinOrderByAggregateInput = {
    id?: SortOrder
    after?: SortOrder
    amount?: SortOrder
    before?: SortOrder
    market?: SortOrder
    type?: SortOrder
    remark?: SortOrder
    memberId?: SortOrder
  }

  export type MemberDetailSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    memberId?: SortOrder
  }

  export type EnumRechargeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RechargeType | EnumRechargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RechargeType[]
    notIn?: $Enums.RechargeType[]
    not?: NestedEnumRechargeTypeFilter<$PrismaModel> | $Enums.RechargeType
  }

  export type MemberCardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    detail?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberCardAvgOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
  }

  export type MemberCardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberCardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberCardSumOrderByAggregateInput = {
    id?: SortOrder
    memberId?: SortOrder
  }

  export type EnumRechargeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RechargeType | EnumRechargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RechargeType[]
    notIn?: $Enums.RechargeType[]
    not?: NestedEnumRechargeTypeWithAggregatesFilter<$PrismaModel> | $Enums.RechargeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRechargeTypeFilter<$PrismaModel>
    _max?: NestedEnumRechargeTypeFilter<$PrismaModel>
  }

  export type CountryPyTelNameCompoundUniqueInput = {
    py: string
    tel: string
    name: string
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    en?: SortOrder
    tel?: SortOrder
    py?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    en?: SortOrder
    tel?: SortOrder
    py?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    en?: SortOrder
    tel?: SortOrder
    py?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StockResourceCountOrderByAggregateInput = {
    id?: SortOrder
    amountScope?: SortOrder
    frequencyScope?: SortOrder
    market?: SortOrder
    spreadScope?: SortOrder
    endAt?: SortOrder
    startAt?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
  }

  export type StockResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    amountScope?: SortOrder
    frequencyScope?: SortOrder
    market?: SortOrder
    spreadScope?: SortOrder
    endAt?: SortOrder
    startAt?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockResourceMinOrderByAggregateInput = {
    id?: SortOrder
    amountScope?: SortOrder
    frequencyScope?: SortOrder
    market?: SortOrder
    spreadScope?: SortOrder
    endAt?: SortOrder
    startAt?: SortOrder
    symbol?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockResourceSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
  }

  export type StockResourceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    open?: SortOrder
    high?: SortOrder
    close?: SortOrder
    low?: SortOrder
    time?: SortOrder
    stockResourceId?: SortOrder
  }

  export type StockResourceRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    stockResourceId?: SortOrder
  }

  export type StockResourceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    open?: SortOrder
    high?: SortOrder
    close?: SortOrder
    low?: SortOrder
    time?: SortOrder
    stockResourceId?: SortOrder
  }

  export type StockResourceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    open?: SortOrder
    high?: SortOrder
    close?: SortOrder
    low?: SortOrder
    time?: SortOrder
    stockResourceId?: SortOrder
  }

  export type StockResourceRecordSumOrderByAggregateInput = {
    id?: SortOrder
    stockResourceId?: SortOrder
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    thumb?: SortOrder
    title?: SortOrder
    market?: SortOrder
    crawlerThumb?: SortOrder
    source?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    thumb?: SortOrder
    title?: SortOrder
    market?: SortOrder
    crawlerThumb?: SortOrder
    source?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    thumb?: SortOrder
    title?: SortOrder
    market?: SortOrder
    crawlerThumb?: SortOrder
    source?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RechargeCountOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    account?: SortOrder
    accountNetwork?: SortOrder
    screens?: SortOrder
    status?: SortOrder
    passMoney?: SortOrder
    convertMoney?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargeAvgOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    status?: SortOrder
    passMoney?: SortOrder
    convertMoney?: SortOrder
    memberId?: SortOrder
  }

  export type RechargeMaxOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    account?: SortOrder
    accountNetwork?: SortOrder
    status?: SortOrder
    passMoney?: SortOrder
    convertMoney?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargeMinOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    account?: SortOrder
    accountNetwork?: SortOrder
    status?: SortOrder
    passMoney?: SortOrder
    convertMoney?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargeSumOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    status?: SortOrder
    passMoney?: SortOrder
    convertMoney?: SortOrder
    memberId?: SortOrder
  }

  export type WithdrawCountOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    cryptoType?: SortOrder
    cryptoNetwork?: SortOrder
    card?: SortOrder
    convertMoney?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawAvgOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    convertMoney?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
  }

  export type WithdrawMaxOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    cryptoType?: SortOrder
    cryptoNetwork?: SortOrder
    convertMoney?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawMinOrderByAggregateInput = {
    id?: SortOrder
    market?: SortOrder
    money?: SortOrder
    type?: SortOrder
    currency?: SortOrder
    cryptoType?: SortOrder
    cryptoNetwork?: SortOrder
    convertMoney?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WithdrawSumOrderByAggregateInput = {
    id?: SortOrder
    money?: SortOrder
    convertMoney?: SortOrder
    status?: SortOrder
    memberId?: SortOrder
  }

  export type RechargeAccountCountOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    accountAddress?: SortOrder
    currency?: SortOrder
    max?: SortOrder
    min?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargeAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    min?: SortOrder
    status?: SortOrder
  }

  export type RechargeAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    accountAddress?: SortOrder
    currency?: SortOrder
    max?: SortOrder
    min?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargeAccountMinOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    accountAddress?: SortOrder
    currency?: SortOrder
    max?: SortOrder
    min?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RechargeAccountSumOrderByAggregateInput = {
    id?: SortOrder
    max?: SortOrder
    min?: SortOrder
    status?: SortOrder
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumGENDERFieldUpdateOperationsInput = {
    set?: $Enums.GENDER
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StockPositionCreateNestedManyWithoutMemberInput = {
    create?: XOR<StockPositionCreateWithoutMemberInput, StockPositionUncheckedCreateWithoutMemberInput> | StockPositionCreateWithoutMemberInput[] | StockPositionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: StockPositionCreateOrConnectWithoutMemberInput | StockPositionCreateOrConnectWithoutMemberInput[]
    createMany?: StockPositionCreateManyMemberInputEnvelope
    connect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
  }

  export type MemberDetailCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberDetailCreateWithoutMemberInput, MemberDetailUncheckedCreateWithoutMemberInput> | MemberDetailCreateWithoutMemberInput[] | MemberDetailUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberDetailCreateOrConnectWithoutMemberInput | MemberDetailCreateOrConnectWithoutMemberInput[]
    createMany?: MemberDetailCreateManyMemberInputEnvelope
    connect?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
  }

  export type MemberSubscribeCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberSubscribeCreateWithoutMemberInput, MemberSubscribeUncheckedCreateWithoutMemberInput> | MemberSubscribeCreateWithoutMemberInput[] | MemberSubscribeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberSubscribeCreateOrConnectWithoutMemberInput | MemberSubscribeCreateOrConnectWithoutMemberInput[]
    createMany?: MemberSubscribeCreateManyMemberInputEnvelope
    connect?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
  }

  export type MemberRechargeCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberRechargeCreateWithoutMemberInput, MemberRechargeUncheckedCreateWithoutMemberInput> | MemberRechargeCreateWithoutMemberInput[] | MemberRechargeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberRechargeCreateOrConnectWithoutMemberInput | MemberRechargeCreateOrConnectWithoutMemberInput[]
    createMany?: MemberRechargeCreateManyMemberInputEnvelope
    connect?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
  }

  export type MemberWithdrawCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberWithdrawCreateWithoutMemberInput, MemberWithdrawUncheckedCreateWithoutMemberInput> | MemberWithdrawCreateWithoutMemberInput[] | MemberWithdrawUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberWithdrawCreateOrConnectWithoutMemberInput | MemberWithdrawCreateOrConnectWithoutMemberInput[]
    createMany?: MemberWithdrawCreateManyMemberInputEnvelope
    connect?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
  }

  export type MemberCardCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberCardCreateWithoutMemberInput, MemberCardUncheckedCreateWithoutMemberInput> | MemberCardCreateWithoutMemberInput[] | MemberCardUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberCardCreateOrConnectWithoutMemberInput | MemberCardCreateOrConnectWithoutMemberInput[]
    createMany?: MemberCardCreateManyMemberInputEnvelope
    connect?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
  }

  export type RechargeCreateNestedManyWithoutMemberInput = {
    create?: XOR<RechargeCreateWithoutMemberInput, RechargeUncheckedCreateWithoutMemberInput> | RechargeCreateWithoutMemberInput[] | RechargeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: RechargeCreateOrConnectWithoutMemberInput | RechargeCreateOrConnectWithoutMemberInput[]
    createMany?: RechargeCreateManyMemberInputEnvelope
    connect?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
  }

  export type WithdrawCreateNestedManyWithoutMemberInput = {
    create?: XOR<WithdrawCreateWithoutMemberInput, WithdrawUncheckedCreateWithoutMemberInput> | WithdrawCreateWithoutMemberInput[] | WithdrawUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: WithdrawCreateOrConnectWithoutMemberInput | WithdrawCreateOrConnectWithoutMemberInput[]
    createMany?: WithdrawCreateManyMemberInputEnvelope
    connect?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
  }

  export type StockPositionUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<StockPositionCreateWithoutMemberInput, StockPositionUncheckedCreateWithoutMemberInput> | StockPositionCreateWithoutMemberInput[] | StockPositionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: StockPositionCreateOrConnectWithoutMemberInput | StockPositionCreateOrConnectWithoutMemberInput[]
    createMany?: StockPositionCreateManyMemberInputEnvelope
    connect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
  }

  export type MemberDetailUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberDetailCreateWithoutMemberInput, MemberDetailUncheckedCreateWithoutMemberInput> | MemberDetailCreateWithoutMemberInput[] | MemberDetailUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberDetailCreateOrConnectWithoutMemberInput | MemberDetailCreateOrConnectWithoutMemberInput[]
    createMany?: MemberDetailCreateManyMemberInputEnvelope
    connect?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
  }

  export type MemberSubscribeUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberSubscribeCreateWithoutMemberInput, MemberSubscribeUncheckedCreateWithoutMemberInput> | MemberSubscribeCreateWithoutMemberInput[] | MemberSubscribeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberSubscribeCreateOrConnectWithoutMemberInput | MemberSubscribeCreateOrConnectWithoutMemberInput[]
    createMany?: MemberSubscribeCreateManyMemberInputEnvelope
    connect?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
  }

  export type MemberRechargeUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberRechargeCreateWithoutMemberInput, MemberRechargeUncheckedCreateWithoutMemberInput> | MemberRechargeCreateWithoutMemberInput[] | MemberRechargeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberRechargeCreateOrConnectWithoutMemberInput | MemberRechargeCreateOrConnectWithoutMemberInput[]
    createMany?: MemberRechargeCreateManyMemberInputEnvelope
    connect?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
  }

  export type MemberWithdrawUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberWithdrawCreateWithoutMemberInput, MemberWithdrawUncheckedCreateWithoutMemberInput> | MemberWithdrawCreateWithoutMemberInput[] | MemberWithdrawUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberWithdrawCreateOrConnectWithoutMemberInput | MemberWithdrawCreateOrConnectWithoutMemberInput[]
    createMany?: MemberWithdrawCreateManyMemberInputEnvelope
    connect?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
  }

  export type MemberCardUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<MemberCardCreateWithoutMemberInput, MemberCardUncheckedCreateWithoutMemberInput> | MemberCardCreateWithoutMemberInput[] | MemberCardUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberCardCreateOrConnectWithoutMemberInput | MemberCardCreateOrConnectWithoutMemberInput[]
    createMany?: MemberCardCreateManyMemberInputEnvelope
    connect?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
  }

  export type RechargeUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<RechargeCreateWithoutMemberInput, RechargeUncheckedCreateWithoutMemberInput> | RechargeCreateWithoutMemberInput[] | RechargeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: RechargeCreateOrConnectWithoutMemberInput | RechargeCreateOrConnectWithoutMemberInput[]
    createMany?: RechargeCreateManyMemberInputEnvelope
    connect?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
  }

  export type WithdrawUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<WithdrawCreateWithoutMemberInput, WithdrawUncheckedCreateWithoutMemberInput> | WithdrawCreateWithoutMemberInput[] | WithdrawUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: WithdrawCreateOrConnectWithoutMemberInput | WithdrawCreateOrConnectWithoutMemberInput[]
    createMany?: WithdrawCreateManyMemberInputEnvelope
    connect?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StockPositionUpdateManyWithoutMemberNestedInput = {
    create?: XOR<StockPositionCreateWithoutMemberInput, StockPositionUncheckedCreateWithoutMemberInput> | StockPositionCreateWithoutMemberInput[] | StockPositionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: StockPositionCreateOrConnectWithoutMemberInput | StockPositionCreateOrConnectWithoutMemberInput[]
    upsert?: StockPositionUpsertWithWhereUniqueWithoutMemberInput | StockPositionUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: StockPositionCreateManyMemberInputEnvelope
    set?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    disconnect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    delete?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    connect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    update?: StockPositionUpdateWithWhereUniqueWithoutMemberInput | StockPositionUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: StockPositionUpdateManyWithWhereWithoutMemberInput | StockPositionUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: StockPositionScalarWhereInput | StockPositionScalarWhereInput[]
  }

  export type MemberDetailUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberDetailCreateWithoutMemberInput, MemberDetailUncheckedCreateWithoutMemberInput> | MemberDetailCreateWithoutMemberInput[] | MemberDetailUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberDetailCreateOrConnectWithoutMemberInput | MemberDetailCreateOrConnectWithoutMemberInput[]
    upsert?: MemberDetailUpsertWithWhereUniqueWithoutMemberInput | MemberDetailUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberDetailCreateManyMemberInputEnvelope
    set?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
    disconnect?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
    delete?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
    connect?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
    update?: MemberDetailUpdateWithWhereUniqueWithoutMemberInput | MemberDetailUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberDetailUpdateManyWithWhereWithoutMemberInput | MemberDetailUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberDetailScalarWhereInput | MemberDetailScalarWhereInput[]
  }

  export type MemberSubscribeUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberSubscribeCreateWithoutMemberInput, MemberSubscribeUncheckedCreateWithoutMemberInput> | MemberSubscribeCreateWithoutMemberInput[] | MemberSubscribeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberSubscribeCreateOrConnectWithoutMemberInput | MemberSubscribeCreateOrConnectWithoutMemberInput[]
    upsert?: MemberSubscribeUpsertWithWhereUniqueWithoutMemberInput | MemberSubscribeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberSubscribeCreateManyMemberInputEnvelope
    set?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
    disconnect?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
    delete?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
    connect?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
    update?: MemberSubscribeUpdateWithWhereUniqueWithoutMemberInput | MemberSubscribeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberSubscribeUpdateManyWithWhereWithoutMemberInput | MemberSubscribeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberSubscribeScalarWhereInput | MemberSubscribeScalarWhereInput[]
  }

  export type MemberRechargeUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberRechargeCreateWithoutMemberInput, MemberRechargeUncheckedCreateWithoutMemberInput> | MemberRechargeCreateWithoutMemberInput[] | MemberRechargeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberRechargeCreateOrConnectWithoutMemberInput | MemberRechargeCreateOrConnectWithoutMemberInput[]
    upsert?: MemberRechargeUpsertWithWhereUniqueWithoutMemberInput | MemberRechargeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberRechargeCreateManyMemberInputEnvelope
    set?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
    disconnect?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
    delete?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
    connect?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
    update?: MemberRechargeUpdateWithWhereUniqueWithoutMemberInput | MemberRechargeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberRechargeUpdateManyWithWhereWithoutMemberInput | MemberRechargeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberRechargeScalarWhereInput | MemberRechargeScalarWhereInput[]
  }

  export type MemberWithdrawUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberWithdrawCreateWithoutMemberInput, MemberWithdrawUncheckedCreateWithoutMemberInput> | MemberWithdrawCreateWithoutMemberInput[] | MemberWithdrawUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberWithdrawCreateOrConnectWithoutMemberInput | MemberWithdrawCreateOrConnectWithoutMemberInput[]
    upsert?: MemberWithdrawUpsertWithWhereUniqueWithoutMemberInput | MemberWithdrawUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberWithdrawCreateManyMemberInputEnvelope
    set?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
    disconnect?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
    delete?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
    connect?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
    update?: MemberWithdrawUpdateWithWhereUniqueWithoutMemberInput | MemberWithdrawUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberWithdrawUpdateManyWithWhereWithoutMemberInput | MemberWithdrawUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberWithdrawScalarWhereInput | MemberWithdrawScalarWhereInput[]
  }

  export type MemberCardUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberCardCreateWithoutMemberInput, MemberCardUncheckedCreateWithoutMemberInput> | MemberCardCreateWithoutMemberInput[] | MemberCardUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberCardCreateOrConnectWithoutMemberInput | MemberCardCreateOrConnectWithoutMemberInput[]
    upsert?: MemberCardUpsertWithWhereUniqueWithoutMemberInput | MemberCardUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberCardCreateManyMemberInputEnvelope
    set?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
    disconnect?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
    delete?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
    connect?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
    update?: MemberCardUpdateWithWhereUniqueWithoutMemberInput | MemberCardUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberCardUpdateManyWithWhereWithoutMemberInput | MemberCardUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberCardScalarWhereInput | MemberCardScalarWhereInput[]
  }

  export type RechargeUpdateManyWithoutMemberNestedInput = {
    create?: XOR<RechargeCreateWithoutMemberInput, RechargeUncheckedCreateWithoutMemberInput> | RechargeCreateWithoutMemberInput[] | RechargeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: RechargeCreateOrConnectWithoutMemberInput | RechargeCreateOrConnectWithoutMemberInput[]
    upsert?: RechargeUpsertWithWhereUniqueWithoutMemberInput | RechargeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: RechargeCreateManyMemberInputEnvelope
    set?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
    disconnect?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
    delete?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
    connect?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
    update?: RechargeUpdateWithWhereUniqueWithoutMemberInput | RechargeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: RechargeUpdateManyWithWhereWithoutMemberInput | RechargeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: RechargeScalarWhereInput | RechargeScalarWhereInput[]
  }

  export type WithdrawUpdateManyWithoutMemberNestedInput = {
    create?: XOR<WithdrawCreateWithoutMemberInput, WithdrawUncheckedCreateWithoutMemberInput> | WithdrawCreateWithoutMemberInput[] | WithdrawUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: WithdrawCreateOrConnectWithoutMemberInput | WithdrawCreateOrConnectWithoutMemberInput[]
    upsert?: WithdrawUpsertWithWhereUniqueWithoutMemberInput | WithdrawUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: WithdrawCreateManyMemberInputEnvelope
    set?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
    disconnect?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
    delete?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
    connect?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
    update?: WithdrawUpdateWithWhereUniqueWithoutMemberInput | WithdrawUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: WithdrawUpdateManyWithWhereWithoutMemberInput | WithdrawUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: WithdrawScalarWhereInput | WithdrawScalarWhereInput[]
  }

  export type StockPositionUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<StockPositionCreateWithoutMemberInput, StockPositionUncheckedCreateWithoutMemberInput> | StockPositionCreateWithoutMemberInput[] | StockPositionUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: StockPositionCreateOrConnectWithoutMemberInput | StockPositionCreateOrConnectWithoutMemberInput[]
    upsert?: StockPositionUpsertWithWhereUniqueWithoutMemberInput | StockPositionUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: StockPositionCreateManyMemberInputEnvelope
    set?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    disconnect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    delete?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    connect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    update?: StockPositionUpdateWithWhereUniqueWithoutMemberInput | StockPositionUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: StockPositionUpdateManyWithWhereWithoutMemberInput | StockPositionUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: StockPositionScalarWhereInput | StockPositionScalarWhereInput[]
  }

  export type MemberDetailUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberDetailCreateWithoutMemberInput, MemberDetailUncheckedCreateWithoutMemberInput> | MemberDetailCreateWithoutMemberInput[] | MemberDetailUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberDetailCreateOrConnectWithoutMemberInput | MemberDetailCreateOrConnectWithoutMemberInput[]
    upsert?: MemberDetailUpsertWithWhereUniqueWithoutMemberInput | MemberDetailUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberDetailCreateManyMemberInputEnvelope
    set?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
    disconnect?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
    delete?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
    connect?: MemberDetailWhereUniqueInput | MemberDetailWhereUniqueInput[]
    update?: MemberDetailUpdateWithWhereUniqueWithoutMemberInput | MemberDetailUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberDetailUpdateManyWithWhereWithoutMemberInput | MemberDetailUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberDetailScalarWhereInput | MemberDetailScalarWhereInput[]
  }

  export type MemberSubscribeUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberSubscribeCreateWithoutMemberInput, MemberSubscribeUncheckedCreateWithoutMemberInput> | MemberSubscribeCreateWithoutMemberInput[] | MemberSubscribeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberSubscribeCreateOrConnectWithoutMemberInput | MemberSubscribeCreateOrConnectWithoutMemberInput[]
    upsert?: MemberSubscribeUpsertWithWhereUniqueWithoutMemberInput | MemberSubscribeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberSubscribeCreateManyMemberInputEnvelope
    set?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
    disconnect?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
    delete?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
    connect?: MemberSubscribeWhereUniqueInput | MemberSubscribeWhereUniqueInput[]
    update?: MemberSubscribeUpdateWithWhereUniqueWithoutMemberInput | MemberSubscribeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberSubscribeUpdateManyWithWhereWithoutMemberInput | MemberSubscribeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberSubscribeScalarWhereInput | MemberSubscribeScalarWhereInput[]
  }

  export type MemberRechargeUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberRechargeCreateWithoutMemberInput, MemberRechargeUncheckedCreateWithoutMemberInput> | MemberRechargeCreateWithoutMemberInput[] | MemberRechargeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberRechargeCreateOrConnectWithoutMemberInput | MemberRechargeCreateOrConnectWithoutMemberInput[]
    upsert?: MemberRechargeUpsertWithWhereUniqueWithoutMemberInput | MemberRechargeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberRechargeCreateManyMemberInputEnvelope
    set?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
    disconnect?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
    delete?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
    connect?: MemberRechargeWhereUniqueInput | MemberRechargeWhereUniqueInput[]
    update?: MemberRechargeUpdateWithWhereUniqueWithoutMemberInput | MemberRechargeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberRechargeUpdateManyWithWhereWithoutMemberInput | MemberRechargeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberRechargeScalarWhereInput | MemberRechargeScalarWhereInput[]
  }

  export type MemberWithdrawUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberWithdrawCreateWithoutMemberInput, MemberWithdrawUncheckedCreateWithoutMemberInput> | MemberWithdrawCreateWithoutMemberInput[] | MemberWithdrawUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberWithdrawCreateOrConnectWithoutMemberInput | MemberWithdrawCreateOrConnectWithoutMemberInput[]
    upsert?: MemberWithdrawUpsertWithWhereUniqueWithoutMemberInput | MemberWithdrawUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberWithdrawCreateManyMemberInputEnvelope
    set?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
    disconnect?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
    delete?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
    connect?: MemberWithdrawWhereUniqueInput | MemberWithdrawWhereUniqueInput[]
    update?: MemberWithdrawUpdateWithWhereUniqueWithoutMemberInput | MemberWithdrawUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberWithdrawUpdateManyWithWhereWithoutMemberInput | MemberWithdrawUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberWithdrawScalarWhereInput | MemberWithdrawScalarWhereInput[]
  }

  export type MemberCardUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<MemberCardCreateWithoutMemberInput, MemberCardUncheckedCreateWithoutMemberInput> | MemberCardCreateWithoutMemberInput[] | MemberCardUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: MemberCardCreateOrConnectWithoutMemberInput | MemberCardCreateOrConnectWithoutMemberInput[]
    upsert?: MemberCardUpsertWithWhereUniqueWithoutMemberInput | MemberCardUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: MemberCardCreateManyMemberInputEnvelope
    set?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
    disconnect?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
    delete?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
    connect?: MemberCardWhereUniqueInput | MemberCardWhereUniqueInput[]
    update?: MemberCardUpdateWithWhereUniqueWithoutMemberInput | MemberCardUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: MemberCardUpdateManyWithWhereWithoutMemberInput | MemberCardUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: MemberCardScalarWhereInput | MemberCardScalarWhereInput[]
  }

  export type RechargeUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<RechargeCreateWithoutMemberInput, RechargeUncheckedCreateWithoutMemberInput> | RechargeCreateWithoutMemberInput[] | RechargeUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: RechargeCreateOrConnectWithoutMemberInput | RechargeCreateOrConnectWithoutMemberInput[]
    upsert?: RechargeUpsertWithWhereUniqueWithoutMemberInput | RechargeUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: RechargeCreateManyMemberInputEnvelope
    set?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
    disconnect?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
    delete?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
    connect?: RechargeWhereUniqueInput | RechargeWhereUniqueInput[]
    update?: RechargeUpdateWithWhereUniqueWithoutMemberInput | RechargeUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: RechargeUpdateManyWithWhereWithoutMemberInput | RechargeUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: RechargeScalarWhereInput | RechargeScalarWhereInput[]
  }

  export type WithdrawUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<WithdrawCreateWithoutMemberInput, WithdrawUncheckedCreateWithoutMemberInput> | WithdrawCreateWithoutMemberInput[] | WithdrawUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: WithdrawCreateOrConnectWithoutMemberInput | WithdrawCreateOrConnectWithoutMemberInput[]
    upsert?: WithdrawUpsertWithWhereUniqueWithoutMemberInput | WithdrawUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: WithdrawCreateManyMemberInputEnvelope
    set?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
    disconnect?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
    delete?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
    connect?: WithdrawWhereUniqueInput | WithdrawWhereUniqueInput[]
    update?: WithdrawUpdateWithWhereUniqueWithoutMemberInput | WithdrawUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: WithdrawUpdateManyWithWhereWithoutMemberInput | WithdrawUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: WithdrawScalarWhereInput | WithdrawScalarWhereInput[]
  }

  export type MemberCreateNestedOneWithoutMemberRechargesInput = {
    create?: XOR<MemberCreateWithoutMemberRechargesInput, MemberUncheckedCreateWithoutMemberRechargesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberRechargesInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutMemberRechargesNestedInput = {
    create?: XOR<MemberCreateWithoutMemberRechargesInput, MemberUncheckedCreateWithoutMemberRechargesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberRechargesInput
    upsert?: MemberUpsertWithoutMemberRechargesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMemberRechargesInput, MemberUpdateWithoutMemberRechargesInput>, MemberUncheckedUpdateWithoutMemberRechargesInput>
  }

  export type MemberCreateNestedOneWithoutMemberWithdrawsInput = {
    create?: XOR<MemberCreateWithoutMemberWithdrawsInput, MemberUncheckedCreateWithoutMemberWithdrawsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberWithdrawsInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutMemberWithdrawsNestedInput = {
    create?: XOR<MemberCreateWithoutMemberWithdrawsInput, MemberUncheckedCreateWithoutMemberWithdrawsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberWithdrawsInput
    upsert?: MemberUpsertWithoutMemberWithdrawsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMemberWithdrawsInput, MemberUpdateWithoutMemberWithdrawsInput>, MemberUncheckedUpdateWithoutMemberWithdrawsInput>
  }

  export type StockPositionCreateNestedManyWithoutStockSymbolInput = {
    create?: XOR<StockPositionCreateWithoutStockSymbolInput, StockPositionUncheckedCreateWithoutStockSymbolInput> | StockPositionCreateWithoutStockSymbolInput[] | StockPositionUncheckedCreateWithoutStockSymbolInput[]
    connectOrCreate?: StockPositionCreateOrConnectWithoutStockSymbolInput | StockPositionCreateOrConnectWithoutStockSymbolInput[]
    createMany?: StockPositionCreateManyStockSymbolInputEnvelope
    connect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
  }

  export type StockPositionUncheckedCreateNestedManyWithoutStockSymbolInput = {
    create?: XOR<StockPositionCreateWithoutStockSymbolInput, StockPositionUncheckedCreateWithoutStockSymbolInput> | StockPositionCreateWithoutStockSymbolInput[] | StockPositionUncheckedCreateWithoutStockSymbolInput[]
    connectOrCreate?: StockPositionCreateOrConnectWithoutStockSymbolInput | StockPositionCreateOrConnectWithoutStockSymbolInput[]
    createMany?: StockPositionCreateManyStockSymbolInputEnvelope
    connect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
  }

  export type StockPositionUpdateManyWithoutStockSymbolNestedInput = {
    create?: XOR<StockPositionCreateWithoutStockSymbolInput, StockPositionUncheckedCreateWithoutStockSymbolInput> | StockPositionCreateWithoutStockSymbolInput[] | StockPositionUncheckedCreateWithoutStockSymbolInput[]
    connectOrCreate?: StockPositionCreateOrConnectWithoutStockSymbolInput | StockPositionCreateOrConnectWithoutStockSymbolInput[]
    upsert?: StockPositionUpsertWithWhereUniqueWithoutStockSymbolInput | StockPositionUpsertWithWhereUniqueWithoutStockSymbolInput[]
    createMany?: StockPositionCreateManyStockSymbolInputEnvelope
    set?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    disconnect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    delete?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    connect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    update?: StockPositionUpdateWithWhereUniqueWithoutStockSymbolInput | StockPositionUpdateWithWhereUniqueWithoutStockSymbolInput[]
    updateMany?: StockPositionUpdateManyWithWhereWithoutStockSymbolInput | StockPositionUpdateManyWithWhereWithoutStockSymbolInput[]
    deleteMany?: StockPositionScalarWhereInput | StockPositionScalarWhereInput[]
  }

  export type StockPositionUncheckedUpdateManyWithoutStockSymbolNestedInput = {
    create?: XOR<StockPositionCreateWithoutStockSymbolInput, StockPositionUncheckedCreateWithoutStockSymbolInput> | StockPositionCreateWithoutStockSymbolInput[] | StockPositionUncheckedCreateWithoutStockSymbolInput[]
    connectOrCreate?: StockPositionCreateOrConnectWithoutStockSymbolInput | StockPositionCreateOrConnectWithoutStockSymbolInput[]
    upsert?: StockPositionUpsertWithWhereUniqueWithoutStockSymbolInput | StockPositionUpsertWithWhereUniqueWithoutStockSymbolInput[]
    createMany?: StockPositionCreateManyStockSymbolInputEnvelope
    set?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    disconnect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    delete?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    connect?: StockPositionWhereUniqueInput | StockPositionWhereUniqueInput[]
    update?: StockPositionUpdateWithWhereUniqueWithoutStockSymbolInput | StockPositionUpdateWithWhereUniqueWithoutStockSymbolInput[]
    updateMany?: StockPositionUpdateManyWithWhereWithoutStockSymbolInput | StockPositionUpdateManyWithWhereWithoutStockSymbolInput[]
    deleteMany?: StockPositionScalarWhereInput | StockPositionScalarWhereInput[]
  }

  export type StockRecordCreateNestedManyWithoutStockInput = {
    create?: XOR<StockRecordCreateWithoutStockInput, StockRecordUncheckedCreateWithoutStockInput> | StockRecordCreateWithoutStockInput[] | StockRecordUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockRecordCreateOrConnectWithoutStockInput | StockRecordCreateOrConnectWithoutStockInput[]
    createMany?: StockRecordCreateManyStockInputEnvelope
    connect?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
  }

  export type StockRecordUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<StockRecordCreateWithoutStockInput, StockRecordUncheckedCreateWithoutStockInput> | StockRecordCreateWithoutStockInput[] | StockRecordUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockRecordCreateOrConnectWithoutStockInput | StockRecordCreateOrConnectWithoutStockInput[]
    createMany?: StockRecordCreateManyStockInputEnvelope
    connect?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumSTOCK_STATUSFieldUpdateOperationsInput = {
    set?: $Enums.STOCK_STATUS
  }

  export type StockRecordUpdateManyWithoutStockNestedInput = {
    create?: XOR<StockRecordCreateWithoutStockInput, StockRecordUncheckedCreateWithoutStockInput> | StockRecordCreateWithoutStockInput[] | StockRecordUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockRecordCreateOrConnectWithoutStockInput | StockRecordCreateOrConnectWithoutStockInput[]
    upsert?: StockRecordUpsertWithWhereUniqueWithoutStockInput | StockRecordUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: StockRecordCreateManyStockInputEnvelope
    set?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
    disconnect?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
    delete?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
    connect?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
    update?: StockRecordUpdateWithWhereUniqueWithoutStockInput | StockRecordUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: StockRecordUpdateManyWithWhereWithoutStockInput | StockRecordUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: StockRecordScalarWhereInput | StockRecordScalarWhereInput[]
  }

  export type StockRecordUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<StockRecordCreateWithoutStockInput, StockRecordUncheckedCreateWithoutStockInput> | StockRecordCreateWithoutStockInput[] | StockRecordUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockRecordCreateOrConnectWithoutStockInput | StockRecordCreateOrConnectWithoutStockInput[]
    upsert?: StockRecordUpsertWithWhereUniqueWithoutStockInput | StockRecordUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: StockRecordCreateManyStockInputEnvelope
    set?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
    disconnect?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
    delete?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
    connect?: StockRecordWhereUniqueInput | StockRecordWhereUniqueInput[]
    update?: StockRecordUpdateWithWhereUniqueWithoutStockInput | StockRecordUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: StockRecordUpdateManyWithWhereWithoutStockInput | StockRecordUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: StockRecordScalarWhereInput | StockRecordScalarWhereInput[]
  }

  export type StockCreateNestedOneWithoutStockRecordInput = {
    create?: XOR<StockCreateWithoutStockRecordInput, StockUncheckedCreateWithoutStockRecordInput>
    connectOrCreate?: StockCreateOrConnectWithoutStockRecordInput
    connect?: StockWhereUniqueInput
  }

  export type StockUpdateOneRequiredWithoutStockRecordNestedInput = {
    create?: XOR<StockCreateWithoutStockRecordInput, StockUncheckedCreateWithoutStockRecordInput>
    connectOrCreate?: StockCreateOrConnectWithoutStockRecordInput
    upsert?: StockUpsertWithoutStockRecordInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutStockRecordInput, StockUpdateWithoutStockRecordInput>, StockUncheckedUpdateWithoutStockRecordInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MemberCreateNestedOneWithoutMemberSubscribeInput = {
    create?: XOR<MemberCreateWithoutMemberSubscribeInput, MemberUncheckedCreateWithoutMemberSubscribeInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberSubscribeInput
    connect?: MemberWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type MemberUpdateOneRequiredWithoutMemberSubscribeNestedInput = {
    create?: XOR<MemberCreateWithoutMemberSubscribeInput, MemberUncheckedCreateWithoutMemberSubscribeInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberSubscribeInput
    upsert?: MemberUpsertWithoutMemberSubscribeInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMemberSubscribeInput, MemberUpdateWithoutMemberSubscribeInput>, MemberUncheckedUpdateWithoutMemberSubscribeInput>
  }

  export type MemberCreateNestedOneWithoutStockPostionInput = {
    create?: XOR<MemberCreateWithoutStockPostionInput, MemberUncheckedCreateWithoutStockPostionInput>
    connectOrCreate?: MemberCreateOrConnectWithoutStockPostionInput
    connect?: MemberWhereUniqueInput
  }

  export type StockSymbolCreateNestedOneWithoutStockPostionInput = {
    create?: XOR<StockSymbolCreateWithoutStockPostionInput, StockSymbolUncheckedCreateWithoutStockPostionInput>
    connectOrCreate?: StockSymbolCreateOrConnectWithoutStockPostionInput
    connect?: StockSymbolWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutStockPostionNestedInput = {
    create?: XOR<MemberCreateWithoutStockPostionInput, MemberUncheckedCreateWithoutStockPostionInput>
    connectOrCreate?: MemberCreateOrConnectWithoutStockPostionInput
    upsert?: MemberUpsertWithoutStockPostionInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutStockPostionInput, MemberUpdateWithoutStockPostionInput>, MemberUncheckedUpdateWithoutStockPostionInput>
  }

  export type StockSymbolUpdateOneRequiredWithoutStockPostionNestedInput = {
    create?: XOR<StockSymbolCreateWithoutStockPostionInput, StockSymbolUncheckedCreateWithoutStockPostionInput>
    connectOrCreate?: StockSymbolCreateOrConnectWithoutStockPostionInput
    upsert?: StockSymbolUpsertWithoutStockPostionInput
    connect?: StockSymbolWhereUniqueInput
    update?: XOR<XOR<StockSymbolUpdateToOneWithWhereWithoutStockPostionInput, StockSymbolUpdateWithoutStockPostionInput>, StockSymbolUncheckedUpdateWithoutStockPostionInput>
  }

  export type MemberCreateNestedOneWithoutMemberDetailInput = {
    create?: XOR<MemberCreateWithoutMemberDetailInput, MemberUncheckedCreateWithoutMemberDetailInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberDetailInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutMemberDetailNestedInput = {
    create?: XOR<MemberCreateWithoutMemberDetailInput, MemberUncheckedCreateWithoutMemberDetailInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberDetailInput
    upsert?: MemberUpsertWithoutMemberDetailInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMemberDetailInput, MemberUpdateWithoutMemberDetailInput>, MemberUncheckedUpdateWithoutMemberDetailInput>
  }

  export type MemberCreateNestedOneWithoutMemberCardsInput = {
    create?: XOR<MemberCreateWithoutMemberCardsInput, MemberUncheckedCreateWithoutMemberCardsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberCardsInput
    connect?: MemberWhereUniqueInput
  }

  export type EnumRechargeTypeFieldUpdateOperationsInput = {
    set?: $Enums.RechargeType
  }

  export type MemberUpdateOneRequiredWithoutMemberCardsNestedInput = {
    create?: XOR<MemberCreateWithoutMemberCardsInput, MemberUncheckedCreateWithoutMemberCardsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutMemberCardsInput
    upsert?: MemberUpsertWithoutMemberCardsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutMemberCardsInput, MemberUpdateWithoutMemberCardsInput>, MemberUncheckedUpdateWithoutMemberCardsInput>
  }

  export type MemberCreateNestedOneWithoutRechargesInput = {
    create?: XOR<MemberCreateWithoutRechargesInput, MemberUncheckedCreateWithoutRechargesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutRechargesInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutRechargesNestedInput = {
    create?: XOR<MemberCreateWithoutRechargesInput, MemberUncheckedCreateWithoutRechargesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutRechargesInput
    upsert?: MemberUpsertWithoutRechargesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutRechargesInput, MemberUpdateWithoutRechargesInput>, MemberUncheckedUpdateWithoutRechargesInput>
  }

  export type MemberCreateNestedOneWithoutWithdrawsInput = {
    create?: XOR<MemberCreateWithoutWithdrawsInput, MemberUncheckedCreateWithoutWithdrawsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutWithdrawsInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutWithdrawsNestedInput = {
    create?: XOR<MemberCreateWithoutWithdrawsInput, MemberUncheckedCreateWithoutWithdrawsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutWithdrawsInput
    upsert?: MemberUpsertWithoutWithdrawsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutWithdrawsInput, MemberUpdateWithoutWithdrawsInput>, MemberUncheckedUpdateWithoutWithdrawsInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGENDERFilter<$PrismaModel = never> = {
    equals?: $Enums.GENDER | EnumGENDERFieldRefInput<$PrismaModel>
    in?: $Enums.GENDER[]
    notIn?: $Enums.GENDER[]
    not?: NestedEnumGENDERFilter<$PrismaModel> | $Enums.GENDER
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGENDERWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GENDER | EnumGENDERFieldRefInput<$PrismaModel>
    in?: $Enums.GENDER[]
    notIn?: $Enums.GENDER[]
    not?: NestedEnumGENDERWithAggregatesFilter<$PrismaModel> | $Enums.GENDER
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGENDERFilter<$PrismaModel>
    _max?: NestedEnumGENDERFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumSTOCK_STATUSFilter<$PrismaModel = never> = {
    equals?: $Enums.STOCK_STATUS | EnumSTOCK_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.STOCK_STATUS[]
    notIn?: $Enums.STOCK_STATUS[]
    not?: NestedEnumSTOCK_STATUSFilter<$PrismaModel> | $Enums.STOCK_STATUS
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSTOCK_STATUSWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.STOCK_STATUS | EnumSTOCK_STATUSFieldRefInput<$PrismaModel>
    in?: $Enums.STOCK_STATUS[]
    notIn?: $Enums.STOCK_STATUS[]
    not?: NestedEnumSTOCK_STATUSWithAggregatesFilter<$PrismaModel> | $Enums.STOCK_STATUS
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSTOCK_STATUSFilter<$PrismaModel>
    _max?: NestedEnumSTOCK_STATUSFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumRechargeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RechargeType | EnumRechargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RechargeType[]
    notIn?: $Enums.RechargeType[]
    not?: NestedEnumRechargeTypeFilter<$PrismaModel> | $Enums.RechargeType
  }

  export type NestedEnumRechargeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RechargeType | EnumRechargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RechargeType[]
    notIn?: $Enums.RechargeType[]
    not?: NestedEnumRechargeTypeWithAggregatesFilter<$PrismaModel> | $Enums.RechargeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRechargeTypeFilter<$PrismaModel>
    _max?: NestedEnumRechargeTypeFilter<$PrismaModel>
  }

  export type StockPositionCreateWithoutMemberInput = {
    id?: bigint | number
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond?: string | null
    identifier?: string | null
    lever?: string | null
    stopLoss?: string | null
    takeProfit?: string | null
    market?: string | null
    type: number
    pl?: string | null
    rate?: string | null
    isBefore?: boolean
    currentPrice?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockSymbol: StockSymbolCreateNestedOneWithoutStockPostionInput
  }

  export type StockPositionUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond?: string | null
    identifier?: string | null
    lever?: string | null
    stopLoss?: string | null
    takeProfit?: string | null
    market?: string | null
    type: number
    pl?: string | null
    rate?: string | null
    isBefore?: boolean
    currentPrice?: string | null
    stockSymbolId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockPositionCreateOrConnectWithoutMemberInput = {
    where: StockPositionWhereUniqueInput
    create: XOR<StockPositionCreateWithoutMemberInput, StockPositionUncheckedCreateWithoutMemberInput>
  }

  export type StockPositionCreateManyMemberInputEnvelope = {
    data: StockPositionCreateManyMemberInput | StockPositionCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberDetailCreateWithoutMemberInput = {
    id?: bigint | number
    after?: string | null
    amount?: string | null
    before?: string | null
    market?: string | null
    type: number
    remark?: string | null
  }

  export type MemberDetailUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    after?: string | null
    amount?: string | null
    before?: string | null
    market?: string | null
    type: number
    remark?: string | null
  }

  export type MemberDetailCreateOrConnectWithoutMemberInput = {
    where: MemberDetailWhereUniqueInput
    create: XOR<MemberDetailCreateWithoutMemberInput, MemberDetailUncheckedCreateWithoutMemberInput>
  }

  export type MemberDetailCreateManyMemberInputEnvelope = {
    data: MemberDetailCreateManyMemberInput | MemberDetailCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberSubscribeCreateWithoutMemberInput = {
    id?: bigint | number
    market: string
    code: string
    name: string
    amount: number
    money: Decimal | DecimalJsLike | number | string
    no: string
    winningAmount?: number | null
    winningPrice?: Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: Decimal | DecimalJsLike | number | string | null
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    status?: number
    type?: number
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockSubscribeId: bigint | number
  }

  export type MemberSubscribeUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    market: string
    code: string
    name: string
    amount: number
    money: Decimal | DecimalJsLike | number | string
    no: string
    winningAmount?: number | null
    winningPrice?: Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: Decimal | DecimalJsLike | number | string | null
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    status?: number
    type?: number
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockSubscribeId: bigint | number
  }

  export type MemberSubscribeCreateOrConnectWithoutMemberInput = {
    where: MemberSubscribeWhereUniqueInput
    create: XOR<MemberSubscribeCreateWithoutMemberInput, MemberSubscribeUncheckedCreateWithoutMemberInput>
  }

  export type MemberSubscribeCreateManyMemberInputEnvelope = {
    data: MemberSubscribeCreateManyMemberInput | MemberSubscribeCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberRechargeCreateWithoutMemberInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    rechargeMoney?: Decimal | DecimalJsLike | number | string
    screen: JsonNullValueInput | InputJsonValue
    market: string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberRechargeUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    rechargeMoney?: Decimal | DecimalJsLike | number | string
    screen: JsonNullValueInput | InputJsonValue
    market: string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberRechargeCreateOrConnectWithoutMemberInput = {
    where: MemberRechargeWhereUniqueInput
    create: XOR<MemberRechargeCreateWithoutMemberInput, MemberRechargeUncheckedCreateWithoutMemberInput>
  }

  export type MemberRechargeCreateManyMemberInputEnvelope = {
    data: MemberRechargeCreateManyMemberInput | MemberRechargeCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberWithdrawCreateWithoutMemberInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    remark?: string | null
    status?: number
    address?: string | null
    market: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberWithdrawUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    remark?: string | null
    status?: number
    address?: string | null
    market: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberWithdrawCreateOrConnectWithoutMemberInput = {
    where: MemberWithdrawWhereUniqueInput
    create: XOR<MemberWithdrawCreateWithoutMemberInput, MemberWithdrawUncheckedCreateWithoutMemberInput>
  }

  export type MemberWithdrawCreateManyMemberInputEnvelope = {
    data: MemberWithdrawCreateManyMemberInput | MemberWithdrawCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type MemberCardCreateWithoutMemberInput = {
    id?: bigint | number
    name?: string | null
    type: $Enums.RechargeType
    detail: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberCardUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    name?: string | null
    type: $Enums.RechargeType
    detail: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberCardCreateOrConnectWithoutMemberInput = {
    where: MemberCardWhereUniqueInput
    create: XOR<MemberCardCreateWithoutMemberInput, MemberCardUncheckedCreateWithoutMemberInput>
  }

  export type MemberCardCreateManyMemberInputEnvelope = {
    data: MemberCardCreateManyMemberInput | MemberCardCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type RechargeCreateWithoutMemberInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    account: string
    accountNetwork: string
    screens: JsonNullValueInput | InputJsonValue
    status?: number
    passMoney?: Decimal | DecimalJsLike | number | string
    convertMoney?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RechargeUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    account: string
    accountNetwork: string
    screens: JsonNullValueInput | InputJsonValue
    status?: number
    passMoney?: Decimal | DecimalJsLike | number | string
    convertMoney?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RechargeCreateOrConnectWithoutMemberInput = {
    where: RechargeWhereUniqueInput
    create: XOR<RechargeCreateWithoutMemberInput, RechargeUncheckedCreateWithoutMemberInput>
  }

  export type RechargeCreateManyMemberInputEnvelope = {
    data: RechargeCreateManyMemberInput | RechargeCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type WithdrawCreateWithoutMemberInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    currency: string
    cryptoType?: string | null
    cryptoNetwork?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: Decimal | DecimalJsLike | number | string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawUncheckedCreateWithoutMemberInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    currency: string
    cryptoType?: string | null
    cryptoNetwork?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: Decimal | DecimalJsLike | number | string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawCreateOrConnectWithoutMemberInput = {
    where: WithdrawWhereUniqueInput
    create: XOR<WithdrawCreateWithoutMemberInput, WithdrawUncheckedCreateWithoutMemberInput>
  }

  export type WithdrawCreateManyMemberInputEnvelope = {
    data: WithdrawCreateManyMemberInput | WithdrawCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type StockPositionUpsertWithWhereUniqueWithoutMemberInput = {
    where: StockPositionWhereUniqueInput
    update: XOR<StockPositionUpdateWithoutMemberInput, StockPositionUncheckedUpdateWithoutMemberInput>
    create: XOR<StockPositionCreateWithoutMemberInput, StockPositionUncheckedCreateWithoutMemberInput>
  }

  export type StockPositionUpdateWithWhereUniqueWithoutMemberInput = {
    where: StockPositionWhereUniqueInput
    data: XOR<StockPositionUpdateWithoutMemberInput, StockPositionUncheckedUpdateWithoutMemberInput>
  }

  export type StockPositionUpdateManyWithWhereWithoutMemberInput = {
    where: StockPositionScalarWhereInput
    data: XOR<StockPositionUpdateManyMutationInput, StockPositionUncheckedUpdateManyWithoutMemberInput>
  }

  export type StockPositionScalarWhereInput = {
    AND?: StockPositionScalarWhereInput | StockPositionScalarWhereInput[]
    OR?: StockPositionScalarWhereInput[]
    NOT?: StockPositionScalarWhereInput | StockPositionScalarWhereInput[]
    id?: BigIntFilter<"StockPosition"> | bigint | number
    amount?: IntFilter<"StockPosition"> | number
    blast?: StringFilter<"StockPosition"> | string
    price?: StringFilter<"StockPosition"> | string
    mode?: IntFilter<"StockPosition"> | number
    status?: IntFilter<"StockPosition"> | number
    bond?: StringNullableFilter<"StockPosition"> | string | null
    identifier?: StringNullableFilter<"StockPosition"> | string | null
    lever?: StringNullableFilter<"StockPosition"> | string | null
    stopLoss?: StringNullableFilter<"StockPosition"> | string | null
    takeProfit?: StringNullableFilter<"StockPosition"> | string | null
    market?: StringNullableFilter<"StockPosition"> | string | null
    type?: IntFilter<"StockPosition"> | number
    pl?: StringNullableFilter<"StockPosition"> | string | null
    rate?: StringNullableFilter<"StockPosition"> | string | null
    isBefore?: BoolFilter<"StockPosition"> | boolean
    currentPrice?: StringNullableFilter<"StockPosition"> | string | null
    memberId?: BigIntFilter<"StockPosition"> | bigint | number
    stockSymbolId?: BigIntFilter<"StockPosition"> | bigint | number
    createdAt?: DateTimeFilter<"StockPosition"> | Date | string
    updatedAt?: DateTimeNullableFilter<"StockPosition"> | Date | string | null
  }

  export type MemberDetailUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberDetailWhereUniqueInput
    update: XOR<MemberDetailUpdateWithoutMemberInput, MemberDetailUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberDetailCreateWithoutMemberInput, MemberDetailUncheckedCreateWithoutMemberInput>
  }

  export type MemberDetailUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberDetailWhereUniqueInput
    data: XOR<MemberDetailUpdateWithoutMemberInput, MemberDetailUncheckedUpdateWithoutMemberInput>
  }

  export type MemberDetailUpdateManyWithWhereWithoutMemberInput = {
    where: MemberDetailScalarWhereInput
    data: XOR<MemberDetailUpdateManyMutationInput, MemberDetailUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberDetailScalarWhereInput = {
    AND?: MemberDetailScalarWhereInput | MemberDetailScalarWhereInput[]
    OR?: MemberDetailScalarWhereInput[]
    NOT?: MemberDetailScalarWhereInput | MemberDetailScalarWhereInput[]
    id?: BigIntFilter<"MemberDetail"> | bigint | number
    after?: StringNullableFilter<"MemberDetail"> | string | null
    amount?: StringNullableFilter<"MemberDetail"> | string | null
    before?: StringNullableFilter<"MemberDetail"> | string | null
    market?: StringNullableFilter<"MemberDetail"> | string | null
    type?: IntFilter<"MemberDetail"> | number
    remark?: StringNullableFilter<"MemberDetail"> | string | null
    memberId?: BigIntFilter<"MemberDetail"> | bigint | number
  }

  export type MemberSubscribeUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberSubscribeWhereUniqueInput
    update: XOR<MemberSubscribeUpdateWithoutMemberInput, MemberSubscribeUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberSubscribeCreateWithoutMemberInput, MemberSubscribeUncheckedCreateWithoutMemberInput>
  }

  export type MemberSubscribeUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberSubscribeWhereUniqueInput
    data: XOR<MemberSubscribeUpdateWithoutMemberInput, MemberSubscribeUncheckedUpdateWithoutMemberInput>
  }

  export type MemberSubscribeUpdateManyWithWhereWithoutMemberInput = {
    where: MemberSubscribeScalarWhereInput
    data: XOR<MemberSubscribeUpdateManyMutationInput, MemberSubscribeUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberSubscribeScalarWhereInput = {
    AND?: MemberSubscribeScalarWhereInput | MemberSubscribeScalarWhereInput[]
    OR?: MemberSubscribeScalarWhereInput[]
    NOT?: MemberSubscribeScalarWhereInput | MemberSubscribeScalarWhereInput[]
    id?: BigIntFilter<"MemberSubscribe"> | bigint | number
    market?: StringFilter<"MemberSubscribe"> | string
    code?: StringFilter<"MemberSubscribe"> | string
    name?: StringFilter<"MemberSubscribe"> | string
    amount?: IntFilter<"MemberSubscribe"> | number
    money?: DecimalFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string
    no?: StringFilter<"MemberSubscribe"> | string
    winningAmount?: IntNullableFilter<"MemberSubscribe"> | number | null
    winningPrice?: DecimalNullableFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: DecimalNullableFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    actualAmount?: DecimalNullableFilter<"MemberSubscribe"> | Decimal | DecimalJsLike | number | string | null
    status?: IntFilter<"MemberSubscribe"> | number
    type?: IntFilter<"MemberSubscribe"> | number
    position?: IntFilter<"MemberSubscribe"> | number
    createdAt?: DateTimeFilter<"MemberSubscribe"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberSubscribe"> | Date | string | null
    stockSubscribeId?: BigIntFilter<"MemberSubscribe"> | bigint | number
    memberId?: BigIntFilter<"MemberSubscribe"> | bigint | number
  }

  export type MemberRechargeUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberRechargeWhereUniqueInput
    update: XOR<MemberRechargeUpdateWithoutMemberInput, MemberRechargeUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberRechargeCreateWithoutMemberInput, MemberRechargeUncheckedCreateWithoutMemberInput>
  }

  export type MemberRechargeUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberRechargeWhereUniqueInput
    data: XOR<MemberRechargeUpdateWithoutMemberInput, MemberRechargeUncheckedUpdateWithoutMemberInput>
  }

  export type MemberRechargeUpdateManyWithWhereWithoutMemberInput = {
    where: MemberRechargeScalarWhereInput
    data: XOR<MemberRechargeUpdateManyMutationInput, MemberRechargeUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberRechargeScalarWhereInput = {
    AND?: MemberRechargeScalarWhereInput | MemberRechargeScalarWhereInput[]
    OR?: MemberRechargeScalarWhereInput[]
    NOT?: MemberRechargeScalarWhereInput | MemberRechargeScalarWhereInput[]
    id?: BigIntFilter<"MemberRecharge"> | bigint | number
    money?: DecimalFilter<"MemberRecharge"> | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFilter<"MemberRecharge"> | Decimal | DecimalJsLike | number | string
    screen?: JsonFilter<"MemberRecharge">
    market?: StringFilter<"MemberRecharge"> | string
    status?: IntFilter<"MemberRecharge"> | number
    memberId?: BigIntFilter<"MemberRecharge"> | bigint | number
    createdAt?: DateTimeFilter<"MemberRecharge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberRecharge"> | Date | string | null
  }

  export type MemberWithdrawUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberWithdrawWhereUniqueInput
    update: XOR<MemberWithdrawUpdateWithoutMemberInput, MemberWithdrawUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberWithdrawCreateWithoutMemberInput, MemberWithdrawUncheckedCreateWithoutMemberInput>
  }

  export type MemberWithdrawUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberWithdrawWhereUniqueInput
    data: XOR<MemberWithdrawUpdateWithoutMemberInput, MemberWithdrawUncheckedUpdateWithoutMemberInput>
  }

  export type MemberWithdrawUpdateManyWithWhereWithoutMemberInput = {
    where: MemberWithdrawScalarWhereInput
    data: XOR<MemberWithdrawUpdateManyMutationInput, MemberWithdrawUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberWithdrawScalarWhereInput = {
    AND?: MemberWithdrawScalarWhereInput | MemberWithdrawScalarWhereInput[]
    OR?: MemberWithdrawScalarWhereInput[]
    NOT?: MemberWithdrawScalarWhereInput | MemberWithdrawScalarWhereInput[]
    id?: BigIntFilter<"MemberWithdraw"> | bigint | number
    money?: DecimalFilter<"MemberWithdraw"> | Decimal | DecimalJsLike | number | string
    remark?: StringNullableFilter<"MemberWithdraw"> | string | null
    status?: IntFilter<"MemberWithdraw"> | number
    address?: StringNullableFilter<"MemberWithdraw"> | string | null
    market?: StringFilter<"MemberWithdraw"> | string
    memberId?: BigIntFilter<"MemberWithdraw"> | bigint | number
    createdAt?: DateTimeFilter<"MemberWithdraw"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberWithdraw"> | Date | string | null
  }

  export type MemberCardUpsertWithWhereUniqueWithoutMemberInput = {
    where: MemberCardWhereUniqueInput
    update: XOR<MemberCardUpdateWithoutMemberInput, MemberCardUncheckedUpdateWithoutMemberInput>
    create: XOR<MemberCardCreateWithoutMemberInput, MemberCardUncheckedCreateWithoutMemberInput>
  }

  export type MemberCardUpdateWithWhereUniqueWithoutMemberInput = {
    where: MemberCardWhereUniqueInput
    data: XOR<MemberCardUpdateWithoutMemberInput, MemberCardUncheckedUpdateWithoutMemberInput>
  }

  export type MemberCardUpdateManyWithWhereWithoutMemberInput = {
    where: MemberCardScalarWhereInput
    data: XOR<MemberCardUpdateManyMutationInput, MemberCardUncheckedUpdateManyWithoutMemberInput>
  }

  export type MemberCardScalarWhereInput = {
    AND?: MemberCardScalarWhereInput | MemberCardScalarWhereInput[]
    OR?: MemberCardScalarWhereInput[]
    NOT?: MemberCardScalarWhereInput | MemberCardScalarWhereInput[]
    id?: BigIntFilter<"MemberCard"> | bigint | number
    name?: StringNullableFilter<"MemberCard"> | string | null
    type?: EnumRechargeTypeFilter<"MemberCard"> | $Enums.RechargeType
    detail?: JsonFilter<"MemberCard">
    memberId?: BigIntFilter<"MemberCard"> | bigint | number
    createdAt?: DateTimeFilter<"MemberCard"> | Date | string
    updatedAt?: DateTimeNullableFilter<"MemberCard"> | Date | string | null
  }

  export type RechargeUpsertWithWhereUniqueWithoutMemberInput = {
    where: RechargeWhereUniqueInput
    update: XOR<RechargeUpdateWithoutMemberInput, RechargeUncheckedUpdateWithoutMemberInput>
    create: XOR<RechargeCreateWithoutMemberInput, RechargeUncheckedCreateWithoutMemberInput>
  }

  export type RechargeUpdateWithWhereUniqueWithoutMemberInput = {
    where: RechargeWhereUniqueInput
    data: XOR<RechargeUpdateWithoutMemberInput, RechargeUncheckedUpdateWithoutMemberInput>
  }

  export type RechargeUpdateManyWithWhereWithoutMemberInput = {
    where: RechargeScalarWhereInput
    data: XOR<RechargeUpdateManyMutationInput, RechargeUncheckedUpdateManyWithoutMemberInput>
  }

  export type RechargeScalarWhereInput = {
    AND?: RechargeScalarWhereInput | RechargeScalarWhereInput[]
    OR?: RechargeScalarWhereInput[]
    NOT?: RechargeScalarWhereInput | RechargeScalarWhereInput[]
    id?: BigIntFilter<"Recharge"> | bigint | number
    market?: StringFilter<"Recharge"> | string
    money?: DecimalFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFilter<"Recharge"> | $Enums.RechargeType
    account?: StringFilter<"Recharge"> | string
    accountNetwork?: StringFilter<"Recharge"> | string
    screens?: JsonFilter<"Recharge">
    status?: IntFilter<"Recharge"> | number
    passMoney?: DecimalFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFilter<"Recharge"> | Decimal | DecimalJsLike | number | string
    memberId?: BigIntFilter<"Recharge"> | bigint | number
    createdAt?: DateTimeFilter<"Recharge"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Recharge"> | Date | string | null
  }

  export type WithdrawUpsertWithWhereUniqueWithoutMemberInput = {
    where: WithdrawWhereUniqueInput
    update: XOR<WithdrawUpdateWithoutMemberInput, WithdrawUncheckedUpdateWithoutMemberInput>
    create: XOR<WithdrawCreateWithoutMemberInput, WithdrawUncheckedCreateWithoutMemberInput>
  }

  export type WithdrawUpdateWithWhereUniqueWithoutMemberInput = {
    where: WithdrawWhereUniqueInput
    data: XOR<WithdrawUpdateWithoutMemberInput, WithdrawUncheckedUpdateWithoutMemberInput>
  }

  export type WithdrawUpdateManyWithWhereWithoutMemberInput = {
    where: WithdrawScalarWhereInput
    data: XOR<WithdrawUpdateManyMutationInput, WithdrawUncheckedUpdateManyWithoutMemberInput>
  }

  export type WithdrawScalarWhereInput = {
    AND?: WithdrawScalarWhereInput | WithdrawScalarWhereInput[]
    OR?: WithdrawScalarWhereInput[]
    NOT?: WithdrawScalarWhereInput | WithdrawScalarWhereInput[]
    id?: BigIntFilter<"Withdraw"> | bigint | number
    market?: StringFilter<"Withdraw"> | string
    money?: DecimalFilter<"Withdraw"> | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFilter<"Withdraw"> | $Enums.RechargeType
    currency?: StringFilter<"Withdraw"> | string
    cryptoType?: StringNullableFilter<"Withdraw"> | string | null
    cryptoNetwork?: StringNullableFilter<"Withdraw"> | string | null
    card?: JsonNullableFilter<"Withdraw">
    convertMoney?: DecimalFilter<"Withdraw"> | Decimal | DecimalJsLike | number | string
    status?: IntFilter<"Withdraw"> | number
    memberId?: BigIntFilter<"Withdraw"> | bigint | number
    createdAt?: DateTimeFilter<"Withdraw"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Withdraw"> | Date | string | null
  }

  export type MemberCreateWithoutMemberRechargesInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardCreateNestedManyWithoutMemberInput
    recharges?: RechargeCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberRechargesInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionUncheckedCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailUncheckedCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeUncheckedCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawUncheckedCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardUncheckedCreateNestedManyWithoutMemberInput
    recharges?: RechargeUncheckedCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberRechargesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberRechargesInput, MemberUncheckedCreateWithoutMemberRechargesInput>
  }

  export type MemberUpsertWithoutMemberRechargesInput = {
    update: XOR<MemberUpdateWithoutMemberRechargesInput, MemberUncheckedUpdateWithoutMemberRechargesInput>
    create: XOR<MemberCreateWithoutMemberRechargesInput, MemberUncheckedCreateWithoutMemberRechargesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMemberRechargesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMemberRechargesInput, MemberUncheckedUpdateWithoutMemberRechargesInput>
  }

  export type MemberUpdateWithoutMemberRechargesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberRechargesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUncheckedUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUncheckedUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUncheckedUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUncheckedUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUncheckedUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUncheckedUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutMemberWithdrawsInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardCreateNestedManyWithoutMemberInput
    recharges?: RechargeCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberWithdrawsInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionUncheckedCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailUncheckedCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeUncheckedCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeUncheckedCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardUncheckedCreateNestedManyWithoutMemberInput
    recharges?: RechargeUncheckedCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberWithdrawsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberWithdrawsInput, MemberUncheckedCreateWithoutMemberWithdrawsInput>
  }

  export type MemberUpsertWithoutMemberWithdrawsInput = {
    update: XOR<MemberUpdateWithoutMemberWithdrawsInput, MemberUncheckedUpdateWithoutMemberWithdrawsInput>
    create: XOR<MemberCreateWithoutMemberWithdrawsInput, MemberUncheckedCreateWithoutMemberWithdrawsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMemberWithdrawsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMemberWithdrawsInput, MemberUncheckedUpdateWithoutMemberWithdrawsInput>
  }

  export type MemberUpdateWithoutMemberWithdrawsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberWithdrawsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUncheckedUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUncheckedUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUncheckedUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUncheckedUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUncheckedUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUncheckedUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type StockPositionCreateWithoutStockSymbolInput = {
    id?: bigint | number
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond?: string | null
    identifier?: string | null
    lever?: string | null
    stopLoss?: string | null
    takeProfit?: string | null
    market?: string | null
    type: number
    pl?: string | null
    rate?: string | null
    isBefore?: boolean
    currentPrice?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    member: MemberCreateNestedOneWithoutStockPostionInput
  }

  export type StockPositionUncheckedCreateWithoutStockSymbolInput = {
    id?: bigint | number
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond?: string | null
    identifier?: string | null
    lever?: string | null
    stopLoss?: string | null
    takeProfit?: string | null
    market?: string | null
    type: number
    pl?: string | null
    rate?: string | null
    isBefore?: boolean
    currentPrice?: string | null
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockPositionCreateOrConnectWithoutStockSymbolInput = {
    where: StockPositionWhereUniqueInput
    create: XOR<StockPositionCreateWithoutStockSymbolInput, StockPositionUncheckedCreateWithoutStockSymbolInput>
  }

  export type StockPositionCreateManyStockSymbolInputEnvelope = {
    data: StockPositionCreateManyStockSymbolInput | StockPositionCreateManyStockSymbolInput[]
    skipDuplicates?: boolean
  }

  export type StockPositionUpsertWithWhereUniqueWithoutStockSymbolInput = {
    where: StockPositionWhereUniqueInput
    update: XOR<StockPositionUpdateWithoutStockSymbolInput, StockPositionUncheckedUpdateWithoutStockSymbolInput>
    create: XOR<StockPositionCreateWithoutStockSymbolInput, StockPositionUncheckedCreateWithoutStockSymbolInput>
  }

  export type StockPositionUpdateWithWhereUniqueWithoutStockSymbolInput = {
    where: StockPositionWhereUniqueInput
    data: XOR<StockPositionUpdateWithoutStockSymbolInput, StockPositionUncheckedUpdateWithoutStockSymbolInput>
  }

  export type StockPositionUpdateManyWithWhereWithoutStockSymbolInput = {
    where: StockPositionScalarWhereInput
    data: XOR<StockPositionUpdateManyMutationInput, StockPositionUncheckedUpdateManyWithoutStockSymbolInput>
  }

  export type StockRecordCreateWithoutStockInput = {
    id?: bigint | number
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date: string
    extra: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StockRecordUncheckedCreateWithoutStockInput = {
    id?: bigint | number
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date: string
    extra: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StockRecordCreateOrConnectWithoutStockInput = {
    where: StockRecordWhereUniqueInput
    create: XOR<StockRecordCreateWithoutStockInput, StockRecordUncheckedCreateWithoutStockInput>
  }

  export type StockRecordCreateManyStockInputEnvelope = {
    data: StockRecordCreateManyStockInput | StockRecordCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type StockRecordUpsertWithWhereUniqueWithoutStockInput = {
    where: StockRecordWhereUniqueInput
    update: XOR<StockRecordUpdateWithoutStockInput, StockRecordUncheckedUpdateWithoutStockInput>
    create: XOR<StockRecordCreateWithoutStockInput, StockRecordUncheckedCreateWithoutStockInput>
  }

  export type StockRecordUpdateWithWhereUniqueWithoutStockInput = {
    where: StockRecordWhereUniqueInput
    data: XOR<StockRecordUpdateWithoutStockInput, StockRecordUncheckedUpdateWithoutStockInput>
  }

  export type StockRecordUpdateManyWithWhereWithoutStockInput = {
    where: StockRecordScalarWhereInput
    data: XOR<StockRecordUpdateManyMutationInput, StockRecordUncheckedUpdateManyWithoutStockInput>
  }

  export type StockRecordScalarWhereInput = {
    AND?: StockRecordScalarWhereInput | StockRecordScalarWhereInput[]
    OR?: StockRecordScalarWhereInput[]
    NOT?: StockRecordScalarWhereInput | StockRecordScalarWhereInput[]
    id?: BigIntFilter<"StockRecord"> | bigint | number
    newPrice?: StringFilter<"StockRecord"> | string
    open?: StringFilter<"StockRecord"> | string
    close?: StringFilter<"StockRecord"> | string
    high?: StringFilter<"StockRecord"> | string
    low?: StringFilter<"StockRecord"> | string
    amount?: StringFilter<"StockRecord"> | string
    volume?: StringFilter<"StockRecord"> | string
    date?: StringFilter<"StockRecord"> | string
    extra?: JsonFilter<"StockRecord">
    createdAt?: DateTimeFilter<"StockRecord"> | Date | string
    stockId?: BigIntFilter<"StockRecord"> | bigint | number
  }

  export type StockCreateWithoutStockRecordInput = {
    id?: bigint | number
    code: string
    symbol: string
    name: string
    cname?: string | null
    type: string
    logo?: string | null
    sok?: string | null
    optional?: boolean
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    status?: $Enums.STOCK_STATUS
    change?: string | null
    changePercent?: string | null
    date?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockUncheckedCreateWithoutStockRecordInput = {
    id?: bigint | number
    code: string
    symbol: string
    name: string
    cname?: string | null
    type: string
    logo?: string | null
    sok?: string | null
    optional?: boolean
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    status?: $Enums.STOCK_STATUS
    change?: string | null
    changePercent?: string | null
    date?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockCreateOrConnectWithoutStockRecordInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutStockRecordInput, StockUncheckedCreateWithoutStockRecordInput>
  }

  export type StockUpsertWithoutStockRecordInput = {
    update: XOR<StockUpdateWithoutStockRecordInput, StockUncheckedUpdateWithoutStockRecordInput>
    create: XOR<StockCreateWithoutStockRecordInput, StockUncheckedCreateWithoutStockRecordInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutStockRecordInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutStockRecordInput, StockUncheckedUpdateWithoutStockRecordInput>
  }

  export type StockUpdateWithoutStockRecordInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cname?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    sok?: NullableStringFieldUpdateOperationsInput | string | null
    optional?: BoolFieldUpdateOperationsInput | boolean
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTOCK_STATUSFieldUpdateOperationsInput | $Enums.STOCK_STATUS
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockUncheckedUpdateWithoutStockRecordInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cname?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    sok?: NullableStringFieldUpdateOperationsInput | string | null
    optional?: BoolFieldUpdateOperationsInput | boolean
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSTOCK_STATUSFieldUpdateOperationsInput | $Enums.STOCK_STATUS
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCreateWithoutMemberSubscribeInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardCreateNestedManyWithoutMemberInput
    recharges?: RechargeCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberSubscribeInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionUncheckedCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailUncheckedCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeUncheckedCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawUncheckedCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardUncheckedCreateNestedManyWithoutMemberInput
    recharges?: RechargeUncheckedCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberSubscribeInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberSubscribeInput, MemberUncheckedCreateWithoutMemberSubscribeInput>
  }

  export type MemberUpsertWithoutMemberSubscribeInput = {
    update: XOR<MemberUpdateWithoutMemberSubscribeInput, MemberUncheckedUpdateWithoutMemberSubscribeInput>
    create: XOR<MemberCreateWithoutMemberSubscribeInput, MemberUncheckedCreateWithoutMemberSubscribeInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMemberSubscribeInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMemberSubscribeInput, MemberUncheckedUpdateWithoutMemberSubscribeInput>
  }

  export type MemberUpdateWithoutMemberSubscribeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberSubscribeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUncheckedUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUncheckedUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUncheckedUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUncheckedUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUncheckedUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUncheckedUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutStockPostionInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    memberDetail?: MemberDetailCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardCreateNestedManyWithoutMemberInput
    recharges?: RechargeCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutStockPostionInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    memberDetail?: MemberDetailUncheckedCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeUncheckedCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeUncheckedCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawUncheckedCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardUncheckedCreateNestedManyWithoutMemberInput
    recharges?: RechargeUncheckedCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutStockPostionInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutStockPostionInput, MemberUncheckedCreateWithoutStockPostionInput>
  }

  export type StockSymbolCreateWithoutStockPostionInput = {
    id?: bigint | number
    code: string
    cat?: string | null
    market: string
    online?: number
    symbol: string
    showName: string
    name?: string | null
    symbolShowName?: string | null
    trade?: number
    type?: number
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    change?: string | null
    changePercent?: string | null
    date?: string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockSymbolUncheckedCreateWithoutStockPostionInput = {
    id?: bigint | number
    code: string
    cat?: string | null
    market: string
    online?: number
    symbol: string
    showName: string
    name?: string | null
    symbolShowName?: string | null
    trade?: number
    type?: number
    newPrice?: string | null
    open?: string | null
    close?: string | null
    high?: string | null
    low?: string | null
    amount?: string | null
    volume?: string | null
    change?: string | null
    changePercent?: string | null
    date?: string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockSymbolCreateOrConnectWithoutStockPostionInput = {
    where: StockSymbolWhereUniqueInput
    create: XOR<StockSymbolCreateWithoutStockPostionInput, StockSymbolUncheckedCreateWithoutStockPostionInput>
  }

  export type MemberUpsertWithoutStockPostionInput = {
    update: XOR<MemberUpdateWithoutStockPostionInput, MemberUncheckedUpdateWithoutStockPostionInput>
    create: XOR<MemberCreateWithoutStockPostionInput, MemberUncheckedCreateWithoutStockPostionInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutStockPostionInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutStockPostionInput, MemberUncheckedUpdateWithoutStockPostionInput>
  }

  export type MemberUpdateWithoutStockPostionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberDetail?: MemberDetailUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutStockPostionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    memberDetail?: MemberDetailUncheckedUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUncheckedUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUncheckedUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUncheckedUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUncheckedUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUncheckedUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type StockSymbolUpsertWithoutStockPostionInput = {
    update: XOR<StockSymbolUpdateWithoutStockPostionInput, StockSymbolUncheckedUpdateWithoutStockPostionInput>
    create: XOR<StockSymbolCreateWithoutStockPostionInput, StockSymbolUncheckedCreateWithoutStockPostionInput>
    where?: StockSymbolWhereInput
  }

  export type StockSymbolUpdateToOneWithWhereWithoutStockPostionInput = {
    where?: StockSymbolWhereInput
    data: XOR<StockSymbolUpdateWithoutStockPostionInput, StockSymbolUncheckedUpdateWithoutStockPostionInput>
  }

  export type StockSymbolUpdateWithoutStockPostionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    cat?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    online?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    showName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbolShowName?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockSymbolUncheckedUpdateWithoutStockPostionInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    cat?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    online?: IntFieldUpdateOperationsInput | number
    symbol?: StringFieldUpdateOperationsInput | string
    showName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbolShowName?: NullableStringFieldUpdateOperationsInput | string | null
    trade?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    newPrice?: NullableStringFieldUpdateOperationsInput | string | null
    open?: NullableStringFieldUpdateOperationsInput | string | null
    close?: NullableStringFieldUpdateOperationsInput | string | null
    high?: NullableStringFieldUpdateOperationsInput | string | null
    low?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    changePercent?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    sync?: NullableJsonNullValueInput | InputJsonValue
    syncMarket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCreateWithoutMemberDetailInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardCreateNestedManyWithoutMemberInput
    recharges?: RechargeCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberDetailInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionUncheckedCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeUncheckedCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeUncheckedCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawUncheckedCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardUncheckedCreateNestedManyWithoutMemberInput
    recharges?: RechargeUncheckedCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberDetailInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberDetailInput, MemberUncheckedCreateWithoutMemberDetailInput>
  }

  export type MemberUpsertWithoutMemberDetailInput = {
    update: XOR<MemberUpdateWithoutMemberDetailInput, MemberUncheckedUpdateWithoutMemberDetailInput>
    create: XOR<MemberCreateWithoutMemberDetailInput, MemberUncheckedCreateWithoutMemberDetailInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMemberDetailInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMemberDetailInput, MemberUncheckedUpdateWithoutMemberDetailInput>
  }

  export type MemberUpdateWithoutMemberDetailInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberDetailInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUncheckedUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUncheckedUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUncheckedUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUncheckedUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUncheckedUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUncheckedUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutMemberCardsInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawCreateNestedManyWithoutMemberInput
    recharges?: RechargeCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutMemberCardsInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionUncheckedCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailUncheckedCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeUncheckedCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeUncheckedCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawUncheckedCreateNestedManyWithoutMemberInput
    recharges?: RechargeUncheckedCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutMemberCardsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutMemberCardsInput, MemberUncheckedCreateWithoutMemberCardsInput>
  }

  export type MemberUpsertWithoutMemberCardsInput = {
    update: XOR<MemberUpdateWithoutMemberCardsInput, MemberUncheckedUpdateWithoutMemberCardsInput>
    create: XOR<MemberCreateWithoutMemberCardsInput, MemberUncheckedCreateWithoutMemberCardsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutMemberCardsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutMemberCardsInput, MemberUncheckedUpdateWithoutMemberCardsInput>
  }

  export type MemberUpdateWithoutMemberCardsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutMemberCardsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUncheckedUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUncheckedUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUncheckedUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUncheckedUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUncheckedUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUncheckedUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutRechargesInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutRechargesInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionUncheckedCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailUncheckedCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeUncheckedCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeUncheckedCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawUncheckedCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardUncheckedCreateNestedManyWithoutMemberInput
    withdraws?: WithdrawUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutRechargesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutRechargesInput, MemberUncheckedCreateWithoutRechargesInput>
  }

  export type MemberUpsertWithoutRechargesInput = {
    update: XOR<MemberUpdateWithoutRechargesInput, MemberUncheckedUpdateWithoutRechargesInput>
    create: XOR<MemberCreateWithoutRechargesInput, MemberUncheckedCreateWithoutRechargesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutRechargesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutRechargesInput, MemberUncheckedUpdateWithoutRechargesInput>
  }

  export type MemberUpdateWithoutRechargesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutRechargesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUncheckedUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUncheckedUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUncheckedUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUncheckedUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUncheckedUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUncheckedUpdateManyWithoutMemberNestedInput
    withdraws?: WithdrawUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type MemberCreateWithoutWithdrawsInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardCreateNestedManyWithoutMemberInput
    recharges?: RechargeCreateNestedManyWithoutMemberInput
  }

  export type MemberUncheckedCreateWithoutWithdrawsInput = {
    id?: bigint | number
    email: string
    name?: string | null
    avatar?: string | null
    password: string
    gender?: $Enums.GENDER
    address?: string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    type?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: Decimal | DecimalJsLike | number | string
    unBalance?: Decimal | DecimalJsLike | number | string
    lockBalance?: Decimal | DecimalJsLike | number | string
    lastLoginTime?: Date | string | null
    stockPostion?: StockPositionUncheckedCreateNestedManyWithoutMemberInput
    memberDetail?: MemberDetailUncheckedCreateNestedManyWithoutMemberInput
    memberSubscribe?: MemberSubscribeUncheckedCreateNestedManyWithoutMemberInput
    memberRecharges?: MemberRechargeUncheckedCreateNestedManyWithoutMemberInput
    memberWithdraws?: MemberWithdrawUncheckedCreateNestedManyWithoutMemberInput
    memberCards?: MemberCardUncheckedCreateNestedManyWithoutMemberInput
    recharges?: RechargeUncheckedCreateNestedManyWithoutMemberInput
  }

  export type MemberCreateOrConnectWithoutWithdrawsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutWithdrawsInput, MemberUncheckedCreateWithoutWithdrawsInput>
  }

  export type MemberUpsertWithoutWithdrawsInput = {
    update: XOR<MemberUpdateWithoutWithdrawsInput, MemberUncheckedUpdateWithoutWithdrawsInput>
    create: XOR<MemberCreateWithoutWithdrawsInput, MemberUncheckedCreateWithoutWithdrawsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutWithdrawsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutWithdrawsInput, MemberUncheckedUpdateWithoutWithdrawsInput>
  }

  export type MemberUpdateWithoutWithdrawsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUpdateManyWithoutMemberNestedInput
  }

  export type MemberUncheckedUpdateWithoutWithdrawsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    gender?: EnumGENDERFieldUpdateOperationsInput | $Enums.GENDER
    address?: NullableStringFieldUpdateOperationsInput | string | null
    accountBalance?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lockBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLoginTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockPostion?: StockPositionUncheckedUpdateManyWithoutMemberNestedInput
    memberDetail?: MemberDetailUncheckedUpdateManyWithoutMemberNestedInput
    memberSubscribe?: MemberSubscribeUncheckedUpdateManyWithoutMemberNestedInput
    memberRecharges?: MemberRechargeUncheckedUpdateManyWithoutMemberNestedInput
    memberWithdraws?: MemberWithdrawUncheckedUpdateManyWithoutMemberNestedInput
    memberCards?: MemberCardUncheckedUpdateManyWithoutMemberNestedInput
    recharges?: RechargeUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type StockPositionCreateManyMemberInput = {
    id?: bigint | number
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond?: string | null
    identifier?: string | null
    lever?: string | null
    stopLoss?: string | null
    takeProfit?: string | null
    market?: string | null
    type: number
    pl?: string | null
    rate?: string | null
    isBefore?: boolean
    currentPrice?: string | null
    stockSymbolId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberDetailCreateManyMemberInput = {
    id?: bigint | number
    after?: string | null
    amount?: string | null
    before?: string | null
    market?: string | null
    type: number
    remark?: string | null
  }

  export type MemberSubscribeCreateManyMemberInput = {
    id?: bigint | number
    market: string
    code: string
    name: string
    amount: number
    money: Decimal | DecimalJsLike | number | string
    no: string
    winningAmount?: number | null
    winningPrice?: Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: Decimal | DecimalJsLike | number | string | null
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    status?: number
    type?: number
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
    stockSubscribeId: bigint | number
  }

  export type MemberRechargeCreateManyMemberInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    rechargeMoney?: Decimal | DecimalJsLike | number | string
    screen: JsonNullValueInput | InputJsonValue
    market: string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberWithdrawCreateManyMemberInput = {
    id?: bigint | number
    money: Decimal | DecimalJsLike | number | string
    remark?: string | null
    status?: number
    address?: string | null
    market: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberCardCreateManyMemberInput = {
    id?: bigint | number
    name?: string | null
    type: $Enums.RechargeType
    detail: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type RechargeCreateManyMemberInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    account: string
    accountNetwork: string
    screens: JsonNullValueInput | InputJsonValue
    status?: number
    passMoney?: Decimal | DecimalJsLike | number | string
    convertMoney?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type WithdrawCreateManyMemberInput = {
    id?: bigint | number
    market: string
    money: Decimal | DecimalJsLike | number | string
    type: $Enums.RechargeType
    currency: string
    cryptoType?: string | null
    cryptoNetwork?: string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: Decimal | DecimalJsLike | number | string
    status?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockPositionUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockSymbol?: StockSymbolUpdateOneRequiredWithoutStockPostionNestedInput
  }

  export type StockPositionUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    stockSymbolId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockPositionUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    stockSymbolId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberDetailUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    after?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberDetailUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    after?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberDetailUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    after?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    remark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberSubscribeUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    no?: StringFieldUpdateOperationsInput | string
    winningAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockSubscribeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MemberSubscribeUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    no?: StringFieldUpdateOperationsInput | string
    winningAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockSubscribeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MemberSubscribeUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    no?: StringFieldUpdateOperationsInput | string
    winningAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalWinningPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockSubscribeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MemberRechargeUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    screen?: JsonNullValueInput | InputJsonValue
    market?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberRechargeUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    screen?: JsonNullValueInput | InputJsonValue
    market?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberRechargeUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rechargeMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    screen?: JsonNullValueInput | InputJsonValue
    market?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberWithdrawUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberWithdrawUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberWithdrawUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    market?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCardUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    detail?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCardUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    detail?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberCardUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    detail?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    account?: StringFieldUpdateOperationsInput | string
    accountNetwork?: StringFieldUpdateOperationsInput | string
    screens?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    passMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    account?: StringFieldUpdateOperationsInput | string
    accountNetwork?: StringFieldUpdateOperationsInput | string
    screens?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    passMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RechargeUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    account?: StringFieldUpdateOperationsInput | string
    accountNetwork?: StringFieldUpdateOperationsInput | string
    screens?: JsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    passMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    currency?: StringFieldUpdateOperationsInput | string
    cryptoType?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoNetwork?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawUncheckedUpdateWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    currency?: StringFieldUpdateOperationsInput | string
    cryptoType?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoNetwork?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WithdrawUncheckedUpdateManyWithoutMemberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    market?: StringFieldUpdateOperationsInput | string
    money?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumRechargeTypeFieldUpdateOperationsInput | $Enums.RechargeType
    currency?: StringFieldUpdateOperationsInput | string
    cryptoType?: NullableStringFieldUpdateOperationsInput | string | null
    cryptoNetwork?: NullableStringFieldUpdateOperationsInput | string | null
    card?: NullableJsonNullValueInput | InputJsonValue
    convertMoney?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockPositionCreateManyStockSymbolInput = {
    id?: bigint | number
    amount: number
    blast: string
    price: string
    mode: number
    status: number
    bond?: string | null
    identifier?: string | null
    lever?: string | null
    stopLoss?: string | null
    takeProfit?: string | null
    market?: string | null
    type: number
    pl?: string | null
    rate?: string | null
    isBefore?: boolean
    currentPrice?: string | null
    memberId: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type StockPositionUpdateWithoutStockSymbolInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member?: MemberUpdateOneRequiredWithoutStockPostionNestedInput
  }

  export type StockPositionUncheckedUpdateWithoutStockSymbolInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockPositionUncheckedUpdateManyWithoutStockSymbolInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: IntFieldUpdateOperationsInput | number
    blast?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    bond?: NullableStringFieldUpdateOperationsInput | string | null
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    lever?: NullableStringFieldUpdateOperationsInput | string | null
    stopLoss?: NullableStringFieldUpdateOperationsInput | string | null
    takeProfit?: NullableStringFieldUpdateOperationsInput | string | null
    market?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    pl?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableStringFieldUpdateOperationsInput | string | null
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    currentPrice?: NullableStringFieldUpdateOperationsInput | string | null
    memberId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockRecordCreateManyStockInput = {
    id?: bigint | number
    newPrice: string
    open: string
    close: string
    high: string
    low: string
    amount: string
    volume: string
    date: string
    extra: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StockRecordUpdateWithoutStockInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    extra?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockRecordUncheckedUpdateWithoutStockInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    extra?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockRecordUncheckedUpdateManyWithoutStockInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    newPrice?: StringFieldUpdateOperationsInput | string
    open?: StringFieldUpdateOperationsInput | string
    close?: StringFieldUpdateOperationsInput | string
    high?: StringFieldUpdateOperationsInput | string
    low?: StringFieldUpdateOperationsInput | string
    amount?: StringFieldUpdateOperationsInput | string
    volume?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    extra?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MemberCountOutputTypeDefaultArgs instead
     */
    export type MemberCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockSymbolCountOutputTypeDefaultArgs instead
     */
    export type StockSymbolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockSymbolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockCountOutputTypeDefaultArgs instead
     */
    export type StockCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberDefaultArgs instead
     */
    export type MemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberRechargeDefaultArgs instead
     */
    export type MemberRechargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberRechargeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberWithdrawDefaultArgs instead
     */
    export type MemberWithdrawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberWithdrawDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockSymbolDefaultArgs instead
     */
    export type StockSymbolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockSymbolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockDefaultArgs instead
     */
    export type StockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockRecordDefaultArgs instead
     */
    export type StockRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockMarketDefaultArgs instead
     */
    export type StockMarketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockMarketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockFavoriteDefaultArgs instead
     */
    export type StockFavoriteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockFavoriteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockSubscribeDefaultArgs instead
     */
    export type StockSubscribeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockSubscribeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberSubscribeDefaultArgs instead
     */
    export type MemberSubscribeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberSubscribeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockPositionDefaultArgs instead
     */
    export type StockPositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockPositionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberDetailDefaultArgs instead
     */
    export type MemberDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberCardDefaultArgs instead
     */
    export type MemberCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryDefaultArgs instead
     */
    export type CountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingDefaultArgs instead
     */
    export type SettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockResourceDefaultArgs instead
     */
    export type StockResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockResourceRecordDefaultArgs instead
     */
    export type StockResourceRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockResourceRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleDefaultArgs instead
     */
    export type ArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RechargeDefaultArgs instead
     */
    export type RechargeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RechargeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WithdrawDefaultArgs instead
     */
    export type WithdrawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WithdrawDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RechargeAccountDefaultArgs instead
     */
    export type RechargeAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RechargeAccountDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}